<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Word Hunt</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            touch-action: manipulation; /* Prevents zooming on mobile */
            background-color: #15803d; /* dark green */
            background-image: 
                linear-gradient(45deg, rgba(0,0,0,0.08) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.08) 75%), 
                linear-gradient(45deg, rgba(0,0,0,0.08) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.08) 75%);
            background-size: 30px 30px;
            background-position: 0 0, 15px 15px;
        }
        .tile {
            background-color: #f6e0b5; /* Light wood color */
            border: 1px solid #c8a776;
            color: #6d4c41; /* Dark brown text */
            box-shadow: 0 4px #c8a776;
            transition: all 0.1s ease-in-out;
        }
        .tile:active {
            transform: translateY(2px);
            box-shadow: 0 2px #c8a776;
        }
        .tile.selected {
            background-color: #4ade80; /* Bright green */
            color: white;
            border-color: #22c55e;
            box-shadow: 0 4px #22c55e;
            transform: scale(1.05) translateY(-2px);
        }
        .tile.correct {
            animation: correct-word-animation 0.5s ease;
        }
        @keyframes correct-word-animation {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); background-color: #4ade80; }
        }
        .tile.incorrect {
             animation: incorrect-word-animation 0.5s ease;
        }
        @keyframes incorrect-word-animation {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-6px); }
            50% { transform: translateX(6px); }
            75% { transform: translateX(-6px); }
        }
        #current-word-display {
            transition: opacity 0.2s, transform 0.2s;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <div id="game-container" class="w-full max-w-sm mx-auto p-4 flex flex-col items-center">
        
        <!-- Score Header -->
        <div class="bg-white rounded-xl shadow-lg p-3 w-full max-w-xs text-center mb-4">
            <div class="text-sm font-semibold text-gray-500">WORDS: <span id="word-count">0</span></div>
            <div class="text-2xl font-bold text-gray-800">SCORE: <span id="score">0</span></div>
            
            <!-- Game Mode Toggle -->
            <div class="mt-2 flex justify-center">
                <div class="bg-gray-200 rounded-full p-1 flex">
                    <button id="timed-mode-btn" class="px-3 py-1 rounded-full bg-blue-500 text-white text-sm font-medium transition-all">
                        Timed
                    </button>
                    <button id="unlimited-mode-btn" class="px-3 py-1 rounded-full text-gray-700 text-sm font-medium transition-all">
                        Unlimited
                    </button>
                </div>
            </div>
        </div>

        <!-- Timer -->
        <div id="timer-display" class="bg-black/25 text-white text-sm font-mono rounded-full px-3 py-1 mb-4">
            00:00
        </div>

        <!-- Current Word Preview -->
        <div id="current-word-display" class="h-10 mb-2 opacity-0 transform -translate-y-2">
             <div class="bg-green-500 text-white font-bold text-lg rounded-full px-5 py-2 shadow-md">
                <span id="current-word"></span>
            </div>
        </div>


        <!-- Game Grid -->
        <div id="grid-container" class="grid grid-cols-4 gap-2 md:gap-3 aspect-square select-none w-full max-w-xs bg-green-800/50 rounded-lg p-2 border-2 border-black/10">
            <!-- Tiles will be generated by JavaScript -->
        </div>

    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center w-11/12 max-w-md transform transition-all scale-95 opacity-0">
            <h2 class="text-4xl font-bold text-gray-800 mb-2" id="game-over-title">Time's Up!</h2>
            <p class="text-lg text-gray-600 mb-4">Your final score is:</p>
            <p id="final-score" class="text-6xl font-extrabold text-blue-500 mb-6">0</p>
            
            <!-- High Score Section -->
            <div class="mb-6 bg-gray-50 p-4 rounded-lg">
                <h3 class="text-xl font-semibold mb-2 text-gray-700">High Scores</h3>
                <div id="high-scores-list" class="text-left">
                    <div class="flex justify-between items-center py-1 border-b border-gray-200">
                        <span class="font-medium">Loading scores...</span>
                        <span></span>
                    </div>
                </div>
            </div>
            
            <div class="flex flex-col space-y-3">
                <button id="play-again-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg text-xl transition duration-300 transform hover:scale-105">
                    Play Again
                </button>
                
                <button id="show-all-words-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-xl transition duration-300 transform hover:scale-105">
                    Show All Possible Words
                </button>
            </div>
            
            <div id="all-possible-words" class="mt-6 hidden">
                <h3 class="text-xl font-semibold mb-2">All Possible Words</h3>
                
                <!-- Sorting options -->
                <div class="flex justify-between items-center mb-2">
                    <span class="text-sm text-gray-600">Sort by:</span>
                    <div class="flex space-x-2">
                        <button id="sort-length-desc" class="px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded hover:bg-blue-200 active-sort">
                            Length ↓
                        </button>
                        <button id="sort-alpha" class="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded hover:bg-gray-200">
                            A-Z
                        </button>
                        <button id="sort-value-desc" class="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded hover:bg-gray-200">
                            Value ↓
                        </button>
                        <button id="sort-value-asc" class="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded hover:bg-gray-200">
                            Value ↑
                        </button>
                    </div>
                </div>
                
                <div class="max-h-60 overflow-y-auto">
                    <div id="possible-words-list" class="grid grid-cols-2 gap-2 text-left"></div>
                    <p id="possible-words-count" class="mt-2 text-sm text-gray-500"></p>
                </div>
            </div>
        </div>
    </div>


    <script>
        const gridContainer = document.getElementById('grid-container');
        const scoreEl = document.getElementById('score');
        const timerDisplayEl = document.getElementById('timer-display');
        const currentWordDisplayEl = document.getElementById('current-word-display');
        const currentWordEl = document.getElementById('current-word');
        const wordCountEl = document.getElementById('word-count');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreEl = document.getElementById('final-score');
        const playAgainBtn = document.getElementById('play-again-btn');

        // Constants
        const GRID_SIZE = 4;
        const GAME_TIME = 80; // seconds
        const DICTIONARY_URL = 'https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt';
        const GAME_MODE = {
            TIMED: 'timed',
            UNLIMITED: 'unlimited'
        };

        // Letter distribution (weighted to favor common letters)
        const LETTER_DISTRIBUTION = "AAAAAAAAABBCCDDDDEEEEEEEEEEEEFFGGGHHIIIIIIIIIJKLLLLMMNNNNNNOOOOOOOOOPPQRRRRRRSSSSSTTTTTTTTUUUUVVWWXYYZ";

        // Game variables
        let grid = [];
        let score = 0;
        let timer = GAME_TIME;
        let timerInterval;
        let foundWords = new Set();
        let isMouseDown = false;
        let currentPath = []; // Stores {row, col} of the current path
        let englishWords = new Set(); // Will store our dictionary
        let currentGameMode = GAME_MODE.TIMED; // Default game mode

        // High scores management
        const HIGH_SCORES_KEY_TIMED = 'wordHuntHighScoresTimed';
        const HIGH_SCORES_KEY_UNLIMITED = 'wordHuntHighScoresUnlimited';
        const MAX_HIGH_SCORES = 5;
        let highScores = [];

        // Secret menu variables
        let secretCode = '';
        let secretCodeTimeout;
        const SECRET_COMMANDS = {
            'GODMODE': enableGodMode,
            'ALLWORDS': showAllWordsCheat,
            'EXTRATIME': addExtraTime,
            'RAINBOW': enableRainbowMode,
            'BIGPOINTS': enableBigPointsMode,
            'SLOWTIME': enableSlowTimeMode,
            'DARKMODE': toggleDarkMode,
            'CONFETTI': triggerConfetti,
            'SHUFFLE': shuffleGrid,
            'MATRIX': enableMatrixMode,
            'ENDGAME': endGameCommand
        };
        let godModeEnabled = false;
        let rainbowModeEnabled = false;
        let bigPointsModeEnabled = false;
        let slowTimeEnabled = false;
        let darkModeEnabled = false;
        let matrixModeEnabled = false;

        // Load high scores from localStorage
        function loadHighScores() {
            try {
                const key = currentGameMode === GAME_MODE.TIMED ? HIGH_SCORES_KEY_TIMED : HIGH_SCORES_KEY_UNLIMITED;
                const savedScores = localStorage.getItem(key);
                if (savedScores) {
                    highScores = JSON.parse(savedScores);
                    console.log(`Loaded ${currentGameMode} high scores:`, highScores);
                } else {
                    highScores = [];
                    console.log(`No saved ${currentGameMode} high scores found`);
                }
            } catch (error) {
                console.error("Error loading high scores:", error);
                highScores = [];
            }
        }

        // Save high scores to localStorage
        function saveHighScores() {
            try {
                const key = currentGameMode === GAME_MODE.TIMED ? HIGH_SCORES_KEY_TIMED : HIGH_SCORES_KEY_UNLIMITED;
                localStorage.setItem(key, JSON.stringify(highScores));
                console.log(`Saved ${currentGameMode} high scores:`, highScores);
            } catch (error) {
                console.error("Error saving high scores:", error);
            }
        }

        // Update high scores with current score
        function updateHighScores() {
            // Create a new score entry
            const newScore = {
                score: score,
                date: new Date().toISOString(),
                words: foundWords.size
            };
            
            // Add the new score to the array
            highScores.push(newScore);
            
            // Sort by score (descending)
            highScores.sort((a, b) => b.score - a.score);
            
            // Keep only the top scores
            highScores = highScores.slice(0, MAX_HIGH_SCORES);
            
            // Save to localStorage
            saveHighScores();
            
            // Update the display
            displayHighScores();
        }

        // Display high scores in the modal
        function displayHighScores() {
            const highScoresList = document.getElementById('high-scores-list');
            if (!highScoresList) return;
            
            highScoresList.innerHTML = '';
            
            // Add game mode indicator
            const modeIndicator = document.createElement('div');
            modeIndicator.className = 'mb-2 text-center';
            modeIndicator.innerHTML = `
                <span class="inline-block px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-xs font-medium">
                    ${currentGameMode === GAME_MODE.TIMED ? 'Timed Mode' : 'Unlimited Mode'} High Scores
                </span>
            `;
            highScoresList.appendChild(modeIndicator);
            
            if (highScores.length === 0) {
                highScoresList.innerHTML += '<div class="text-center py-2 text-gray-500">No high scores yet</div>';
                return;
            }
            
            // Add each high score
            highScores.forEach((scoreData, index) => {
                const scoreRow = document.createElement('div');
                scoreRow.className = 'flex justify-between items-center py-1 border-b border-gray-200';
                
                // Add medal emoji for top 3
                let rankDisplay = `${index + 1}.`;
                if (index === 0) rankDisplay = '🥇 ' + rankDisplay;
                else if (index === 1) rankDisplay = '🥈 ' + rankDisplay;
                else if (index === 2) rankDisplay = '🥉 ' + rankDisplay;
                
                // Format date
                const scoreDate = new Date(scoreData.date);
                const dateStr = scoreDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                
                // Highlight if this is the current score
                const isCurrentScore = scoreData.score === score && 
                                      scoreData.words === foundWords.size && 
                                      new Date().getTime() - scoreDate.getTime() < 60000; // Within the last minute
                
                if (isCurrentScore) {
                    scoreRow.className += ' bg-blue-50';
                }
                
                scoreRow.innerHTML = `
                    <span class="font-medium">${rankDisplay} <span class="text-gray-600">${dateStr}</span></span>
                    <span class="font-bold ${isCurrentScore ? 'text-blue-600' : ''}">${scoreData.score} <span class="text-sm font-normal">(${scoreData.words} words)</span></span>
                `;
                
                highScoresList.appendChild(scoreRow);
            });
        }

        function init() {
            // Reset game state
            score = 0;
            timer = GAME_TIME;
            foundWords = new Set();
            currentPath = [];
            
            // Update UI elements
            const scoreEl = document.getElementById('score');
            if (scoreEl) scoreEl.textContent = '0';
            
            // Update timer display based on game mode
            const timerDisplayEl = document.getElementById('timer-display');
            if (timerDisplayEl) {
                if (currentGameMode === GAME_MODE.TIMED) {
                    updateTimerDisplay();
                } else {
                    timerDisplayEl.textContent = "End Game";
                    timerDisplayEl.classList.add('bg-red-500', 'hover:bg-red-600', 'cursor-pointer');
                    timerDisplayEl.title = "Click to end the game";
                }
            }
            
            const wordCountEl = document.getElementById('word-count');
            if (wordCountEl) wordCountEl.textContent = '0';
            
            const currentWordDisplayEl = document.getElementById('current-word-display');
            if (currentWordDisplayEl) {
                currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
            }
            
            // Hide game over modal
            const gameOverModal = document.getElementById('game-over-modal');
            if (gameOverModal) {
                gameOverModal.classList.add('hidden');
                const modalContent = gameOverModal.querySelector('div');
                if (modalContent) {
                    modalContent.classList.add('scale-95', 'opacity-0');
                }
            }

            // Generate and render the grid
            generateGrid();
            renderGrid();
            
            // Start the timer and add event listeners
            if (currentGameMode === GAME_MODE.TIMED) {
                startTimer();
            } else {
                // For unlimited mode, just show "--:--" in the timer
                const timerDisplayEl = document.getElementById('timer-display');
                if (timerDisplayEl) {
                    timerDisplayEl.textContent = "END GAME";
                }
            }
            
            addEventListeners();
            
            console.log(`Game initialized in ${currentGameMode} mode with grid:`, grid);
        }

        function generateGrid() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                const row = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    const randomIndex = Math.floor(Math.random() * LETTER_DISTRIBUTION.length);
                    const randomLetter = LETTER_DISTRIBUTION[randomIndex];
                    row.push(randomLetter);
                }
                grid.push(row);
            }
            console.log("Generated grid:", grid);
        }

        function renderGrid() {
            const gridContainer = document.getElementById('grid-container');
            if (!gridContainer) {
                console.error("Grid container not found!");
                return;
            }
            
            gridContainer.innerHTML = '';
            
            grid.forEach((row, rowIndex) => {
                row.forEach((letter, colIndex) => {
                    const tile = document.createElement('div');
                    tile.textContent = letter;
                    tile.dataset.row = rowIndex;
                    tile.dataset.col = colIndex;
                    tile.classList.add('tile', 'flex', 'items-center', 'justify-center', 'text-2xl', 'md:text-3xl', 'font-bold', 'rounded-md', 'cursor-pointer');
                    gridContainer.appendChild(tile);
                });
            });
            
            console.log("Grid rendered with", gridContainer.children.length, "tiles");
        }
        
        function addEventListeners() {
            const events = [
                ['mousedown', handleInteractionStart],
                ['mouseup', handleInteractionEnd],
                ['mouseover', handleInteractionMove],
                ['touchstart', handleInteractionStart, { passive: false }],
                ['touchend', handleInteractionEnd],
                ['touchmove', handleInteractionMove, { passive: false }]
            ];
            
            // Cleanup previous listeners
            events.forEach(([event, handler, options]) => {
                const target = ['mouseup', 'touchend'].includes(event) ? document : gridContainer;
                target.removeEventListener(event, handler, options);
            });
            
            // Add new listeners
            events.forEach(([event, handler, options]) => {
                const target = ['mouseup', 'touchend'].includes(event) ? document : gridContainer;
                target.addEventListener(event, handler, options);
            });
        }
        
        function updateTimerDisplay() {
            const timerDisplayEl = document.getElementById('timer-display');
            if (!timerDisplayEl) {
                console.error("Timer display element not found!");
                return;
            }
            
            const minutes = Math.floor(timer / 60).toString().padStart(2, '0');
            const seconds = (timer % 60).toString().padStart(2, '0');
            timerDisplayEl.textContent = `${minutes}:${seconds}`;
            console.log("Timer updated:", timerDisplayEl.textContent);
        }

        function startTimer() {
            clearInterval(timerInterval);
            updateTimerDisplay(); // Update immediately
            
            timerInterval = setInterval(() => {
                timer--;
                updateTimerDisplay();
                
                if (timer <= 0) {
                    endGame();
                }
            }, 1000);
            
            console.log("Timer started with", timer, "seconds");
        }

        // End the game
        function endGame() {
            // Clear the timer interval
            clearInterval(timerInterval);
            
            // Update the final score
            const finalScoreEl = document.getElementById('final-score');
            if (finalScoreEl) {
                finalScoreEl.textContent = score;
            }
            
            // Update the game over title based on game mode
            const gameOverTitle = document.getElementById('game-over-title');
            if (gameOverTitle) {
                gameOverTitle.textContent = currentGameMode === GAME_MODE.TIMED ? "Time's Up!" : "Game Over!";
            }
            
            // Update high scores
            updateHighScores();
            
            // Reset the all possible words section
            const allPossibleWordsSection = document.getElementById('all-possible-words');
            if (allPossibleWordsSection) {
                allPossibleWordsSection.classList.add('hidden');
            }
            
            // Show the game over modal
            const gameOverModal = document.getElementById('game-over-modal');
            if (gameOverModal) {
                // Update the high scores section title to include mode
                const highScoresTitle = gameOverModal.querySelector('h3');
                if (highScoresTitle) {
                    highScoresTitle.textContent = `High Scores (${currentGameMode === GAME_MODE.TIMED ? 'Timed Mode' : 'Unlimited Mode'})`;
                }
                
                // Add mode switching tabs if they don't exist
                if (!gameOverModal.querySelector('.mode-tabs')) {
                    const highScoresSection = gameOverModal.querySelector('.mb-6.bg-gray-50.p-4.rounded-lg');
                    if (highScoresSection) {
                        const modeTabs = document.createElement('div');
                        modeTabs.className = 'mode-tabs flex mb-3 border-b border-gray-200';
                        modeTabs.innerHTML = `
                            <button class="flex-1 py-2 px-3 text-sm font-medium ${currentGameMode === GAME_MODE.TIMED ? 'text-blue-600 border-b-2 border-blue-500' : 'text-gray-500 hover:text-gray-700'}" data-mode="timed">
                                Timed Mode
                            </button>
                            <button class="flex-1 py-2 px-3 text-sm font-medium ${currentGameMode === GAME_MODE.UNLIMITED ? 'text-blue-600 border-b-2 border-blue-500' : 'text-gray-500 hover:text-gray-700'}" data-mode="unlimited">
                                Unlimited Mode
                            </button>
                        `;
                        
                        // Insert tabs before the high scores list
                        highScoresSection.insertBefore(modeTabs, highScoresSection.querySelector('h3'));
                        
                        // Add event listeners to the tabs
                        modeTabs.querySelectorAll('button').forEach(tab => {
                            tab.addEventListener('click', () => {
                                const mode = tab.getAttribute('data-mode');
                                
                                // Update active tab styling
                                modeTabs.querySelectorAll('button').forEach(t => {
                                    t.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                                    t.classList.add('text-gray-500', 'hover:text-gray-700');
                                });
                                tab.classList.remove('text-gray-500', 'hover:text-gray-700');
                                tab.classList.add('text-blue-600', 'border-b-2', 'border-blue-500');
                                
                                // Load and display high scores for the selected mode
                                const tempCurrentMode = currentGameMode;
                                currentGameMode = mode === 'timed' ? GAME_MODE.TIMED : GAME_MODE.UNLIMITED;
                                loadHighScores();
                                displayHighScores();
                                
                                // Update the high scores section title
                                const highScoresTitle = highScoresSection.querySelector('h3');
                                if (highScoresTitle) {
                                    highScoresTitle.textContent = `High Scores (${currentGameMode === GAME_MODE.TIMED ? 'Timed Mode' : 'Unlimited Mode'})`;
                                }
                                
                                // Restore the actual current mode (for when the game restarts)
                                currentGameMode = tempCurrentMode;
                            });
                        });
                    }
                } else {
                    // Update active tab styling
                    const modeTabs = gameOverModal.querySelector('.mode-tabs');
                    if (modeTabs) {
                        modeTabs.querySelectorAll('button').forEach(tab => {
                            const mode = tab.getAttribute('data-mode');
                            if ((mode === 'timed' && currentGameMode === GAME_MODE.TIMED) || 
                                (mode === 'unlimited' && currentGameMode === GAME_MODE.UNLIMITED)) {
                                tab.classList.remove('text-gray-500', 'hover:text-gray-700');
                                tab.classList.add('text-blue-600', 'border-b-2', 'border-blue-500');
                            } else {
                                tab.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                                tab.classList.add('text-gray-500', 'hover:text-gray-700');
                            }
                        });
                    }
                }
                
                gameOverModal.classList.remove('hidden');
                
                // Animate the modal
                setTimeout(() => {
                    const modalContent = gameOverModal.querySelector('div');
                    if (modalContent) {
                        modalContent.classList.remove('scale-95', 'opacity-0');
                    }
                }, 50);
            }
            
            console.log(`Game ended in ${currentGameMode} mode with score:`, score);
        }

        // Make endGame available globally for console access
        window.endGame = endGame;
        
        function handleInteractionStart(e) {
            e.preventDefault();
            isMouseDown = true;
            const tile = getTileFromEvent(e);
            if (tile) {
                startPath(tile);
            }
        }

        function handleInteractionMove(e) {
            if (!isMouseDown) return;
            e.preventDefault();
            const tile = getTileFromEvent(e);
            if (tile) {
                continuePath(tile);
            }
        }
        
        async function handleInteractionEnd(e) {
            if (!isMouseDown) return;
            isMouseDown = false;
            
            const word = getWordFromPath();
            if (word.length >= 3) {
                // Check word immediately without delay
                await checkWord(word);
            } else {
                // For words shorter than 3 letters, just reset the path
                currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                resetPath();
            }
        }
        
        function getTileFromEvent(e) {
            let target;
            if (e.touches && e.touches.length > 0) {
                const touch = e.touches[0];
                target = document.elementFromPoint(touch.clientX, touch.clientY);
            } else {
                target = e.target;
            }
            return target && target.classList.contains('tile') ? target : null;
        }

        function startPath(tile) {
            currentPath.push({ row: parseInt(tile.dataset.row), col: parseInt(tile.dataset.col) });
            tile.classList.add('selected');
            updateCurrentWord();
        }

        function continuePath(tile) {
            if (currentPath.length === 0) {
                startPath(tile);
                return;
            }
            
            const row = parseInt(tile.dataset.row);
            const col = parseInt(tile.dataset.col);
            
            if (currentPath.some(p => p.row === row && p.col === col)) return;

            const lastTile = currentPath[currentPath.length - 1];
            const isAdjacent = Math.abs(lastTile.row - row) <= 1 && Math.abs(lastTile.col - col) <= 1;

            if (isAdjacent) {
                currentPath.push({ row, col });
                tile.classList.add('selected');
                updateCurrentWord();
            }
        }
        
        function getWordFromPath() {
             return currentPath.map(p => grid[p.row][p.col]).join('');
        }
        
        function calculatePoints(wordLength) {
            if (wordLength === 3) return 100;
            if (wordLength === 4) return 400;
            if (wordLength === 5) return 800;
            if (wordLength === 6) return 1400;
            if (wordLength === 7) return 1800;
            if (wordLength >= 8) return 2200;
            return 0;
        }

        function updateCurrentWord() {
            const word = getWordFromPath();
            if (word) {
                // Don't show points yet, just show the word
                currentWordEl.textContent = word;
                currentWordDisplayEl.classList.remove('opacity-0', 'transform', '-translate-y-2');
            }
        }
        
        function animatePath(animationClass) {
            currentPath.forEach(p => {
                const tile = gridContainer.querySelector(`[data-row='${p.row}'][data-col='${p.col}']`);
                if (tile) {
                    tile.classList.add(animationClass);
                    setTimeout(() => tile.classList.remove(animationClass), 500);
                }
            });
        }

        function resetPath() {
            // Remove the 'selected' class from all tiles
            document.querySelectorAll('.tile.selected').forEach(tile => {
                tile.classList.remove('selected');
            });
            
            // Clear the current path
            currentPath = [];
        }

        async function checkWord(word) {
            // First check if the word has already been found
            if (foundWords.has(word)) {
                // Show the word with 0 points
                currentWordEl.textContent = `${word} (+0)`;
                // Immediately animate and reset
                animatePath('incorrect');
                setTimeout(() => {
                    currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                    resetPath();
                }, 500);
                return;
            }

            // Check if the word is in our dictionary first (faster than API call)
            if (englishWords.has(word)) {
                // Valid word - show points and update score immediately
                const points = calculatePoints(word.length);
                currentWordEl.textContent = `${word} (+${points})`;
                foundWords.add(word);
                updateScore(word);
                animatePath('correct');
                setTimeout(() => {
                    resetPath();
                }, 300);
                return;
            }

            // If not in our dictionary, try the API as a backup
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (response.ok) {
                    // Valid word - show points and update score immediately
                    const points = calculatePoints(word.length);
                    currentWordEl.textContent = `${word} (+${points})`;
                    foundWords.add(word);
                    updateScore(word);
                    animatePath('correct');
                    setTimeout(() => {
                        resetPath();
                    }, 300);
                } else {
                    // Invalid word - show 0 points
                    currentWordEl.textContent = `${word} (+0)`;
                    animatePath('incorrect');
                    setTimeout(() => {
                        currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                        resetPath();
                    }, 500);
                }
            } catch (error) {
                console.error("Dictionary API error:", error);
                // In case of API error, treat as invalid
                currentWordEl.textContent = `${word} (+0)`;
                animatePath('incorrect');
                setTimeout(() => {
                    currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                    resetPath();
                }, 500);
            }
        }

        function updateScore(word) {
            score += calculatePoints(word.length);
            scoreEl.textContent = score;
            wordCountEl.textContent = foundWords.size;
        }
        
        playAgainBtn.addEventListener('click', init);
        window.onload = init;

        // Find all possible words on the board
        function findAllPossibleWords() {
            console.log("Finding all possible words...");
            
            // Create a set to store unique words
            const possibleWords = new Set();
            
            // Create a visited array to track visited cells during DFS
            const visited = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(false));
            
            // Try starting from each cell
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    // Start DFS from this cell
                    dfs(i, j, "", visited, possibleWords);
                }
            }
            
            // Convert set to array, filter valid words, and sort
            const validWords = Array.from(possibleWords)
                .filter(word => word.length >= 3 && englishWords.has(word));
            
            console.log(`Found ${validWords.length} possible words`);
            return validWords;
        }

        // Depth-first search to find words
        function dfs(row, col, currentWord, visited, possibleWords) {
            // Check if out of bounds or already visited
            if (row < 0 || row >= GRID_SIZE || col < 0 || col >= GRID_SIZE || visited[row][col]) {
                return;
            }
            
            // Add current letter to the word
            const newWord = currentWord + grid[row][col];
            
            // Mark current cell as visited
            visited[row][col] = true;
            
            // If the word is valid (3+ letters), add it to the set
            if (newWord.length >= 3 && englishWords.has(newWord)) {
                possibleWords.add(newWord);
            }
            
            // Explore all 8 adjacent cells
            const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
            
            for (const [dx, dy] of directions) {
                dfs(row + dx, col + dy, newWord, visited, possibleWords);
            }
            
            // Backtrack: mark current cell as unvisited
            visited[row][col] = false;
        }

        // Show all possible words in the modal
        function showAllPossibleWords() {
            console.log("Showing all possible words...");
            
            const allPossibleWordsSection = document.getElementById('all-possible-words');
            const possibleWordsList = document.getElementById('possible-words-list');
            const possibleWordsCount = document.getElementById('possible-words-count');
            
            // Show loading indicator
            possibleWordsList.innerHTML = '<div class="col-span-2 text-center py-4">Finding all possible words...</div>';
            allPossibleWordsSection.classList.remove('hidden');
            
            // Use setTimeout to allow the UI to update before starting the intensive calculation
            setTimeout(() => {
                try {
                    // Find all possible words
                    const possibleWords = findAllPossibleWords();
                    
                    // Store the words in a global variable for sorting
                    window.allPossibleWords = possibleWords.map(word => ({
                        word: word,
                        length: word.length,
                        value: calculatePoints(word.length),
                        found: foundWords.has(word.toLowerCase())
                    }));
                    
                    // Display the words (default sort by length)
                    displayPossibleWords('length-desc');
                    
                    // Set up sorting buttons
                    setupSortingButtons();
                    
                } catch (error) {
                    console.error("Error finding possible words:", error);
                    possibleWordsList.innerHTML = '<div class="col-span-2 text-center py-4 text-red-500">Error finding words</div>';
                }
            }, 100);
        }

        // Display possible words with the specified sorting
        function displayPossibleWords(sortType) {
            const possibleWordsList = document.getElementById('possible-words-list');
            const possibleWordsCount = document.getElementById('possible-words-count');
            
            if (!possibleWordsList || !window.allPossibleWords) return;
            
            // Clear the list
            possibleWordsList.innerHTML = '';
            
            if (window.allPossibleWords.length === 0) {
                possibleWordsList.innerHTML = '<div class="col-span-2 text-center py-4">No words found</div>';
                return;
            }
            
            // Sort the words based on the selected sort type
            let sortedWords = [...window.allPossibleWords];
            
            switch (sortType) {
                case 'alpha':
                    sortedWords.sort((a, b) => a.word.localeCompare(b.word));
                    break;
                case 'length-desc':
                    sortedWords.sort((a, b) => b.length - a.length || a.word.localeCompare(b.word));
                    break;
                case 'value-desc':
                    sortedWords.sort((a, b) => b.value - a.value || a.word.localeCompare(b.word));
                    break;
                case 'value-asc':
                    sortedWords.sort((a, b) => a.value - b.value || a.word.localeCompare(b.word));
                    break;
            }
            
            // Group words by length or value depending on sort type
            const groupBy = sortType.startsWith('length') ? 'length' : 
                           (sortType === 'alpha' ? null : 'value');
            
            if (groupBy) {
                // Group by length or value
                const wordsByGroup = {};
                sortedWords.forEach(wordObj => {
                    const groupValue = wordObj[groupBy];
                    if (!wordsByGroup[groupValue]) {
                        wordsByGroup[groupValue] = [];
                    }
                    wordsByGroup[groupValue].push(wordObj);
                });
                
                // Get group keys and sort them
                let groupKeys = Object.keys(wordsByGroup).map(Number);
                if (sortType === 'length-desc' || sortType === 'value-desc') {
                    groupKeys.sort((a, b) => b - a);
                } else {
                    groupKeys.sort((a, b) => a - b);
                }
                
                // Display words grouped by length or value
                groupKeys.forEach(groupValue => {
                    // Create a section for this group
                    const groupSection = document.createElement('div');
                    groupSection.className = 'col-span-2 mt-2 first:mt-0';
                    
                    const groupLabel = groupBy === 'length' ? 
                        `${groupValue}-letter words (${wordsByGroup[groupValue].length})` : 
                        `${groupValue} points (${wordsByGroup[groupValue].length})`;
                        
                    groupSection.innerHTML = `<h4 class="font-semibold text-sm text-gray-700">${groupLabel}</h4>`;
                    possibleWordsList.appendChild(groupSection);
                    
                    // Add each word
                    wordsByGroup[groupValue].forEach(wordObj => {
                        const wordEl = document.createElement('div');
                        wordEl.className = 'px-2 py-1 text-sm';
                        
                        // Highlight words that were found by the player
                        if (wordObj.found) {
                            wordEl.className += ' bg-green-100 text-green-800 rounded';
                            wordEl.innerHTML = `${wordObj.word} <span class="text-xs">✓</span>`;
                        } else {
                            wordEl.textContent = wordObj.word;
                        }
                        
                        possibleWordsList.appendChild(wordEl);
                    });
                });
            } else {
                // Alphabetical sort - no grouping
                sortedWords.forEach(wordObj => {
                    const wordEl = document.createElement('div');
                    wordEl.className = 'px-2 py-1 text-sm';
                    
                    // Highlight words that were found by the player
                    if (wordObj.found) {
                        wordEl.className += ' bg-green-100 text-green-800 rounded';
                        wordEl.innerHTML = `${wordObj.word} <span class="text-xs">✓</span>`;
                    } else {
                        wordEl.textContent = wordObj.word;
                    }
                    
                    possibleWordsList.appendChild(wordEl);
                });
            }
            
            // Update the count
            const foundCount = window.allPossibleWords.filter(wordObj => wordObj.found).length;
            possibleWordsCount.textContent = `You found ${foundCount} out of ${window.allPossibleWords.length} possible words (${Math.round((foundCount / window.allPossibleWords.length) * 100) || 0}%)`;
        }

        // Set up sorting buttons
        function setupSortingButtons() {
            const sortButtons = [
                { id: 'sort-length-desc', type: 'length-desc' },
                { id: 'sort-alpha', type: 'alpha' },
                { id: 'sort-value-desc', type: 'value-desc' },
                { id: 'sort-value-asc', type: 'value-asc' }
            ];
            
            sortButtons.forEach(button => {
                const buttonEl = document.getElementById(button.id);
                if (buttonEl) {
                    buttonEl.addEventListener('click', () => {
                        // Update active button styling
                        sortButtons.forEach(b => {
                            const el = document.getElementById(b.id);
                            if (el) {
                                el.classList.remove('bg-blue-100', 'text-blue-800', 'active-sort');
                                el.classList.add('bg-gray-100', 'text-gray-800');
                            }
                        });
                        
                        buttonEl.classList.remove('bg-gray-100', 'text-gray-800');
                        buttonEl.classList.add('bg-blue-100', 'text-blue-800', 'active-sort');
                        
                        // Display words with the selected sorting
                        displayPossibleWords(button.type);
                    });
                }
            });
        }

        // Set up event listeners
        function setupEventListeners() {
            // Play again button
            const playAgainBtn = document.getElementById('play-again-btn');
            if (playAgainBtn) {
                playAgainBtn.addEventListener('click', () => {
                    // Hide the game over modal
                    const gameOverModal = document.getElementById('game-over-modal');
                    if (gameOverModal) {
                        const modalContent = gameOverModal.querySelector('div');
                        if (modalContent) {
                            modalContent.classList.add('scale-95', 'opacity-0');
                        }
                        
                        setTimeout(() => {
                            gameOverModal.classList.add('hidden');
                            // Start a new game
                            init();
                        }, 300);
                    }
                });
            }
            
            // Show all words button
            const showAllWordsBtn = document.getElementById('show-all-words-btn');
            if (showAllWordsBtn) {
                showAllWordsBtn.addEventListener('click', () => {
                    console.log("Show all words button clicked");
                    showAllPossibleWords();
                });
            }
            
            // Game mode toggle buttons
            const timedModeBtn = document.getElementById('timed-mode-btn');
            const unlimitedModeBtn = document.getElementById('unlimited-mode-btn');
            
            if (timedModeBtn && unlimitedModeBtn) {
                timedModeBtn.addEventListener('click', () => {
                    if (currentGameMode !== GAME_MODE.TIMED) {
                        setGameMode(GAME_MODE.TIMED);
                    }
                });
                
                unlimitedModeBtn.addEventListener('click', () => {
                    if (currentGameMode !== GAME_MODE.UNLIMITED) {
                        setGameMode(GAME_MODE.UNLIMITED);
                    }
                });
            }
            
            // Add end game button for unlimited mode
            const timerDisplayEl = document.getElementById('timer-display');
            if (timerDisplayEl) {
                timerDisplayEl.addEventListener('click', () => {
                    if (currentGameMode === GAME_MODE.UNLIMITED) {
                        endGame();
                    }
                });
            }
        }

        // Set the game mode
        function setGameMode(mode) {
            if (mode === currentGameMode) return;
            
            currentGameMode = mode;
            
            // Update UI to reflect the current mode
            const timedModeBtn = document.getElementById('timed-mode-btn');
            const unlimitedModeBtn = document.getElementById('unlimited-mode-btn');
            const timerDisplayEl = document.getElementById('timer-display');
            
            if (timedModeBtn && unlimitedModeBtn) {
                if (mode === GAME_MODE.TIMED) {
                    timedModeBtn.classList.add('bg-blue-500', 'text-white');
                    timedModeBtn.classList.remove('text-gray-700');
                    unlimitedModeBtn.classList.remove('bg-blue-500', 'text-white');
                    unlimitedModeBtn.classList.add('text-gray-700');
                    
                    // Show timer display
                    if (timerDisplayEl) {
                        timerDisplayEl.textContent = `${Math.floor(timer / 60).toString().padStart(2, '0')}:${(timer % 60).toString().padStart(2, '0')}`;
                        timerDisplayEl.classList.remove('bg-red-500', 'hover:bg-red-600', 'cursor-pointer');
                        timerDisplayEl.title = "";
                    }
                } else {
                    unlimitedModeBtn.classList.add('bg-blue-500', 'text-white');
                    unlimitedModeBtn.classList.remove('text-gray-700');
                    timedModeBtn.classList.remove('bg-blue-500', 'text-white');
                    timedModeBtn.classList.add('text-gray-700');
                    
                    // Replace timer with end game button
                    if (timerDisplayEl) {
                        clearInterval(timerInterval);
                        timerDisplayEl.textContent = "End Game";
                        timerDisplayEl.classList.add('bg-red-500', 'hover:bg-red-600', 'cursor-pointer');
                        timerDisplayEl.title = "Click to end the game";
                    }
                }
            }
            
            // Load high scores for the selected mode
            loadHighScores();
            
            // Start a new game with the new mode
            init();
            
            console.log(`Game mode changed to: ${mode}`);
        }

        // Load the English words dictionary
        async function loadDictionary() {
            try {
                console.log('Loading dictionary from:', DICTIONARY_URL);
                const response = await fetch(DICTIONARY_URL);
                
                if (!response.ok) {
                    throw new Error(`Failed to load dictionary: ${response.status} ${response.statusText}`);
                }
                
                const text = await response.text();
                const words = text.split('\n')
                    .map(word => word.trim().toUpperCase())
                    .filter(word => word.length >= 3); // Only keep words with 3+ letters
                
                englishWords = new Set(words);
                console.log(`Successfully loaded ${englishWords.size} words from dictionary`);
            } catch (error) {
                console.error('Error loading dictionary:', error);
                
                // Fallback to a smaller set of common words if needed
                alert('Failed to load dictionary. Using a smaller word set instead.');
                // You might want to define a COMMON_WORDS array as fallback
            }
        }

        // Add secret menu functionality
        function setupSecretMenu() {
            // Listen for key presses to detect secret code
            document.addEventListener('keydown', (e) => {
                // Only capture letter keys
                if (/^[a-zA-Z]$/.test(e.key)) {
                    secretCode += e.key.toUpperCase();
                    
                    // Reset the timeout
                    clearTimeout(secretCodeTimeout);
                    
                    // Check if the current code matches any commands
                    Object.keys(SECRET_COMMANDS).forEach(command => {
                        if (secretCode.endsWith(command)) {
                            // Execute the command
                            SECRET_COMMANDS[command]();
                            
                            // Show a notification
                            showSecretCommandNotification(command);
                            
                            // Reset the code
                            secretCode = '';
                            return;
                        }
                    });
                    
                    // Set a timeout to reset the code after 2 seconds of inactivity
                    secretCodeTimeout = setTimeout(() => {
                        secretCode = '';
                    }, 2000);
                }
            });
            
            console.log("Secret menu initialized. Try typing secret commands!");
        }

        // Secret command functions
        function enableGodMode() {
            godModeEnabled = !godModeEnabled;
            console.log(`God Mode ${godModeEnabled ? 'enabled' : 'disabled'}`);
            
            if (godModeEnabled) {
                // In God Mode, all words are valid
                window.originalCheckWord = checkWord;
                checkWord = function(word) {
                    if (word.length < 3) return;
                    
                    // Always treat as valid word
                    const points = calculatePoints(word.length) * 2; // Double points in God Mode
                    currentWordEl.textContent = `${word} (+${points}) GOD MODE!`;
                    foundWords.add(word);
                    
                    // Update score
                    score += points;
                    scoreEl.textContent = score;
                    wordCountEl.textContent = foundWords.size;
                    
                    // Animate
                    animatePath('correct');
                    setTimeout(() => {
                        resetPath();
                    }, 300);
                };
            } else {
                // Restore original function
                if (window.originalCheckWord) {
                    checkWord = window.originalCheckWord;
                }
            }
        }

        function showAllWordsCheat() {
            // Find all possible words and highlight them on the grid
            const possibleWords = findAllPossibleWords();
            console.log(`Cheat activated: Found ${possibleWords.length} possible words`);
            
            // Show a temporary overlay with some of the words
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50';
            overlay.innerHTML = `
                <div class="bg-white p-6 rounded-xl max-w-md max-h-96 overflow-auto">
                    <h3 class="text-xl font-bold mb-3">Secret Cheat: Word List</h3>
                    <p class="mb-3 text-sm text-gray-600">Here are some of the highest-scoring words:</p>
                    <div class="grid grid-cols-2 gap-2">
                        ${possibleWords
                            .sort((a, b) => calculatePoints(b.length) - calculatePoints(a.length))
                            .slice(0, 20)
                            .map(word => `<div class="bg-blue-100 px-2 py-1 rounded text-blue-800">${word} (${calculatePoints(word.length)})</div>`)
                            .join('')
                        }
                    </div>
                    <p class="mt-4 text-xs text-gray-500">Click anywhere to close</p>
                </div>
            `;
            
            document.body.appendChild(overlay);
            overlay.addEventListener('click', () => {
                document.body.removeChild(overlay);
            });
        }

        function addExtraTime() {
            if (currentGameMode === GAME_MODE.TIMED) {
                timer += 30; // Add 30 seconds
                updateTimerDisplay();
                console.log("Extra time added: +30 seconds");
            } else {
                console.log("Extra time can only be added in timed mode");
            }
        }

        function enableRainbowMode() {
            rainbowModeEnabled = !rainbowModeEnabled;
            console.log(`Rainbow Mode ${rainbowModeEnabled ? 'enabled' : 'disabled'}`);
            
            const tiles = document.querySelectorAll('.tile');
            
            if (rainbowModeEnabled) {
                // Add rainbow animation to all tiles
                tiles.forEach(tile => {
                    tile.classList.add('rainbow-animation');
                });
                
                // Add CSS for rainbow animation if it doesn't exist
                if (!document.getElementById('rainbow-style')) {
                    const style = document.createElement('style');
                    style.id = 'rainbow-style';
                    style.textContent = `
                        @keyframes rainbow {
                            0% { background-color: #ff0000; }
                            14% { background-color: #ff7f00; }
                            28% { background-color: #ffff00; }
                            42% { background-color: #00ff00; }
                            57% { background-color: #0000ff; }
                            71% { background-color: #4b0082; }
                            85% { background-color: #9400d3; }
                            100% { background-color: #ff0000; }
                        }
                        .rainbow-animation {
                            animation: rainbow 5s linear infinite;
                            color: white !important;
                            text-shadow: 0 0 3px black;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                // Remove rainbow animation
                tiles.forEach(tile => {
                    tile.classList.remove('rainbow-animation');
                });
            }
        }

        function enableBigPointsMode() {
            bigPointsModeEnabled = !bigPointsModeEnabled;
            console.log(`Big Points Mode ${bigPointsModeEnabled ? 'enabled' : 'disabled'}`);
            
            // Store original function if not already stored
            if (!window.originalCalculatePoints) {
                window.originalCalculatePoints = calculatePoints;
            }
            
            if (bigPointsModeEnabled) {
                // Override the points calculation
                calculatePoints = function(wordLength) {
                    // 5x normal points
                    if (wordLength === 3) return 500;
                    if (wordLength === 4) return 2000;
                    if (wordLength === 5) return 4000;
                    if (wordLength === 6) return 7000;
                    if (wordLength === 7) return 9000;
                    if (wordLength >= 8) return 11000;
                    return 0;
                };
            } else {
                // Restore original function
                if (window.originalCalculatePoints) {
                    calculatePoints = window.originalCalculatePoints;
                }
            }
        }

        function showSecretCommandNotification(command) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-purple-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-300';
            notification.innerHTML = `
                <div class="flex items-center">
                    <span class="text-lg mr-2">🔮</span>
                    <div>
                        <div class="font-bold">Secret Command Activated!</div>
                        <div class="text-sm">${command}</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Add a secret dot to the score header
        function addSecretDot() {
            const scoreHeader = document.querySelector('.bg-white.rounded-xl.shadow-lg');
            if (!scoreHeader) return;
            
            // Create the secret dot
            const secretDot = document.createElement('div');
            secretDot.id = 'secret-dot';
            secretDot.className = 'absolute top-2 right-2 w-2 h-2 rounded-full bg-gray-300 cursor-pointer';
            secretDot.style.opacity = '0.5';
            
            // Make sure the score header has position relative
            scoreHeader.style.position = 'relative';
            
            // Add the dot to the score header
            scoreHeader.appendChild(secretDot);
            
            // Track clicks
            let clickCount = 0;
            let clickTimer = null;
            
            secretDot.addEventListener('click', () => {
                clickCount++;
                
                // Visual feedback
                secretDot.style.transform = 'scale(1.5)';
                setTimeout(() => {
                    secretDot.style.transform = 'scale(1)';
                }, 100);
                
                // Reset click count after 1 second of inactivity
                clearTimeout(clickTimer);
                clickTimer = setTimeout(() => {
                    clickCount = 0;
                }, 1000);
                
                // Open secret menu after 3 clicks
                if (clickCount >= 3) {
                    clickCount = 0;
                    openSecretMenu();
                }
            });
        }

        // Open the secret menu
        function openSecretMenu() {
            console.log("Secret menu opened");
            
            // Create the secret menu overlay
            const overlay = document.createElement('div');
            overlay.id = 'secret-menu-overlay';
            overlay.className = 'fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50';
            
            // Create the menu content with new commands
            overlay.innerHTML = `
                <div class="bg-white p-6 rounded-xl max-w-md w-11/12 transform transition-all scale-95 opacity-0 max-h-[80vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold text-purple-800">🔮 Secret Menu</h3>
                        <button id="close-secret-menu" class="text-gray-500 hover:text-gray-800">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                    
                    <div class="space-y-3">
                        <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-purple-500 to-indigo-600 text-white rounded-lg hover:from-purple-600 hover:to-indigo-700 transition-all" data-command="GODMODE">
                            God Mode <span class="text-xs opacity-75">(All words valid)</span>
                        </button>
                        
                        <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-blue-500 to-teal-400 text-white rounded-lg hover:from-blue-600 hover:to-teal-500 transition-all" data-command="ALLWORDS">
                            Show All Words <span class="text-xs opacity-75">(Cheat sheet)</span>
                        </button>
                        
                        <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-yellow-500 to-orange-500 text-white rounded-lg hover:from-yellow-600 hover:to-orange-600 transition-all" data-command="EXTRATIME">
                            Extra Time <span class="text-xs opacity-75">(+30 seconds)</span>
                        </button>
                        
                        <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-red-500 to-pink-500 text-white rounded-lg hover:from-red-600 hover:to-pink-600 transition-all" data-command="RAINBOW">
                            Rainbow Mode <span class="text-xs opacity-75">(Colorful tiles)</span>
                        </button>
                        
                        <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-green-500 to-emerald-500 text-white rounded-lg hover:from-green-600 hover:to-emerald-600 transition-all" data-command="BIGPOINTS">
                            Big Points <span class="text-xs opacity-75">(5x scoring)</span>
                        </button>
                        
                        <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-blue-400 to-cyan-500 text-white rounded-lg hover:from-blue-500 hover:to-cyan-600 transition-all" data-command="SLOWTIME">
                            Slow Time <span class="text-xs opacity-75">(Timer runs at half speed)</span>
                        </button>
                        
                        <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-gray-700 to-gray-900 text-white rounded-lg hover:from-gray-800 hover:to-black transition-all" data-command="DARKMODE">
                            Dark Mode <span class="text-xs opacity-75">(Night theme)</span>
                        </button>
                        
                        <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-pink-400 to-purple-400 text-white rounded-lg hover:from-pink-500 hover:to-purple-500 transition-all" data-command="CONFETTI">
                            Confetti <span class="text-xs opacity-75">(Celebration!)</span>
                        </button>
                        
                        <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-amber-400 to-yellow-500 text-white rounded-lg hover:from-amber-500 hover:to-yellow-600 transition-all" data-command="SHUFFLE">
                            Shuffle <span class="text-xs opacity-75">(New letters)</span>
                        </button>
                        
                        <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-green-400 to-green-600 text-white rounded-lg hover:from-green-500 hover:to-green-700 transition-all" data-command="MATRIX">
                            Matrix <span class="text-xs opacity-75">(Enter the Matrix)</span>
                        </button>
                        
                        <div class="border-t border-gray-200 my-3 pt-3">
                            <button class="secret-command-btn w-full py-2 px-4 bg-gradient-to-r from-red-600 to-red-800 text-white rounded-lg hover:from-red-700 hover:to-red-900 transition-all" data-command="ENDGAME">
                                End Game <span class="text-xs opacity-75">(Finish current game)</span>
                            </button>
                        </div>
                    </div>
                    
                    <div class="mt-4 text-xs text-gray-500 text-center">
                        You can also activate these by typing the command name during gameplay
                    </div>
                </div>
            `;
            
            // Add the overlay to the body
            document.body.appendChild(overlay);
            
            // Animate in
            setTimeout(() => {
                const menuContent = overlay.querySelector('div');
                if (menuContent) {
                    menuContent.classList.remove('scale-95', 'opacity-0');
                }
            }, 10);
            
            // Set up event listeners for the menu
            overlay.querySelector('#close-secret-menu').addEventListener('click', () => {
                closeSecretMenu();
            });
            
            // Close when clicking outside the menu
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    closeSecretMenu();
                }
            });
            
            // Set up command buttons
            const commandButtons = overlay.querySelectorAll('.secret-command-btn');
            commandButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const command = button.getAttribute('data-command');
                    if (command && SECRET_COMMANDS[command]) {
                        SECRET_COMMANDS[command]();
                        showSecretCommandNotification(command);
                        closeSecretMenu();
                    }
                });
            });
        }

        // Close the secret menu
        function closeSecretMenu() {
            const overlay = document.getElementById('secret-menu-overlay');
            if (!overlay) return;
            
            // Animate out
            const menuContent = overlay.querySelector('div');
            if (menuContent) {
                menuContent.classList.add('scale-95', 'opacity-0');
            }
            
            // Remove after animation
            setTimeout(() => {
                document.body.removeChild(overlay);
            }, 300);
        }

        // New secret commands
        function enableSlowTimeMode() {
            slowTimeEnabled = !slowTimeEnabled;
            console.log(`Slow Time Mode ${slowTimeEnabled ? 'enabled' : 'disabled'}`);
            
            if (slowTimeEnabled) {
                // Slow down the timer in timed mode
                if (currentGameMode === GAME_MODE.TIMED) {
                    clearInterval(timerInterval);
                    timerInterval = setInterval(() => {
                        // Only decrease timer every other second
                        if (Math.floor(Date.now() / 1000) % 2 === 0) {
                            timer--;
                            updateTimerDisplay();
                            
                            if (timer <= 0) {
                                endGame();
                            }
                        }
                    }, 1000);
                    
                    // Add visual indicator
                    const timerEl = document.getElementById('timer-display');
                    if (timerEl) {
                        timerEl.classList.add('text-blue-400', 'animate-pulse');
                    }
                }
            } else {
                // Restore normal timer
                if (currentGameMode === GAME_MODE.TIMED) {
                    clearInterval(timerInterval);
                    startTimer();
                    
                    // Remove visual indicator
                    const timerEl = document.getElementById('timer-display');
                    if (timerEl) {
                        timerEl.classList.remove('text-blue-400', 'animate-pulse');
                    }
                }
            }
        }

        function toggleDarkMode() {
            darkModeEnabled = !darkModeEnabled;
            console.log(`Dark Mode ${darkModeEnabled ? 'enabled' : 'disabled'}`);
            
            const gameContainer = document.getElementById('game-container');
            const body = document.body;
            
            if (darkModeEnabled) {
                // Enable dark mode
                body.classList.add('bg-gray-900');
                
                // Update UI elements
                document.querySelectorAll('.bg-white').forEach(el => {
                    el.classList.remove('bg-white');
                    el.classList.add('bg-gray-800', 'text-white');
                });
                
                document.querySelectorAll('.text-gray-800').forEach(el => {
                    el.classList.remove('text-gray-800');
                    el.classList.add('text-gray-200');
                });
                
                document.querySelectorAll('.text-gray-600').forEach(el => {
                    el.classList.remove('text-gray-600');
                    el.classList.add('text-gray-400');
                });
                
                // Update grid
                const gridContainer = document.getElementById('grid-container');
                if (gridContainer) {
                    gridContainer.classList.remove('bg-green-800/50');
                    gridContainer.classList.add('bg-blue-900/50');
                }
                
                // Add dark mode style
                if (!document.getElementById('dark-mode-style')) {
                    const style = document.createElement('style');
                    style.id = 'dark-mode-style';
                    style.textContent = `
                        .tile {
                            background-color: #2d3748 !important;
                            color: #e2e8f0 !important;
                            border-color: #4a5568 !important;
                        }
                        .tile.selected {
                            background-color: #4299e1 !important;
                        }
                        .tile.correct {
                            background-color: #38a169 !important;
                        }
                        .tile.incorrect {
                            background-color: #e53e3e !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                // Disable dark mode
                body.classList.remove('bg-gray-900');
                
                // Update UI elements
                document.querySelectorAll('.bg-gray-800').forEach(el => {
                    el.classList.remove('bg-gray-800', 'text-white');
                    el.classList.add('bg-white');
                });
                
                document.querySelectorAll('.text-gray-200').forEach(el => {
                    el.classList.remove('text-gray-200');
                    el.classList.add('text-gray-800');
                });
                
                document.querySelectorAll('.text-gray-400').forEach(el => {
                    el.classList.remove('text-gray-400');
                    el.classList.add('text-gray-600');
                });
                
                // Update grid
                const gridContainer = document.getElementById('grid-container');
                if (gridContainer) {
                    gridContainer.classList.remove('bg-blue-900/50');
                    gridContainer.classList.add('bg-green-800/50');
                }
                
                // Remove dark mode style
                const darkModeStyle = document.getElementById('dark-mode-style');
                if (darkModeStyle) {
                    darkModeStyle.remove();
                }
            }
        }

        function triggerConfetti() {
            console.log("Confetti triggered!");
            
            // Create confetti effect
            for (let i = 0; i < 100; i++) {
                createConfettiPiece();
            }
        }

        function createConfettiPiece() {
            const colors = ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#577590'];
            const confetti = document.createElement('div');
            
            // Random position, color, and rotation
            const left = Math.random() * 100;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const rotation = Math.random() * 360;
            const size = Math.random() * 10 + 5;
            
            confetti.style.cssText = `
                position: fixed;
                top: -20px;
                left: ${left}vw;
                width: ${size}px;
                height: ${size}px;
                background-color: ${color};
                transform: rotate(${rotation}deg);
                z-index: 1000;
                pointer-events: none;
            `;
            
            document.body.appendChild(confetti);
            
            // Animate falling
            const duration = Math.random() * 3000 + 2000;
            const keyframes = [
                { transform: `translateY(0) rotate(${rotation}deg)`, opacity: 1 },
                { transform: `translateY(${window.innerHeight + 100}px) rotate(${rotation + 360}deg)`, opacity: 0 }
            ];
            
            const animation = confetti.animate(keyframes, {
                duration: duration,
                easing: 'cubic-bezier(0.1, 0.8, 0.3, 1)',
                fill: 'forwards'
            });
            
            animation.onfinish = () => {
                confetti.remove();
            };
        }

        function shuffleGrid() {
            console.log("Grid shuffled!");
            
            // Animate the shuffle
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                // Add shake animation
                tile.classList.add('animate-shake');
                
                // Remove animation after it completes
                setTimeout(() => {
                    tile.classList.remove('animate-shake');
                }, 500);
            });
            
            // Regenerate the grid after animation
            setTimeout(() => {
                generateGrid();
                renderGrid();
            }, 500);
            
            // Add shake animation CSS if it doesn't exist
            if (!document.getElementById('shake-animation')) {
                const style = document.createElement('style');
                style.id = 'shake-animation';
                style.textContent = `
                    @keyframes shake {
                        0% { transform: translate(0, 0) rotate(0deg); }
                        20% { transform: translate(-5px, 0) rotate(-5deg); }
                        40% { transform: translate(5px, 0) rotate(5deg); }
                        60% { transform: translate(-3px, 0) rotate(-3deg); }
                        80% { transform: translate(3px, 0) rotate(3deg); }
                        100% { transform: translate(0, 0) rotate(0deg); }
                    }
                    .animate-shake {
                        animation: shake 0.5s ease-in-out;
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function enableMatrixMode() {
            matrixModeEnabled = !matrixModeEnabled;
            console.log(`Matrix Mode ${matrixModeEnabled ? 'enabled' : 'disabled'}`);
            
            if (matrixModeEnabled) {
                // Create matrix background
                const canvas = document.createElement('canvas');
                canvas.id = 'matrix-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: -1;
                `;
                document.body.appendChild(canvas);
                
                // Initialize matrix effect
                initMatrix(canvas);
                
                // Make game elements more visible
                document.querySelectorAll('.bg-white, .tile').forEach(el => {
                    el.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.5)';
                });
            } else {
                // Remove matrix background
                const canvas = document.getElementById('matrix-canvas');
                if (canvas) {
                    canvas.remove();
                }
                
                // Remove box shadows
                document.querySelectorAll('.bg-white, .tile').forEach(el => {
                    el.style.boxShadow = '';
                });
            }
        }

        function initMatrix(canvas) {
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Matrix characters
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const fontSize = 14;
            const columns = canvas.width / fontSize;
            
            // Array to track the y position of each column
            const drops = [];
            for (let i = 0; i < columns; i++) {
                drops[i] = 1;
            }
            
            // Drawing the characters
            function draw() {
                // Black BG with opacity for the trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#0f0'; // Green text
                ctx.font = fontSize + 'px monospace';
                
                // Loop through drops
                for (let i = 0; i < drops.length; i++) {
                    // Random character
                    const text = chars.charAt(Math.floor(Math.random() * chars.length));
                    
                    // x = i * fontSize, y = drops[i] * fontSize
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    // Randomly reset some drops to the top
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    
                    // Increment y coordinate
                    drops[i]++;
                }
            }
            
            // Animation loop
            const matrixInterval = setInterval(draw, 33);
            
            // Store interval ID for cleanup
            canvas.matrixInterval = matrixInterval;
            
            // Resize handler
            window.addEventListener('resize', () => {
                if (matrixModeEnabled) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
            });
        }

        function endGameCommand() {
            console.log("End Game command activated");
            
            // Create a confirmation dialog
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50';
            overlay.innerHTML = `
                <div class="bg-white p-6 rounded-xl max-w-md w-11/12 text-center">
                    <h3 class="text-xl font-bold text-red-600 mb-3">⚠️ End Game?</h3>
                    <p class="mb-4">Are you sure you want to end the current game?</p>
                    <div class="flex space-x-3">
                        <button id="cancel-end-game" class="flex-1 py-2 px-4 bg-gray-200 hover:bg-gray-300 rounded-lg transition-colors">
                            Cancel
                        </button>
                        <button id="confirm-end-game" class="flex-1 py-2 px-4 bg-red-500 hover:bg-red-600 text-white rounded-lg transition-colors">
                            End Game
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Set up event listeners
            document.getElementById('cancel-end-game').addEventListener('click', () => {
                document.body.removeChild(overlay);
            });
            
            document.getElementById('confirm-end-game').addEventListener('click', () => {
                document.body.removeChild(overlay);
                // End the game with a slight delay for better UX
                setTimeout(() => {
                    endGame();
                }, 300);
            });
        }

        // Initialize the game when the page loads
        window.onload = async function() {
            console.log("Window loaded");
            
            // Load the dictionary first
            await loadDictionary();
            
            // Load high scores
            loadHighScores();
            
            // Set up event listeners
            setupEventListeners();
            
            // Set up secret menu
            setupSecretMenu();
            
            // Add the secret dot
            addSecretDot();
            
            // Initialize the game
            init();
            
            // Make key functions available globally for debugging
            window.endGame = endGame;
            window.startNewGame = init;
            window.showAllWords = showAllPossibleWords;
            
            console.log("Game ready! You can use these console commands:");
            console.log("- endGame() - End the current game");
            console.log("- startNewGame() - Start a new game");
        }
    </script>
</body>
</html>

            
    </script>
</body>
</html>
