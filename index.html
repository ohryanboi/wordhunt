<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Word Hunt</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            touch-action: manipulation; /* Prevents zooming on mobile */
            background-color: #15803d; /* dark green */
            background-image: 
                linear-gradient(45deg, rgba(0,0,0,0.08) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.08) 75%), 
                linear-gradient(45deg, rgba(0,0,0,0.08) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.08) 75%);
            background-size: 30px 30px;
            background-position: 0 0, 15px 15px;
        }
        .tile {
            background-color: #f4e4bc; /* Light cream/wood color */
            border: 2px solid #d4b896; /* Darker border */
            color: #5d4037; /* Dark brown text */
            border-radius: 12px; /* Rounded corners like the image */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
            transition: all 0.1s ease-in-out;
            font-weight: bold;
            aspect-ratio: 1;
            min-height: 60px;
        }
        .tile:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .tile:active {
            transform: translateY(0px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .tile.selected {
            background-color: #4ade80; /* Bright green */
            color: white;
            border-color: #22c55e;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
            transform: scale(1.05) translateY(-2px);
        }
        .tile.correct {
            animation: correct-word-animation 0.5s ease;
        }
        @keyframes correct-word-animation {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); background-color: #4ade80; }
        }
        .tile.incorrect {
             animation: incorrect-word-animation 0.5s ease;
        }
        @keyframes incorrect-word-animation {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-6px); }
            50% { transform: translateX(6px); }
            75% { transform: translateX(-6px); }
        }
        #current-word-display {
            transition: opacity 0.2s, transform 0.2s;
        }
        @keyframes flash {
            0%, 100% { background-color: #15803d; }
            50% { background-color: #fbbf24; }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Lightweight achievement notification animation */
        @keyframes achievementSlide {
            0% { transform: translate(-50%, -20px); opacity: 0; }
            100% { transform: translate(-50%, 0); opacity: 1; }
        }

        .achievement-notification {
            animation: achievementSlide 0.3s ease-out;
        }

        /* Mobile-responsive menu styles */
        .mobile-menu-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 60;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .mobile-menu-content {
            background: white;
            border-radius: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.2s ease-out;
        }

        .mobile-menu-content.show {
            transform: scale(1);
            opacity: 1;
        }

        .mobile-menu-header {
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .mobile-menu-body {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            -webkit-overflow-scrolling: touch;
        }

        .mobile-menu-footer {
            padding: 0.75rem 1rem;
            border-top: 1px solid #e5e7eb;
            background: #f9fafb;
            border-radius: 0 0 1rem 1rem;
            flex-shrink: 0;
        }

        /* Desktop menu styles for larger screens */
        @media (min-width: 768px) {
            .mobile-menu-panel {
                position: fixed;
                top: 1rem;
                left: auto;
                right: 1rem;
                bottom: auto;
                background: transparent;
                padding: 0;
                align-items: flex-start;
                justify-content: flex-end;
            }

            .mobile-menu-content {
                max-width: 320px;
                max-height: calc(100vh - 2rem);
                transform: translateX(100%);
                opacity: 1;
            }

            .mobile-menu-content.show {
                transform: translateX(0);
            }

            .mobile-menu-panel.left {
                left: 1rem;
                right: auto;
                justify-content: flex-start;
            }

            .mobile-menu-panel.left .mobile-menu-content {
                transform: translateX(-100%);
            }

            .mobile-menu-panel.left .mobile-menu-content.show {
                transform: translateX(0);
            }
        }

        /* Touch-friendly button styles */
        .mobile-touch-btn {
            min-height: 44px;
            padding: 0.75rem 1rem;
            margin: 0.25rem 0;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
            text-align: left;
            width: 100%;
            border: none;
            cursor: pointer;
        }

        .mobile-touch-btn:active {
            transform: scale(0.98);
        }

        /* Scrollbar styles for mobile menus */
        .mobile-menu-body::-webkit-scrollbar {
            width: 4px;
        }

        .mobile-menu-body::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 2px;
        }

        .mobile-menu-body::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 2px;
        }

        .mobile-menu-body::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <!-- Opening UI -->
    <div id="opening-ui" class="w-full max-w-lg mx-auto p-6 flex flex-col items-center">

        <!-- Title -->
        <div class="text-center mb-8">
            <h1 class="text-5xl font-bold text-white mb-2 drop-shadow-lg">Word Hunt</h1>
            <p class="text-lg text-white/80">Find words in the letter grid!</p>
        </div>

        <!-- Board Size Selection -->
        <div class="bg-white rounded-xl shadow-lg p-6 w-full mb-6">
            <h2 class="text-xl font-bold text-gray-800 mb-2 text-center">Choose Board Size</h2>
            <p class="text-sm text-gray-600 text-center mb-4">Selected: <span id="selected-board-size" class="font-bold text-purple-600">4√ó4 Classic</span></p>

            <div class="flex space-x-4">
                <button id="board-4x4-btn" class="flex-1 p-4 bg-gradient-to-r from-purple-500 to-purple-600 text-white rounded-lg hover:from-purple-600 hover:to-purple-700 transition-all transform hover:scale-105 border-4 border-purple-300 shadow-lg">
                    <div class="text-center">
                        <div class="text-lg font-bold">4√ó4 Grid</div>
                        <div class="text-sm opacity-90">Classic ‚Ä¢ 16 Letters</div>
                        <div class="text-2xl mt-2">üì±</div>
                        <div id="selected-4x4" class="text-xs mt-1 font-bold">‚úì SELECTED</div>
                    </div>
                </button>

                <button id="board-5x5-btn" class="flex-1 p-4 bg-gradient-to-r from-orange-500 to-orange-600 text-white rounded-lg hover:from-orange-600 hover:to-orange-700 transition-all transform hover:scale-105 border-4 border-transparent">
                    <div class="text-center">
                        <div class="text-lg font-bold">5√ó5 Grid</div>
                        <div class="text-sm opacity-90">Challenge ‚Ä¢ 25 Letters</div>
                        <div class="text-2xl mt-2">üñ•Ô∏è</div>
                        <div id="selected-5x5" class="text-xs mt-1 font-bold opacity-0">‚úì SELECTED</div>
                    </div>
                </button>
            </div>
        </div>

        <!-- Game Mode Selection -->
        <div class="bg-white rounded-xl shadow-lg p-6 w-full mb-6">
            <h2 class="text-xl font-bold text-gray-800 mb-4 text-center">Choose Your Mode</h2>

            <div class="space-y-4">
                <button id="start-timed-btn" class="w-full p-4 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 transition-all transform hover:scale-105">
                    <div class="flex items-center justify-between">
                        <div class="text-left">
                            <div class="text-lg font-bold">‚è±Ô∏è Timed Mode</div>
                            <div class="text-sm opacity-90">80 seconds to find as many words as possible</div>
                        </div>
                        <div class="text-2xl">üèÉ‚Äç‚ôÇÔ∏è</div>
                    </div>
                </button>

                <button id="start-unlimited-btn" class="w-full p-4 bg-gradient-to-r from-green-500 to-green-600 text-white rounded-lg hover:from-green-600 hover:to-green-700 transition-all transform hover:scale-105">
                    <div class="flex items-center justify-between">
                        <div class="text-left">
                            <div class="text-lg font-bold">‚ôæÔ∏è Unlimited Mode</div>
                            <div class="text-sm opacity-90">Take your time and find every word</div>
                        </div>
                        <div class="text-2xl">üßò‚Äç‚ôÄÔ∏è</div>
                    </div>
                </button>
            </div>
        </div>

        <!-- Leaderboard -->
        <div class="bg-white rounded-xl shadow-lg p-6 w-full mb-6">
            <h2 class="text-xl font-bold text-gray-800 mb-4 text-center">üèÜ Leaderboard</h2>

            <!-- Mode Tabs -->
            <div class="flex mb-4 border-b border-gray-200">
                <button id="leaderboard-timed-tab" class="flex-1 py-2 px-3 text-sm font-medium text-blue-600 border-b-2 border-blue-500">
                    Timed Mode
                </button>
                <button id="leaderboard-unlimited-tab" class="flex-1 py-2 px-3 text-sm font-medium text-gray-500 hover:text-gray-700">
                    Unlimited Mode
                </button>
            </div>

            <div id="opening-leaderboard" class="space-y-2">
                <div class="text-center py-4 text-gray-500">Loading scores...</div>
            </div>
        </div>

        <!-- Customize Button -->
        <div class="w-full mb-4">
            <button id="opening-customize-btn" class="w-full py-3 px-4 bg-gradient-to-r from-purple-500 to-indigo-600 text-white rounded-lg hover:from-purple-600 hover:to-indigo-700 transition-all text-lg font-medium transform hover:scale-105">
                üé® Customize Game
            </button>
        </div>

        <!-- Achievements Button -->
        <div class="w-full mb-4">
            <button id="opening-achievements-btn" class="w-full py-3 px-4 bg-gradient-to-r from-yellow-500 to-orange-500 text-white rounded-lg hover:from-yellow-600 hover:to-orange-600 transition-all text-lg font-medium transform hover:scale-105">
                üèÜ Achievements
            </button>
        </div>

        <!-- Daily Challenge Button -->
        <div class="w-full mb-4">
            <button id="opening-daily-challenge-btn" class="w-full py-3 px-4 bg-gradient-to-r from-emerald-500 to-teal-500 text-white rounded-lg hover:from-emerald-600 hover:to-teal-600 transition-all text-lg font-medium transform hover:scale-105">
                üìÖ Daily Challenge
            </button>
        </div>

        <!-- Data Reset Button -->
        <div class="w-full mb-6">
            <button id="reset-data-btn" class="w-full py-2 px-4 bg-gradient-to-r from-red-500 to-red-600 text-white rounded-lg hover:from-red-600 hover:to-red-700 transition-all text-sm font-medium">
                üóëÔ∏è Reset All Data
            </button>
        </div>

        <!-- Instructions -->
        <div class="bg-white/10 rounded-lg p-4 w-full text-center">
            <p class="text-white/80 text-sm">
                üí° <strong>How to play:</strong> Drag across adjacent letters to form words.
                Longer words = more points!
            </p>
        </div>

    </div>

    <!-- Game Container (hidden initially) -->
    <div id="game-container" class="w-full max-w-sm mx-auto p-4 flex flex-col items-center hidden">

        <!-- Score Header -->
        <div class="bg-white rounded-xl shadow-lg p-3 w-full max-w-xs text-center mb-4">
            <!-- Grid Size Indicator -->
            <div class="text-xs font-bold text-purple-600 mb-1">
                <span id="current-grid-size">4√ó4 GRID</span>
            </div>

            <div class="text-sm font-semibold text-gray-500">WORDS: <span id="word-count">0</span></div>
            <div class="text-2xl font-bold text-gray-800">SCORE: <span id="score">0</span></div>

            <!-- Game Mode Toggle -->
            <div class="mt-2 flex justify-center">
                <div class="bg-gray-200 rounded-full p-1 flex">
                    <button id="timed-mode-btn" class="px-3 py-1 rounded-full bg-blue-500 text-white text-sm font-medium transition-all">
                        Timed
                    </button>
                    <button id="unlimited-mode-btn" class="px-3 py-1 rounded-full text-gray-700 text-sm font-medium transition-all">
                        Unlimited
                    </button>
                </div>
            </div>
        </div>

        <!-- Customize Button -->
        <div class="w-full max-w-xs mb-3">
            <button id="customize-btn" class="w-full py-2 px-4 bg-gradient-to-r from-purple-500 to-indigo-600 text-white rounded-lg hover:from-purple-600 hover:to-indigo-700 transition-all text-sm font-medium">
                üé® Customize
            </button>
        </div>

        <!-- Back to Menu Button -->
        <div class="w-full max-w-xs mb-3">
            <button id="back-to-menu-btn" class="w-full py-2 px-4 bg-gradient-to-r from-gray-500 to-gray-600 text-white rounded-lg hover:from-gray-600 hover:to-gray-700 transition-all text-sm font-medium">
                ‚Üê Back to Menu
            </button>
        </div>

        <!-- Timer -->
        <div id="timer-display" class="bg-black/25 text-white text-sm font-mono rounded-full px-3 py-1 mb-4">
            00:00
        </div>

        <!-- Current Word Preview -->
        <div id="current-word-display" class="h-10 mb-2 opacity-0 transform -translate-y-2">
             <div class="bg-green-500 text-white font-bold text-lg rounded-full px-5 py-2 shadow-md">
                <span id="current-word"></span>
            </div>
        </div>

        <!-- Power-ups Panel -->
        <div id="powerups-panel" class="bg-black/25 text-white text-sm rounded-full px-3 py-1 mb-4">
            <div class="flex items-center justify-between">
                <div class="font-mono">‚ö°</div>
                <div class="flex gap-1" id="powerups-inventory">
                    <!-- Power-ups will be populated here -->
                </div>
            </div>
        </div>

        <!-- Competitive Mode Indicator -->
        <div id="competitive-mode-indicator" class="bg-amber-500/90 text-white text-xs rounded-full px-3 py-1 mb-4 hidden">
            <div class="flex items-center justify-center">
                <div class="font-mono">üèÜ Competitive Mode</div>
            </div>
        </div>

        <!-- Secret Commands Used Indicator -->
        <div id="secret-commands-indicator" class="bg-red-500/90 text-white text-xs rounded-full px-3 py-1 mb-4 hidden">
            <div class="flex items-center justify-center">
                <div class="font-mono">üö´ Score Won't Save</div>
            </div>
        </div>

        <!-- Game Grid -->
        <div class="relative">
            <!-- Grid Size Badge -->
            <div id="grid-size-badge" class="absolute -top-2 -right-2 bg-purple-600 text-white text-xs font-bold px-2 py-1 rounded-full z-10">
                4√ó4
            </div>
            <div id="grid-container" class="grid grid-cols-4 gap-3 md:gap-4 aspect-square select-none w-full max-w-xs bg-green-700 rounded-xl p-4 border-2 border-green-800">
                <!-- Tiles will be generated by JavaScript -->
            </div>
        </div>

    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center w-11/12 max-w-md transform transition-all scale-95 opacity-0">
            <h2 class="text-4xl font-bold text-gray-800 mb-2" id="game-over-title">Time's Up!</h2>
            <p class="text-lg text-gray-600 mb-4">Your final score is:</p>
            <p id="final-score" class="text-6xl font-extrabold text-blue-500 mb-6">0</p>
            
            <!-- High Score Section -->
            <div class="mb-6 bg-gray-50 p-4 rounded-lg">
                <h3 class="text-xl font-semibold mb-2 text-gray-700">High Scores</h3>
                <div id="high-scores-list" class="text-left">
                    <div class="flex justify-between items-center py-1 border-b border-gray-200">
                        <span class="font-medium">Loading scores...</span>
                        <span></span>
                    </div>
                </div>
            </div>
            
            <div class="flex flex-col space-y-3">
                <button id="play-again-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg text-xl transition duration-300 transform hover:scale-105">
                    Play Again
                </button>
                
                <button id="show-all-words-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-xl transition duration-300 transform hover:scale-105">
                    Show All Possible Words
                </button>
            </div>
            
            <div id="all-possible-words" class="mt-6 hidden">
                <h3 class="text-xl font-semibold mb-2">All Possible Words</h3>
                
                <!-- Sorting options -->
                <div class="flex justify-between items-center mb-2">
                    <span class="text-sm text-gray-600">Sort by:</span>
                    <div class="flex space-x-2">
                        <button id="sort-length-desc" class="px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded hover:bg-blue-200 active-sort">
                            Length ‚Üì
                        </button>
                        <button id="sort-alpha" class="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded hover:bg-gray-200">
                            A-Z
                        </button>
                        <button id="sort-value-desc" class="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded hover:bg-gray-200">
                            Value ‚Üì
                        </button>
                        <button id="sort-value-asc" class="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded hover:bg-gray-200">
                            Value ‚Üë
                        </button>
                    </div>
                </div>
                
                <div class="max-h-60 overflow-y-auto">
                    <div id="possible-words-list" class="grid grid-cols-2 gap-2 text-left"></div>
                    <p id="possible-words-count" class="mt-2 text-sm text-gray-500"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Daily Challenge Modal -->
    <div id="daily-challenge-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-lg w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center mb-6">
                <h2 class="text-2xl font-bold text-emerald-600 mb-2">üìÖ Daily Challenge</h2>
                <p class="text-gray-600" id="daily-challenge-date">Today's Challenge</p>
            </div>

            <div id="daily-challenge-info" class="mb-6">
                <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4 mb-4">
                    <div class="flex items-center justify-between mb-2">
                        <span class="font-semibold text-emerald-700">Challenge #<span id="challenge-number"></span></span>
                        <span class="text-sm text-emerald-600" id="challenge-status">Not Started</span>
                    </div>
                    <div class="text-sm text-gray-600">
                        <div>Grid Size: <span id="challenge-grid-size" class="font-medium">4x4</span></div>
                        <div>Time Limit: <span class="font-medium">80 seconds</span></div>
                        <div>Your Streak: <span id="current-streak" class="font-bold text-emerald-600">0 days</span></div>
                    </div>
                </div>

                <div id="daily-stats" class="grid grid-cols-2 gap-4 mb-4">
                    <div class="bg-gray-50 rounded-lg p-3 text-center">
                        <div class="text-lg font-bold text-gray-800" id="today-score">--</div>
                        <div class="text-xs text-gray-500">Your Score</div>
                    </div>
                    <div class="bg-gray-50 rounded-lg p-3 text-center">
                        <div class="text-lg font-bold text-gray-800" id="today-rank">--</div>
                        <div class="text-xs text-gray-500">Your Rank</div>
                    </div>
                </div>

                <div id="streak-badges" class="mb-4">
                    <h4 class="font-semibold text-gray-700 mb-2">Streak Badges</h4>
                    <div class="flex flex-wrap gap-2">
                        <div class="badge-item flex items-center space-x-1 px-2 py-1 rounded-full text-xs" data-streak="3">
                            <span>üî•</span><span>3-Day</span>
                        </div>
                        <div class="badge-item flex items-center space-x-1 px-2 py-1 rounded-full text-xs" data-streak="7">
                            <span>‚≠ê</span><span>Week</span>
                        </div>
                        <div class="badge-item flex items-center space-x-1 px-2 py-1 rounded-full text-xs" data-streak="30">
                            <span>üíé</span><span>Month</span>
                        </div>
                        <div class="badge-item flex items-center space-x-1 px-2 py-1 rounded-full text-xs" data-streak="100">
                            <span>üëë</span><span>Legend</span>
                        </div>
                    </div>
                </div>
            </div>

            <div id="upcoming-challenges" class="mb-4">
                <h4 class="font-semibold text-gray-700 mb-2">Upcoming Challenges</h4>
                <div class="space-y-1" id="upcoming-challenges-list">
                    <!-- Upcoming challenges will be populated here -->
                </div>
            </div>

            <div class="space-y-3">
                <button id="start-daily-challenge" class="w-full py-3 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600 transition-colors font-medium">
                    üöÄ Start Today's Challenge
                </button>
                <button id="view-daily-leaderboard" class="w-full py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                    üèÜ View Leaderboard
                </button>
                <button id="close-daily-challenge" class="w-full py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Daily Challenge Leaderboard Modal -->
    <div id="daily-leaderboard-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center mb-6">
                <h2 class="text-xl font-bold text-blue-600 mb-2">üèÜ Daily Leaderboard</h2>
                <p class="text-gray-600" id="leaderboard-date">Today's Rankings</p>
            </div>

            <div id="leaderboard-content" class="mb-6">
                <div class="space-y-2" id="leaderboard-list">
                    <!-- Leaderboard entries will be populated here -->
                </div>
            </div>

            <div class="flex space-x-3">
                <button id="close-leaderboard" class="flex-1 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    Close
                </button>
                <button id="share-score" class="flex-1 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors">
                    üì§ Share
                </button>
            </div>
        </div>
    </div>

    <!-- Daily Challenge Results Modal -->
    <div id="daily-results-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center mb-6">
                <h2 class="text-2xl font-bold text-emerald-600 mb-2">üéâ Challenge Complete!</h2>
                <p class="text-gray-600">Daily Challenge Results</p>
            </div>

            <div id="results-content" class="mb-6">
                <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4 mb-4">
                    <div class="text-center">
                        <div class="text-3xl font-bold text-emerald-600" id="final-challenge-score">0</div>
                        <div class="text-sm text-gray-600">Your Score</div>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div class="text-center">
                        <div class="text-lg font-bold text-gray-800" id="final-rank">--</div>
                        <div class="text-xs text-gray-500">Global Rank</div>
                    </div>
                    <div class="text-center">
                        <div class="text-lg font-bold text-gray-800" id="final-words">0</div>
                        <div class="text-xs text-gray-500">Words Found</div>
                    </div>
                </div>

                <div id="streak-update" class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-4">
                    <div class="text-center">
                        <div class="text-lg font-bold text-yellow-600" id="new-streak">1</div>
                        <div class="text-sm text-gray-600">Day Streak!</div>
                        <div id="badge-earned" class="mt-2 hidden">
                            <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-yellow-100 text-yellow-800">
                                <span id="earned-badge-icon">üî•</span>
                                <span id="earned-badge-text" class="ml-1">New Badge Earned!</span>
                            </span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="space-y-3">
                <button id="view-leaderboard-from-results" class="w-full py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                    üèÜ View Leaderboard
                </button>
                <button id="share-daily-result" class="w-full py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors">
                    üì§ Share Result
                </button>
                <button id="close-daily-results" class="w-full py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Power-up Collection Modal -->
    <div id="powerup-collection-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-4 max-w-xs w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center">
                <div class="text-3xl mb-2" id="collected-powerup-icon">‚ö°</div>
                <h3 class="text-lg font-bold text-gray-800 mb-1" id="collected-powerup-name">Power-up Found!</h3>
                <p class="text-sm text-gray-600 mb-3" id="collected-powerup-description">You found a power-up!</p>
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-2 mb-3">
                    <div class="text-xs text-blue-700">
                        Total: <span id="powerup-inventory-count" class="font-bold">1</span> power-ups
                    </div>
                </div>
                <button id="close-powerup-modal" class="w-full py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors text-sm">
                    Continue Playing
                </button>
            </div>
        </div>
    </div>

    <!-- Power-up Shop Modal -->
    <div id="powerup-shop-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center mb-6">
                <h2 class="text-2xl font-bold text-purple-600 mb-2">‚ö° Power-up Shop</h2>
                <p class="text-gray-600">Manage your power-ups</p>
            </div>

            <div id="shop-inventory" class="mb-6">
                <h3 class="font-semibold text-gray-700 mb-3">Your Inventory</h3>
                <div class="grid grid-cols-2 gap-3" id="shop-powerups-list">
                    <!-- Power-ups inventory will be populated here -->
                </div>
            </div>

            <div class="border-t pt-4">
                <div class="text-center text-sm text-gray-500 mb-4">
                    Earn power-ups by finding them during gameplay!
                </div>
                <button id="close-powerup-shop" class="w-full py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Data Reset Confirmation Modal -->
    <div id="reset-confirmation-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center mb-6">
                <div class="text-6xl mb-4">‚ö†Ô∏è</div>
                <h2 class="text-2xl font-bold text-red-600 mb-2">Reset All Data</h2>
                <p class="text-gray-600">This action cannot be undone!</p>
            </div>

            <div class="mb-6">
                <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                    <h3 class="font-semibold text-red-700 mb-2">This will permanently delete:</h3>
                    <ul class="text-sm text-red-600 space-y-1">
                        <li>‚Ä¢ All high scores and leaderboards</li>
                        <li>‚Ä¢ Daily challenge progress and streaks</li>
                        <li>‚Ä¢ All achievements and unlocks</li>
                        <li>‚Ä¢ Power-up inventory</li>
                        <li>‚Ä¢ Game settings and customizations</li>
                    </ul>
                </div>
            </div>

            <div class="space-y-3">
                <button id="confirm-reset-btn" class="w-full py-3 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors font-medium">
                    üóëÔ∏è Yes, Delete Everything
                </button>
                <button id="cancel-reset-btn" class="w-full py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        const gridContainer = document.getElementById('grid-container');
        const scoreEl = document.getElementById('score');
        const timerDisplayEl = document.getElementById('timer-display');
        const currentWordDisplayEl = document.getElementById('current-word-display');
        const currentWordEl = document.getElementById('current-word');
        const wordCountEl = document.getElementById('word-count');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreEl = document.getElementById('final-score');
        const playAgainBtn = document.getElementById('play-again-btn');

        // Constants
        let GRID_SIZE = 4; // Will be set based on board size
        const GAME_TIME = 80; // seconds

        // Multiple dictionary sources for comprehensive word coverage
        const DICTIONARY_URLS = [
            'https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt',
            'https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-usa.txt',
            'https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-usa-no-swears.txt'
        ];
        const GAME_MODE = {
            TIMED: 'timed',
            UNLIMITED: 'unlimited',
            DAILY_CHALLENGE: 'daily_challenge'
        };
        const BOARD_SIZE = {
            SMALL: 4,
            LARGE: 5
        };

        // Letter distribution (weighted to favor common letters)
        const LETTER_DISTRIBUTION = "AAAAAAAAABBCCDDDDEEEEEEEEEEEEFFGGGHHIIIIIIIIIJKLLLLMMNNNNNNOOOOOOOOOPPQRRRRRRSSSSSTTTTTTTTUUUUVVWWXYYZ";

        // Comprehensive built-in word list (common words for offline play)
        const BUILT_IN_WORDS = [
            // 3-letter words
            'THE', 'AND', 'FOR', 'ARE', 'BUT', 'NOT', 'YOU', 'ALL', 'CAN', 'HER', 'WAS', 'ONE', 'OUR', 'HAD', 'BY', 'HOT', 'WORD', 'WHAT', 'SOME', 'WE', 'IT', 'DO', 'CAN', 'OUT', 'OTHER', 'WERE', 'WHICH', 'THEIR', 'TIME', 'WILL', 'HOW', 'SAID', 'EACH', 'SHE', 'TWO', 'MORE', 'VERY', 'WHAT', 'KNOW', 'JUST', 'FIRST', 'GET', 'OVER', 'THINK', 'ALSO', 'YOUR', 'WORK', 'LIFE', 'ONLY', 'NEW', 'YEARS', 'WAY', 'MAY', 'SAY', 'COME', 'ITS', 'NOW', 'MOST', 'PEOPLE', 'MY', 'MADE', 'THAN', 'BEEN', 'CALL', 'WHO', 'OIL', 'SIT', 'SET', 'RUN', 'EAT', 'FAR', 'SEA', 'EYE', 'BAD', 'BIG', 'BOX', 'BOY', 'BUS', 'CAR', 'CAT', 'CUP', 'CUT', 'DAD', 'DAY', 'DOG', 'EAR', 'END', 'FAN', 'FUN', 'GOT', 'GUN', 'HAT', 'HIT', 'JOB', 'LAW', 'LEG', 'LET', 'LOT', 'LOW', 'MAN', 'MAP', 'MOM', 'NET', 'OLD', 'PAN', 'PEN', 'PET', 'PUT', 'RED', 'SAD', 'SUN', 'TEN', 'TOP', 'TOY', 'TRY', 'USE', 'VAN', 'WAR', 'WIN', 'YES', 'YET', 'ZOO',

            // 4-letter words
            'THAT', 'WITH', 'HAVE', 'THIS', 'WILL', 'YOUR', 'FROM', 'THEY', 'KNOW', 'WANT', 'BEEN', 'GOOD', 'MUCH', 'SOME', 'TIME', 'VERY', 'WHEN', 'COME', 'HERE', 'JUST', 'LIKE', 'LONG', 'MAKE', 'MANY', 'OVER', 'SUCH', 'TAKE', 'THAN', 'THEM', 'WELL', 'WERE', 'ABLE', 'BACK', 'CALL', 'CAME', 'EACH', 'EVEN', 'FIND', 'GIVE', 'HAND', 'HIGH', 'KEEP', 'LAST', 'LEFT', 'LIFE', 'LIVE', 'LOOK', 'MADE', 'MOST', 'MOVE', 'MUST', 'NAME', 'NEED', 'NEXT', 'OPEN', 'PART', 'PLAY', 'RIGHT', 'SAID', 'SAME', 'SEEM', 'SHOW', 'SIDE', 'TELL', 'TURN', 'USED', 'WANT', 'WAYS', 'WEEK', 'WENT', 'WHAT', 'WORD', 'WORK', 'YEAR', 'ALSO', 'AREA', 'AWAY', 'BEST', 'BOTH', 'CAME', 'CASE', 'CITY', 'COME', 'COULD', 'DAYS', 'DOES', 'DOWN', 'EACH', 'EARLY', 'EVEN', 'EVER', 'FACE', 'FACT', 'FEEL', 'FELT', 'FIRE', 'FORM', 'FOUR', 'FREE', 'FULL', 'GAME', 'GAVE', 'GIRL', 'GOES', 'GONE', 'GREAT', 'GREW', 'HALF', 'HARD', 'HEAD', 'HEAR', 'HELP', 'HELD', 'HOME', 'HOPE', 'HOUR', 'IDEA', 'INTO', 'JOHN', 'KEEP', 'KIND', 'KNEW', 'LAND', 'LARGE', 'LATE', 'LEARN', 'LESS', 'LINE', 'LIST', 'LIVE', 'LONG', 'LOOK', 'LOVE', 'MAIN', 'MAKE', 'MANY', 'MEAN', 'MIND', 'MORE', 'MOVE', 'MUCH', 'MUST', 'NAME', 'NEAR', 'NEED', 'NEVER', 'NEWS', 'NEXT', 'NICE', 'NIGHT', 'NONE', 'ONCE', 'ONLY', 'OPEN', 'ORDER', 'OTHER', 'OVER', 'PART', 'PAST', 'PLAN', 'PLAY', 'POINT', 'REAL', 'ROOM', 'SAID', 'SAME', 'SEEM', 'SEEN', 'SEND', 'SHOW', 'SIDE', 'SINCE', 'SMALL', 'SOME', 'SOON', 'STILL', 'SUCH', 'SURE', 'TAKE', 'TALK', 'TELL', 'THAN', 'THAT', 'THEM', 'THEN', 'THEY', 'THIS', 'TIME', 'TOLD', 'TOOK', 'TURN', 'UNDER', 'UNTIL', 'UPON', 'USED', 'VERY', 'WANT', 'WATER', 'WAYS', 'WEEK', 'WELL', 'WENT', 'WERE', 'WHAT', 'WHEN', 'WHERE', 'WILL', 'WITH', 'WORD', 'WORK', 'YEAR', 'YOUR',

            // 5-letter words
            'ABOUT', 'AFTER', 'AGAIN', 'BEING', 'BELOW', 'COULD', 'EVERY', 'FIRST', 'FOUND', 'GREAT', 'GROUP', 'HOUSE', 'LARGE', 'LIGHT', 'MIGHT', 'NEVER', 'OTHER', 'PLACE', 'RIGHT', 'SHALL', 'SMALL', 'SOUND', 'STILL', 'THEIR', 'THERE', 'THESE', 'THINK', 'THREE', 'UNDER', 'WATER', 'WHERE', 'WHICH', 'WHILE', 'WORLD', 'WOULD', 'WRITE', 'YOUNG', 'ABOVE', 'ADDED', 'ALONE', 'ALONG', 'AMONG', 'ASKED', 'BASED', 'BEGAN', 'BEING', 'BLACK', 'BRING', 'BUILD', 'BUILT', 'CARRY', 'CAUSE', 'CHAIR', 'CHILD', 'CLEAR', 'CLOSE', 'COLOR', 'COMES', 'COURT', 'DOING', 'EARLY', 'EARTH', 'FIELD', 'FINAL', 'FORCE', 'FORMS', 'FRONT', 'GIVEN', 'GOING', 'HANDS', 'HEARD', 'HEART', 'HEAVY', 'HORSE', 'HUMAN', 'KNOWN', 'LATER', 'LEARN', 'LEAST', 'LEAVE', 'LEVEL', 'LIGHT', 'LIVED', 'LOCAL', 'MAKES', 'MEANS', 'MONEY', 'MOVED', 'MUSIC', 'NEEDS', 'NIGHT', 'NORTH', 'OFTEN', 'ORDER', 'PAPER', 'PARTS', 'PARTY', 'PEACE', 'PHONE', 'PIECE', 'PLANT', 'POINT', 'POWER', 'PRESS', 'PRICE', 'QUITE', 'REACH', 'READY', 'RIVER', 'ROUND', 'SENSE', 'SERVE', 'SHALL', 'SHORT', 'SHOWN', 'SINCE', 'SPACE', 'SPEAK', 'SPENT', 'STAGE', 'START', 'STATE', 'STORY', 'STUDY', 'TAKEN', 'TERMS', 'TODAY', 'TOTAL', 'TRADE', 'TRIED', 'TRULY', 'UNION', 'UNTIL', 'USUAL', 'VALUE', 'VOICE', 'WATCH', 'WEEKS', 'WHOLE', 'WHOSE', 'WOMAN', 'WORDS', 'WORKS', 'YEARS',

            // 6+ letter words
            'SHOULD', 'AROUND', 'BEFORE', 'CHANGE', 'DURING', 'FOLLOW', 'FRIEND', 'GROUND', 'HAPPEN', 'HAVING', 'INSIDE', 'ITSELF', 'LETTER', 'LITTLE', 'LIVING', 'MAKING', 'MATTER', 'MOMENT', 'MOTHER', 'MOVING', 'NATURE', 'NEEDED', 'NUMBER', 'OFFICE', 'OPENED', 'PEOPLE', 'PERSON', 'PLAYED', 'PLEASE', 'POLICY', 'PRETTY', 'PUBLIC', 'RATHER', 'REASON', 'RECORD', 'RESULT', 'RETURN', 'SCHOOL', 'SECOND', 'SEEMED', 'SIMPLE', 'SINGLE', 'SOCIAL', 'SOMETHING', 'SPECIAL', 'STREET', 'STRONG', 'SYSTEM', 'TAKING', 'THINGS', 'THOUGH', 'THROUGH', 'TOWARD', 'TRYING', 'TURNED', 'UNITED', 'WANTED', 'WINDOW', 'WITHIN', 'WITHOUT', 'WORKING', 'WRITING', 'WRITTEN', 'ANOTHER', 'BECAUSE', 'BETWEEN', 'COMPANY', 'CONTROL', 'COUNTRY', 'CURRENT', 'DEVELOP', 'EXAMPLE', 'GENERAL', 'GETTING', 'GOVERNMENT', 'HOWEVER', 'INCLUDE', 'INSTEAD', 'INTEREST', 'LOOKING', 'MACHINE', 'MEETING', 'NOTHING', 'PICTURE', 'PROBLEM', 'PROGRAM', 'PROJECT', 'PROVIDE', 'QUALITY', 'QUICKLY', 'READING', 'REALITY', 'RECEIVE', 'REQUIRE', 'RUNNING', 'SCIENCE', 'SERVICE', 'SEVERAL', 'SOCIETY', 'STATION', 'STUDENT', 'SUPPORT', 'SURFACE', 'TEACHER', 'THOUGHT', 'TONIGHT', 'TROUBLE', 'USUALLY', 'VERSION', 'WAITING', 'WALKING', 'WEEKEND', 'WELCOME', 'WESTERN', 'WHETHER', 'WILLING', 'WINNING', 'WORKING', 'WRITING', 'ALREADY', 'AMAZING', 'ANCIENT', 'ANIMALS', 'ANOTHER', 'ANXIETY', 'ANYBODY', 'ANYMORE', 'APPEARS', 'APPLIED', 'ARTICLE', 'ATTEMPT', 'BALANCE', 'BATTERY', 'BEDROOM', 'BENEFIT', 'BICYCLE', 'BIOLOGY', 'BROTHER', 'BROUGHT', 'BUILDER', 'BURNING', 'CABINET', 'CALCIUM', 'CALLING', 'CAMPING', 'CAPTAIN', 'CAREFUL', 'CARRIED', 'CEILING', 'CENTRAL', 'CENTURY', 'CERTAIN', 'CHAMBER', 'CHANNEL', 'CHAPTER', 'CHARITY', 'CHICKEN', 'CIRCUIT', 'CLASSIC', 'CLIMATE', 'CLOTHES', 'COLLEGE', 'COMBINE', 'COMFORT', 'COMMAND', 'COMMENT', 'COMPARE', 'COMPLEX', 'CONCEPT', 'CONCERN', 'CONDUCT', 'CONFIRM', 'CONNECT', 'CONSIST', 'CONTACT', 'CONTAIN', 'CONTENT', 'CONTEST', 'CONTEXT', 'COOKING', 'CORRECT', 'COUNCIL', 'COUNTER', 'COURAGE', 'COVERED', 'CREATED', 'CULTURE', 'CURRENT', 'CUTTING', 'DANCING', 'DEALING', 'DECIDED', 'DELIVER', 'DENSITY', 'DEPENDS', 'DESKTOP', 'DESPITE', 'DESTROY', 'DEVELOP', 'DIAMOND', 'DIGITAL', 'DINNER', 'DISEASE', 'DISPLAY', 'DISTANT', 'DIVIDED', 'DRAWING', 'DRIVING', 'DROPPED', 'EARLIER', 'EASTERN', 'ECONOMY', 'EDITION', 'ELEMENT', 'EMOTION', 'ENABLED', 'ENDLESS', 'ENGAGED', 'ENGLISH', 'ENHANCE', 'EVENING', 'EXACTLY', 'EXAMINE', 'EXCITED', 'EXECUTE', 'EXHIBIT', 'EXPLAIN', 'EXPLORE', 'EXPRESS', 'EXTREME', 'FACTORY', 'FAILURE', 'FANTASY', 'FASHION', 'FEATURE', 'FEDERAL', 'FEELING', 'FICTION', 'FIFTEEN', 'FINANCE', 'FINDING', 'FISHING', 'FITNESS', 'FOREIGN', 'FOREVER', 'FORMULA', 'FORTUNE', 'FORWARD', 'FREEDOM', 'FURTHER', 'GALLERY', 'GARBAGE', 'GARDEN', 'GENERAL', 'GENETIC', 'GENUINE', 'GETTING', 'GLASSES', 'GREATER', 'GROWING', 'HABITAT', 'HANGING', 'HAPPENS', 'HEADING', 'HEALTHY', 'HEARING', 'HEATING', 'HELPING', 'HERSELF', 'HIGHWAY', 'HIMSELF', 'HISTORY', 'HOLDING', 'HOLIDAY', 'HOUSING', 'HOWEVER', 'HUNDRED', 'HUNTING', 'HUSBAND', 'IMAGINE', 'IMPROVE', 'INCLUDE', 'INITIAL', 'INQUIRY', 'INSIGHT', 'INSTALL', 'INSTANT', 'INSTEAD', 'INTENSE', 'INTERIM', 'INVOLVE', 'JOURNAL', 'JOURNEY', 'JUSTICE', 'KEEPING', 'KITCHEN', 'KNOWING', 'LANDING', 'LARGELY', 'LASTING', 'LAUNDRY', 'LEADING', 'LEARNED', 'LEATHER', 'LEAVING', 'LIBRARY', 'LIMITED', 'LINKING', 'LISTING', 'LOADING', 'LOCATED', 'LOOKING', 'MACHINE', 'MANAGER', 'MAPPING', 'MARRIED', 'MASSIVE', 'MAXIMUM', 'MEANING', 'MEASURE', 'MEDICAL', 'MEETING', 'MENTION', 'MESSAGE', 'MILLION', 'MINERAL', 'MINIMUM', 'MISSING', 'MISSION', 'MISTAKE', 'MIXTURE', 'MONITOR', 'MORNING', 'MUSICAL', 'NATURAL', 'NEITHER', 'NETWORK', 'NEUTRAL', 'NOTHING', 'NUCLEAR', 'NURSING', 'OBVIOUS', 'OFFICER', 'ONGOING', 'OPENING', 'OPERATE', 'OPINION', 'OPTICAL', 'ORGANIC', 'OUTDOOR', 'OUTLINE', 'OUTSIDE', 'OVERALL', 'PACKAGE', 'PAINTED', 'PARKING', 'PARTIAL', 'PARTNER', 'PASSAGE', 'PASSING', 'PASSION', 'PATIENT', 'PATTERN', 'PAYMENT', 'PENALTY', 'PERFECT', 'PERFORM', 'PERHAPS', 'PICTURE', 'PLASTIC', 'POPULAR', 'PORTION', 'POVERTY', 'PRECISE', 'PREDICT', 'PREPARE', 'PRESENT', 'PREVENT', 'PRIMARY', 'PRINTER', 'PRIVACY', 'PRIVATE', 'PROBLEM', 'PROCESS', 'PRODUCE', 'PRODUCT', 'PROFILE', 'PROJECT', 'PROMISE', 'PROTECT', 'PROVIDE', 'PURPOSE', 'PUSHING', 'PUTTING', 'QUALITY', 'QUARTER', 'QUICKLY', 'RADICAL', 'RAILWAY', 'RAPIDLY', 'READILY', 'READING', 'REALITY', 'RECEIVE', 'RECOVER', 'REFLECT', 'REGULAR', 'RELATED', 'RELEASE', 'REMAINS', 'REMOVAL', 'REPLACE', 'REQUIRE', 'RESERVE', 'RESOLVE', 'RESPECT', 'RESPOND', 'RESTORE', 'RETIRED', 'REVENUE', 'REVERSE', 'ROUTINE', 'RUNNING', 'SATISFY', 'SCIENCE', 'SCRATCH', 'SECTION', 'SEEKING', 'SELLING', 'SENDING', 'SERIOUS', 'SERVICE', 'SESSION', 'SETTING', 'SEVERAL', 'SHARING', 'SHELTER', 'SHOWING', 'SIMILAR', 'SITTING', 'SIXTEEN', 'SMOKING', 'SOCIETY', 'SOMEHOW', 'SOMEONE', 'SPEAKER', 'SPECIAL', 'STATION', 'STORAGE', 'STRANGE', 'STRETCH', 'STUDENT', 'SUBJECT', 'SUCCESS', 'SUGGEST', 'SUMMARY', 'SUPPORT', 'SUPPOSE', 'SURFACE', 'SURGERY', 'SURPLUS', 'SURVIVE', 'SUSPECT', 'SUSTAIN', 'TEACHER', 'TELLING', 'TENSION', 'TESTING', 'THERAPY', 'THEREBY', 'THOUGHT', 'THROUGH', 'TONIGHT', 'TOTALLY', 'TOUCHED', 'TOWARDS', 'TRAFFIC', 'TRAINED', 'TREATED', 'TROUBLE', 'TURNING', 'TYPICAL', 'UNIFORM', 'UNKNOWN', 'UNUSUAL', 'UPGRADE', 'UTILITY', 'VARIETY', 'VEHICLE', 'VERSION', 'VILLAGE', 'VISIBLE', 'WAITING', 'WALKING', 'WARNING', 'WEARING', 'WEATHER', 'WEBSITE', 'WEDDING', 'WEEKEND', 'WELCOME', 'WELFARE', 'WESTERN', 'WHETHER', 'WILLING', 'WINNING', 'WITHOUT', 'WORKING', 'WRITING', 'WRITTEN'
        ];

        // Game variables
        let grid = [];
        let score = 0;
        let timer = GAME_TIME;
        let timerInterval;
        let foundWords = new Set();
        let isMouseDown = false;
        let currentPath = []; // Stores {row, col} of the current path
        let englishWords = new Set(); // Will store our dictionary

        // Secret command tracking
        let secretCommandsUsed = false; // Track if any secret commands were used in current game
        let currentGameMode = GAME_MODE.TIMED; // Default game mode
        let currentBoardSize = BOARD_SIZE.SMALL; // Default board size

        // Daily Challenge System
        const DAILY_CHALLENGE_KEY = 'wordHuntDailyChallenges';
        const DAILY_STREAK_KEY = 'wordHuntDailyStreak';
        const DAILY_LEADERBOARD_KEY = 'wordHuntDailyLeaderboard';

        let dailyChallengeData = {
            currentStreak: 0,
            lastPlayedDate: null,
            completedChallenges: new Map(), // challengeId -> {score, words, completed, rank}
            streakBadges: new Set() // earned streak badges
        };

        // Daily challenge configuration for automatic generation
        const DAILY_CHALLENGE_CONFIG = {
            // Starting date for daily challenges (today)
            startDate: new Date('2024-12-18'),

            // Pre-generated seeds for 100 days of challenges
            seeds: [
                12345, 67890, 23456, 78901, 34567, 89012, 45678, 90123, 56789, 1234,
                11111, 22222, 33333, 44444, 55555, 66666, 77777, 88888, 99999, 10101,
                13579, 24680, 97531, 86420, 75319, 64208, 53197, 42086, 31975, 20864,
                98765, 87654, 76543, 65432, 54321, 43210, 32109, 21098, 10987, 9876,
                19283, 47561, 83729, 56104, 92847, 38520, 74163, 61958, 25374, 80691,
                15926, 53589, 79323, 84626, 43383, 27950, 28841, 97169, 39937, 51058,
                20974, 94459, 23078, 16406, 28620, 89986, 28034, 82534, 21170, 67982,
                14808, 65132, 82306, 64709, 38446, 9550, 58223, 17253, 59408, 12847,
                56482, 13956, 62977, 47093, 69995, 95749, 66967, 62772, 40766, 30353,
                54759, 45729, 64462, 29489, 54930, 38196, 44288, 10975, 66593, 34461
            ],

            // Challenge themes for variety (optional)
            themes: [
                { name: 'Classic', gridSize: 4, timeLimit: 80 },
                { name: 'Speed Run', gridSize: 4, timeLimit: 60 },
                { name: 'Extended', gridSize: 4, timeLimit: 100 },
                { name: 'Big Grid', gridSize: 5, timeLimit: 90 },
                { name: 'Marathon', gridSize: 5, timeLimit: 120 }
            ]
        };

        let isDailyChallenge = false;
        let currentChallengeId = null;

        // Cache for findAllPossibleWords optimization
        let wordSearchCache = {
            gridHash: null,
            words: null,
            trie: null
        };

        // Power-ups System
        const POWERUPS_KEY = 'wordHuntPowerups';
        const POWERUP_TYPES = {
            TIME_FREEZE: {
                id: 'time_freeze',
                name: 'Time Freeze',
                icon: '‚ùÑÔ∏è',
                description: 'Freezes the timer for 10 seconds',
                rarity: 'common',
                duration: 10000,
                color: 'bg-blue-500'
            },
            WORD_HINT: {
                id: 'word_hint',
                name: 'Word Hint',
                icon: 'üí°',
                description: 'Reveals a random word on the grid',
                rarity: 'common',
                color: 'bg-yellow-500'
            },
            LETTER_SHUFFLE: {
                id: 'letter_shuffle',
                name: 'Letter Shuffle',
                icon: 'üîÄ',
                description: 'Shuffles all letters on the grid',
                rarity: 'uncommon',
                color: 'bg-purple-500'
            },
            POINT_MULTIPLIER: {
                id: 'point_multiplier',
                name: '2x Points',
                icon: '‚ú®',
                description: 'Double points for 30 seconds',
                rarity: 'rare',
                duration: 30000,
                multiplier: 2,
                color: 'bg-green-500'
            },
            MEGA_MULTIPLIER: {
                id: 'mega_multiplier',
                name: '3x Points',
                icon: 'üåü',
                description: 'Triple points for 20 seconds',
                rarity: 'epic',
                duration: 20000,
                multiplier: 3,
                color: 'bg-orange-500'
            },
            EXTRA_TIME: {
                id: 'extra_time',
                name: 'Extra Time',
                icon: '‚è∞',
                description: 'Adds 15 seconds to the timer',
                rarity: 'uncommon',
                timeBonus: 15,
                color: 'bg-indigo-500'
            },
            WORD_MAGNET: {
                id: 'word_magnet',
                name: 'Word Magnet',
                icon: 'üß≤',
                description: 'Highlights all 6+ letter words for 15 seconds',
                rarity: 'rare',
                duration: 15000,
                color: 'bg-pink-500'
            },
            LUCKY_GRID: {
                id: 'lucky_grid',
                name: 'Lucky Grid',
                icon: 'üçÄ',
                description: 'Replaces grid with high-scoring letters',
                rarity: 'epic',
                color: 'bg-emerald-500'
            }
        };

        // Power-up spawn rates (percentage chance per word found)
        const POWERUP_SPAWN_RATES = {
            common: 8,    // 8% chance
            uncommon: 4,  // 4% chance
            rare: 2,      // 2% chance
            epic: 0.5     // 0.5% chance
        };

        let powerupInventory = new Map(); // powerupId -> count
        let activePowerups = new Map(); // powerupId -> {endTime, data}
        let powerupSpawns = new Map(); // position -> powerupType
        let powerupEffects = {
            timeFreeze: false,
            pointMultiplier: 1,
            wordMagnet: false
        };

        // High scores management
        const HIGH_SCORES_KEY_TIMED_4X4 = 'wordHuntHighScoresTimed4x4';
        const HIGH_SCORES_KEY_UNLIMITED_4X4 = 'wordHuntHighScoresUnlimited4x4';
        const HIGH_SCORES_KEY_TIMED_5X5 = 'wordHuntHighScoresTimed5x5';
        const HIGH_SCORES_KEY_UNLIMITED_5X5 = 'wordHuntHighScoresUnlimited5x5';
        const MAX_HIGH_SCORES = 5;
        let highScores = [];

        // Game statistics
        let gamesPlayed = 0;
        let totalScore = 0;
        let bestScore = 0;
        let totalWordsFound = 0;

        // Achievements system with categories
        let achievements = {
            // Long-term achievements (progression over time)
            'first_game': { unlocked: false, name: 'First Steps', description: 'Play your first game', icon: 'üéÆ', requirement: 1, type: 'games', category: 'long-term' },
            'games_5': { unlocked: false, name: 'Getting Started', description: 'Play 5 games', icon: 'üéØ', requirement: 5, type: 'games', category: 'long-term' },
            'games_10': { unlocked: false, name: 'Regular Player', description: 'Play 10 games', icon: 'üèÜ', requirement: 10, type: 'games', category: 'long-term' },
            'games_25': { unlocked: false, name: 'Dedicated Gamer', description: 'Play 25 games', icon: 'üéñÔ∏è', requirement: 25, type: 'games', category: 'long-term' },
            'games_50': { unlocked: false, name: 'Word Hunter', description: 'Play 50 games', icon: 'üèÖ', requirement: 50, type: 'games', category: 'long-term' },
            'games_100': { unlocked: false, name: 'Century Club', description: 'Play 100 games', icon: 'üëë', requirement: 100, type: 'games', category: 'long-term' },
            'words_total_100': { unlocked: false, name: 'Wordsmith', description: 'Find 100 words total', icon: '‚úçÔ∏è', requirement: 100, type: 'words_total', category: 'long-term' },
            'words_total_500': { unlocked: false, name: 'Dictionary', description: 'Find 500 words total', icon: 'üìñ', requirement: 500, type: 'words_total', category: 'long-term' },
            'words_total_1000': { unlocked: false, name: 'Encyclopedia', description: 'Find 1000 words total', icon: 'üìö', requirement: 1000, type: 'words_total', category: 'long-term' },
            'customizer': { unlocked: false, name: 'Style Master', description: 'Use 5 different customize effects', icon: 'üé®', requirement: 5, type: 'customize', category: 'long-term' },

            // Skill-based achievements (require skill/performance)
            'score_100': { unlocked: false, name: 'First Century', description: 'Score 100 points in a game', icon: 'üíØ', requirement: 100, type: 'score', category: 'skill' },
            'score_500': { unlocked: false, name: 'High Scorer', description: 'Score 500 points in a game', icon: '‚≠ê', requirement: 500, type: 'score', category: 'skill' },
            'score_1000': { unlocked: false, name: 'Four Digits', description: 'Score 1000 points in a game', icon: 'üåü', requirement: 1000, type: 'score', category: 'skill' },
            'score_2000': { unlocked: false, name: 'Elite Player', description: 'Score 2000 points in a game', icon: 'üíé', requirement: 2000, type: 'score', category: 'skill' },
            'score_3000': { unlocked: false, name: 'Master Player', description: 'Score 3000 points in a game', icon: 'üëë', requirement: 3000, type: 'score', category: 'skill' },
            'words_10': { unlocked: false, name: 'Word Finder', description: 'Find 10 words in a single game', icon: 'üìù', requirement: 10, type: 'words_single', category: 'skill' },
            'words_20': { unlocked: false, name: 'Vocabulary Master', description: 'Find 20 words in a single game', icon: 'üìö', requirement: 20, type: 'words_single', category: 'skill' },
            'words_30': { unlocked: false, name: 'Word Wizard', description: 'Find 30 words in a single game', icon: 'üßô', requirement: 30, type: 'words_single', category: 'skill' },
            'perfect_game': { unlocked: false, name: 'Perfect Game', description: 'Find all possible words in a game', icon: 'üéØ', requirement: 1, type: 'perfect', category: 'skill' },
            'speed_demon': { unlocked: false, name: 'Speed Demon', description: 'Find 5 words in under 30 seconds', icon: '‚ö°', requirement: 5, type: 'speed', category: 'skill' },
            'lightning_fast': { unlocked: false, name: 'Lightning Fast', description: 'Find 10 words in under 60 seconds', icon: 'üå©Ô∏è', requirement: 10, type: 'speed', category: 'skill' },
            'long_word': { unlocked: false, name: 'Wordsmith Pro', description: 'Find a word with 8+ letters', icon: 'üìè', requirement: 8, type: 'word_length', category: 'skill' },
            'epic_word': { unlocked: false, name: 'Epic Wordsmith', description: 'Find a word with 10+ letters', icon: 'üìú', requirement: 10, type: 'word_length', category: 'skill' },

            // Hidden achievements (secret/discovery-based)
            'secret_finder': { unlocked: false, name: 'Secret Finder', description: 'Discover the secret menu', icon: 'üîÆ', requirement: 1, type: 'secret', category: 'hidden' },
            'effect_collector': { unlocked: false, name: 'Effect Collector', description: 'Try 10 different visual effects', icon: 'üé≠', requirement: 10, type: 'customize', category: 'hidden' },
            'night_owl': { unlocked: false, name: 'Night Owl', description: 'Play a game after midnight', icon: 'ü¶â', requirement: 1, type: 'time', category: 'hidden' },
            'early_bird': { unlocked: false, name: 'Early Bird', description: 'Play a game before 6 AM', icon: 'üê¶', requirement: 1, type: 'time', category: 'hidden' },
            'palindrome_hunter': { unlocked: false, name: 'Palindrome Hunter', description: 'Find a palindrome word', icon: 'üîÑ', requirement: 1, type: 'palindrome', category: 'hidden' },
            'vowel_master': { unlocked: false, name: 'Vowel Master', description: 'Find a word with all 5 vowels', icon: 'üÖ∞Ô∏è', requirement: 1, type: 'vowel_word', category: 'hidden' },
            'no_vowels': { unlocked: false, name: 'Consonant King', description: 'Find a word with no vowels', icon: 'üö´', requirement: 1, type: 'no_vowel_word', category: 'hidden' },
            'matrix_mode': { unlocked: false, name: 'Neo', description: 'Use Matrix effect during gameplay', icon: 'üï∂Ô∏è', requirement: 1, type: 'matrix_play', category: 'hidden' },

            // Additional Long-term Achievements
            'games_200': { unlocked: false, name: 'Bicentennial', description: 'Play 200 games', icon: 'üéä', requirement: 200, type: 'games', category: 'long-term' },
            'games_500': { unlocked: false, name: 'Half Millennium', description: 'Play 500 games', icon: 'üè∞', requirement: 500, type: 'games', category: 'long-term' },
            'games_1000': { unlocked: false, name: 'Millennium Master', description: 'Play 1000 games', icon: 'üëë', requirement: 1000, type: 'games', category: 'long-term' },
            'words_total_2000': { unlocked: false, name: 'Word Collector', description: 'Find 2000 words total', icon: 'üìö', requirement: 2000, type: 'words_total', category: 'long-term' },
            'words_total_5000': { unlocked: false, name: 'Lexicon Master', description: 'Find 5000 words total', icon: 'üìñ', requirement: 5000, type: 'words_total', category: 'long-term' },
            'words_total_10000': { unlocked: false, name: 'Dictionary God', description: 'Find 10000 words total', icon: 'üìú', requirement: 10000, type: 'words_total', category: 'long-term' },
            'daily_player': { unlocked: false, name: 'Daily Player', description: 'Play for 7 consecutive days', icon: 'üìÖ', requirement: 7, type: 'daily_streak', category: 'long-term' },
            'weekly_warrior': { unlocked: false, name: 'Weekly Warrior', description: 'Play for 30 consecutive days', icon: 'üóìÔ∏è', requirement: 30, type: 'daily_streak', category: 'long-term' },
            'monthly_master': { unlocked: false, name: 'Monthly Master', description: 'Play for 100 consecutive days', icon: 'üìÜ', requirement: 100, type: 'daily_streak', category: 'long-term' },
            'effect_master': { unlocked: false, name: 'Effect Master', description: 'Use 20 different customize effects', icon: 'üé®', requirement: 20, type: 'customize', category: 'long-term' },
            'background_artist': { unlocked: false, name: 'Background Artist', description: 'Try all background themes', icon: 'üñºÔ∏è', requirement: 11, type: 'backgrounds', category: 'long-term' },
            'score_accumulator': { unlocked: false, name: 'Score Accumulator', description: 'Reach 50000 total score', icon: 'üí∞', requirement: 50000, type: 'total_score', category: 'long-term' },
            'score_millionaire': { unlocked: false, name: 'Score Millionaire', description: 'Reach 100000 total score', icon: 'üíé', requirement: 100000, type: 'total_score', category: 'long-term' },

            // Additional Skill-based Achievements
            'score_5000': { unlocked: false, name: 'Legendary Player', description: 'Score 5000 points in a game', icon: 'üåü', requirement: 5000, type: 'score', category: 'skill' },
            'score_10000': { unlocked: false, name: 'Godlike Player', description: 'Score 10000 points in a game', icon: '‚ö°', requirement: 10000, type: 'score', category: 'skill' },
            'words_40': { unlocked: false, name: 'Word Sage', description: 'Find 40 words in a single game', icon: 'üß†', requirement: 40, type: 'words_single', category: 'skill' },
            'words_50': { unlocked: false, name: 'Word Genius', description: 'Find 50 words in a single game', icon: 'üéì', requirement: 50, type: 'words_single', category: 'skill' },
            'speed_master': { unlocked: false, name: 'Speed Master', description: 'Find 15 words in under 90 seconds', icon: 'üèÉ', requirement: 15, type: 'speed', category: 'skill' },
            'flash_finder': { unlocked: false, name: 'Flash Finder', description: 'Find 3 words in under 10 seconds', icon: '‚ö°', requirement: 3, type: 'speed_burst', category: 'skill' },
            'combo_master': { unlocked: false, name: 'Combo Master', description: 'Find 5 words in a row without mistakes', icon: 'üî•', requirement: 5, type: 'combo', category: 'skill' },
            'streak_legend': { unlocked: false, name: 'Streak Legend', description: 'Find 10 words in a row without mistakes', icon: 'üåü', requirement: 10, type: 'combo', category: 'skill' },
            'efficiency_expert': { unlocked: false, name: 'Efficiency Expert', description: 'Score 2000+ points with under 15 words', icon: 'üéØ', requirement: 1, type: 'efficiency', category: 'skill' },
            'word_length_master': { unlocked: false, name: 'Length Master', description: 'Find words of every length (3-10+)', icon: 'üìè', requirement: 8, type: 'word_variety', category: 'skill' },
            'no_mistakes': { unlocked: false, name: 'Perfectionist', description: 'Complete a game without any invalid words', icon: '‚ú®', requirement: 1, type: 'perfect_accuracy', category: 'skill' },
            'quick_start': { unlocked: false, name: 'Quick Start', description: 'Find first word within 5 seconds', icon: 'üöÄ', requirement: 1, type: 'quick_start', category: 'skill' },
            'endurance_runner': { unlocked: false, name: 'Endurance Runner', description: 'Play for full 80 seconds in timed mode', icon: '‚è±Ô∏è', requirement: 1, type: 'endurance', category: 'skill' },

            // Additional Hidden Achievements
            'weekend_warrior': { unlocked: false, name: 'Weekend Warrior', description: 'Play on both Saturday and Sunday', icon: 'üèñÔ∏è', requirement: 1, type: 'weekend', category: 'hidden' },
            'holiday_player': { unlocked: false, name: 'Holiday Player', description: 'Play on a major holiday', icon: 'üéÑ', requirement: 1, type: 'holiday', category: 'hidden' },
            'midnight_gamer': { unlocked: false, name: 'Midnight Gamer', description: 'Play exactly at midnight', icon: 'üïõ', requirement: 1, type: 'exact_time', category: 'hidden' },
            'lucky_seven': { unlocked: false, name: 'Lucky Seven', description: 'Score exactly 777 points', icon: 'üçÄ', requirement: 777, type: 'exact_score', category: 'hidden' },
            'double_trouble': { unlocked: false, name: 'Double Trouble', description: 'Find two identical words in one game', icon: 'üë•', requirement: 1, type: 'duplicate_words', category: 'hidden' },
            'alphabet_soup': { unlocked: false, name: 'Alphabet Soup', description: 'Find words starting with 10 different letters', icon: 'üî§', requirement: 10, type: 'alphabet_variety', category: 'hidden' },
            'reverse_psychology': { unlocked: false, name: 'Reverse Psychology', description: 'Find a word backwards', icon: 'üîÑ', requirement: 1, type: 'reverse_word', category: 'hidden' },
            'theme_master': { unlocked: false, name: 'Theme Master', description: 'Use every background theme in one session', icon: 'üé®', requirement: 1, type: 'theme_session', category: 'hidden' },
            'secret_sequence': { unlocked: false, name: 'Secret Sequence', description: 'Find words in alphabetical order', icon: 'üî¢', requirement: 1, type: 'alphabetical', category: 'hidden' },
            'color_blind': { unlocked: false, name: 'Color Blind', description: 'Play with 5 different visual effects active', icon: 'üåà', requirement: 5, type: 'multi_effects', category: 'hidden' },
            'minimalist': { unlocked: false, name: 'Minimalist', description: 'Score 1000+ with only 3-letter words', icon: 'üéØ', requirement: 1, type: 'minimalist', category: 'hidden' },
            'maximalist': { unlocked: false, name: 'Maximalist', description: 'Find only 6+ letter words in a game', icon: 'üìè', requirement: 1, type: 'maximalist', category: 'hidden' },
            'grid_explorer': { unlocked: false, name: 'Grid Explorer', description: 'Use every tile on the grid in one game', icon: 'üó∫Ô∏è', requirement: 1, type: 'full_grid', category: 'hidden' },
            'corner_master': { unlocked: false, name: 'Corner Master', description: 'Find words using all 4 corner tiles', icon: 'üìê', requirement: 1, type: 'corners', category: 'hidden' },
            'center_stage': { unlocked: false, name: 'Center Stage', description: 'Find 5 words all using the center tile', icon: 'üéØ', requirement: 5, type: 'center_tile', category: 'hidden' },
            'border_patrol': { unlocked: false, name: 'Border Patrol', description: 'Find words using only edge tiles', icon: 'üî≤', requirement: 1, type: 'edge_only', category: 'hidden' },
            'snake_charmer': { unlocked: false, name: 'Snake Charmer', description: 'Find a word that zigzags across the grid', icon: 'üêç', requirement: 1, type: 'zigzag', category: 'hidden' },
            'time_traveler': { unlocked: false, name: 'Time Traveler', description: 'Play in both timed and unlimited modes', icon: '‚è∞', requirement: 1, type: 'mode_variety', category: 'hidden' },
            'size_matters': { unlocked: false, name: 'Size Matters', description: 'Play on both 4x4 and 5x5 grids', icon: 'üìè', requirement: 1, type: 'grid_variety', category: 'hidden' },
            'easter_egg': { unlocked: false, name: 'Easter Egg', description: 'Find the hidden word "EASTER"', icon: 'ü•ö', requirement: 1, type: 'easter_word', category: 'hidden' },

            // Daily Challenge Achievements
            'daily_debut': { unlocked: false, name: 'Daily Debut', description: 'Complete your first daily challenge', icon: 'üìÖ', requirement: 1, type: 'daily_challenge', category: 'long-term' },
            'streak_starter': { unlocked: false, name: 'Streak Starter', description: 'Complete 3 daily challenges in a row', icon: 'üî•', requirement: 3, type: 'daily_streak', category: 'long-term' },
            'weekly_champion': { unlocked: false, name: 'Weekly Champion', description: 'Complete 7 daily challenges in a row', icon: '‚≠ê', requirement: 7, type: 'daily_streak', category: 'long-term' },
            'monthly_legend': { unlocked: false, name: 'Monthly Legend', description: 'Complete 30 daily challenges in a row', icon: 'üíé', requirement: 30, type: 'daily_streak', category: 'long-term' },
            'century_streak': { unlocked: false, name: 'Century Streak', description: 'Complete 100 daily challenges in a row', icon: 'üëë', requirement: 100, type: 'daily_streak', category: 'long-term' },
            'daily_perfectionist': { unlocked: false, name: 'Daily Perfectionist', description: 'Score 2000+ points in a daily challenge', icon: 'üéØ', requirement: 2000, type: 'daily_score', category: 'skill' },
            'daily_champion': { unlocked: false, name: 'Daily Champion', description: 'Rank #1 in a daily challenge', icon: 'ü•á', requirement: 1, type: 'daily_rank', category: 'skill' },
            'daily_podium': { unlocked: false, name: 'Daily Podium', description: 'Rank in top 3 of a daily challenge', icon: 'üèÜ', requirement: 3, type: 'daily_rank', category: 'skill' },

            // Power-up Achievements
            'power_collector': { unlocked: false, name: 'Power Collector', description: 'Collect your first power-up', icon: '‚ö°', requirement: 1, type: 'powerup_collected', category: 'hidden' },
            'power_hoarder': { unlocked: false, name: 'Power Hoarder', description: 'Collect 10 power-ups', icon: 'üîã', requirement: 10, type: 'powerup_collected', category: 'long-term' },
            'time_master': { unlocked: false, name: 'Time Master', description: 'Use a Time Freeze power-up', icon: '‚ùÑÔ∏è', requirement: 1, type: 'powerup_used', category: 'hidden' },
            'multiplier_madness': { unlocked: false, name: 'Multiplier Madness', description: 'Use a point multiplier power-up', icon: '‚ú®', requirement: 1, type: 'powerup_used', category: 'hidden' },
            'power_combo': { unlocked: false, name: 'Power Combo', description: 'Have 3 power-ups active at once', icon: 'üåü', requirement: 3, type: 'powerup_combo', category: 'skill' },
            'lucky_finder': { unlocked: false, name: 'Lucky Finder', description: 'Find an epic rarity power-up', icon: 'üçÄ', requirement: 1, type: 'powerup_rarity', category: 'hidden' }
        };

        // Achievement tracking variables
        let customizeEffectsUsed = new Set();
        let backgroundsUsed = new Set();
        let gameStartTime = 0;
        let wordsFoundInTime = 0;
        let matrixModeActive = false;
        let currentStreak = 0;
        let invalidWordCount = 0;
        let firstWordTime = 0;
        let tilesUsed = new Set();
        let lastPlayDate = null;
        let consecutiveDays = 0;
        let sessionBackgrounds = new Set();
        let activeEffectsCount = 0;

        function getHighScoreKey(mode, boardSize) {
            if (mode === GAME_MODE.TIMED) {
                return boardSize === BOARD_SIZE.SMALL ? HIGH_SCORES_KEY_TIMED_4X4 : HIGH_SCORES_KEY_TIMED_5X5;
            } else {
                return boardSize === BOARD_SIZE.SMALL ? HIGH_SCORES_KEY_UNLIMITED_4X4 : HIGH_SCORES_KEY_UNLIMITED_5X5;
            }
        }

        // Secret menu variables
        let secretCode = '';
        let secretCodeTimeout;
        let secretDotClicks = 0;
        let secretDotClickTimeout;
        let secretTouchSequence = [];
        let secretTouchTimeout;
        const REQUIRED_DOT_CLICKS = 5; // Reduced from 7 to 5
        const SECRET_TOUCH_PATTERN = ['top-left', 'top-right', 'bottom-right']; // Simplified touch pattern
        const SECRET_COMMANDS = {
            'GODMODE': enableGodMode,
            'ALLWORDS': showAllWordsCheat,
            'EXTRATIME': addExtraTime,
            'BIGPOINTS': enableBigPointsMode,
            'SLOWTIME': enableSlowTimeMode,
            'SHUFFLE': shuffleGrid,
            'ENDGAME': endGameCommand,
            'FREEZE': freezeTimer,
            'BOOST': scoreBoost,
            'HINT': showHint,
            'LUCKY': luckyGrid,
            'RESET': resetScore,
            'DOUBLE': doublePoints,
            'REVEAL': revealWord,
            'SPEED': speedMode,
            'INFINITE': infiniteTime,
            'VOWELS': vowelGrid,
            'MEGA': megaPoints,
            'GHOST': ghostMode,
            'MATRIX': matrixRain,
            'TELEPORT': teleportTiles,
            'QUANTUM': quantumGrid,
            'LASER': laserMode,
            'PORTAL': portalEffect,
            'CHAOS': chaosMode,
            'REMOVE_ALL_SECRET': removeAllSecretEffects
        };

        // Customize menu effects
        const CUSTOMIZE_EFFECTS = {
            'RAINBOW': enableRainbowMode,
            'DARKMODE': toggleDarkMode,
            'CONFETTI': triggerConfetti,
            'FLASH': flashMode,
            'ZOOM': zoomMode,
            'SPIN': spinGrid,
            'SHAKE': shakeGrid,
            'GLOW': glowMode,
            'MAGIC': magicGrid,
            'MATRIX': enableMatrixMode,
            'NEON': neonMode,
            'RETRO': retroMode,
            'SNOW': snowEffect,
            'FIRE': fireEffect,
            'BUBBLE': bubbleMode,
            'PULSE': pulseMode,
            'GRADIENT': gradientMode,
            'MIRROR': mirrorMode,
            'WAVE': waveEffect,
            'BG_BLUE': setBlueBackground,
            'BG_PURPLE': setPurpleBackground,
            'BG_GREEN': setGreenBackground,
            'BG_SUNSET': setSunsetBackground,
            'BG_OCEAN': setOceanBackground,
            'BG_FOREST': setForestBackground,
            'BG_SPACE': setSpaceBackground,
            'BG_RAINBOW': setRainbowBackground,
            'BG_DOTS': setDotsPattern,
            'BG_STRIPES': setStripesPattern,
            'BG_WAVES': setWavesPattern,
            'BG_RESET': resetBackground,
            'DISCO': discoMode,
            'HOLOGRAM': hologramEffect,
            'CYBERPUNK': cyberpunkTheme,
            'VINTAGE': vintageFilter,
            'GLITCH': glitchEffect,
            'AURORA': auroraEffect,
            'CRYSTAL': crystalTheme,
            'LAVA': lavaEffect,
            'ELECTRIC': electricEffect,
            'COSMIC': cosmicTheme,
            'REMOVE_ALL_CUSTOMIZE': removeAllCustomizeEffects,
            'ACHIEVEMENTS': openAchievementsMenu
        };
        let godModeEnabled = false;
        let rainbowModeEnabled = false;
        let bigPointsModeEnabled = false;
        let slowTimeEnabled = false;
        let darkModeEnabled = false;
        let matrixModeEnabled = false;

        // Load high scores from localStorage
        function loadHighScores() {
            try {
                const key = getHighScoreKey(currentGameMode, currentBoardSize);
                const savedScores = localStorage.getItem(key);
                if (savedScores) {
                    highScores = JSON.parse(savedScores);
                    console.log(`Loaded ${currentGameMode} ${currentBoardSize}x${currentBoardSize} high scores:`, highScores);
                } else {
                    highScores = [];
                    console.log(`No saved ${currentGameMode} ${currentBoardSize}x${currentBoardSize} high scores found`);
                }
            } catch (error) {
                console.error("Error loading high scores:", error);
                highScores = [];
            }
        }

        // Save high scores to localStorage
        function saveHighScores() {
            try {
                const key = getHighScoreKey(currentGameMode, currentBoardSize);
                localStorage.setItem(key, JSON.stringify(highScores));
                console.log(`Saved ${currentGameMode} ${currentBoardSize}x${currentBoardSize} high scores:`, highScores);
            } catch (error) {
                console.error("Error saving high scores:", error);
            }
        }

        // Update high scores with current score
        function updateHighScores() {
            // Don't save scores to leaderboard if secret commands were used
            if (secretCommandsUsed) {
                console.log("Score not saved to leaderboard: secret commands were used during this game");

                // Show a notification to inform the player
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 bg-orange-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-500';
                notification.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="text-xl">üö´</span>
                        <div>
                            <div class="font-bold">Score Not Saved</div>
                            <div class="text-sm opacity-90">Secret commands were used</div>
                        </div>
                    </div>
                `;

                document.body.appendChild(notification);

                // Animate in
                setTimeout(() => {
                    notification.classList.remove('translate-x-full');
                }, 100);

                // Auto-hide after 4 seconds
                setTimeout(() => {
                    notification.classList.add('translate-x-full');
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 500);
                }, 4000);

                // Still update the display to show current leaderboard
                displayHighScores();
                return;
            }

            // Create a new score entry
            const newScore = {
                score: score,
                date: new Date().toISOString(),
                words: foundWords.size
            };

            // Add the new score to the array
            highScores.push(newScore);

            // Sort by score (descending)
            highScores.sort((a, b) => b.score - a.score);

            // Keep only the top scores
            highScores = highScores.slice(0, MAX_HIGH_SCORES);

            // Save to localStorage
            saveHighScores();

            // Update the display
            displayHighScores();
        }

        // Display high scores in the modal
        function displayHighScores() {
            const highScoresList = document.getElementById('high-scores-list');
            if (!highScoresList) return;
            
            highScoresList.innerHTML = '';
            
            // Add game mode indicator
            const modeIndicator = document.createElement('div');
            modeIndicator.className = 'mb-2 text-center';
            modeIndicator.innerHTML = `
                <span class="inline-block px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-xs font-medium">
                    ${currentGameMode === GAME_MODE.TIMED ? 'Timed Mode' : 'Unlimited Mode'} High Scores
                </span>
            `;
            highScoresList.appendChild(modeIndicator);
            
            if (highScores.length === 0) {
                highScoresList.innerHTML += '<div class="text-center py-2 text-gray-500">No high scores yet</div>';
                return;
            }
            
            // Add each high score
            highScores.forEach((scoreData, index) => {
                const scoreRow = document.createElement('div');
                scoreRow.className = 'flex justify-between items-center py-1 border-b border-gray-200';
                
                // Add medal emoji for top 3
                let rankDisplay = `${index + 1}.`;
                if (index === 0) rankDisplay = 'ü•á ' + rankDisplay;
                else if (index === 1) rankDisplay = 'ü•à ' + rankDisplay;
                else if (index === 2) rankDisplay = 'ü•â ' + rankDisplay;
                
                // Format date
                const scoreDate = new Date(scoreData.date);
                const dateStr = scoreDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                
                // Highlight if this is the current score
                const isCurrentScore = scoreData.score === score && 
                                      scoreData.words === foundWords.size && 
                                      new Date().getTime() - scoreDate.getTime() < 60000; // Within the last minute
                
                if (isCurrentScore) {
                    scoreRow.className += ' bg-blue-50';
                }
                
                scoreRow.innerHTML = `
                    <span class="font-medium">${rankDisplay} <span class="text-gray-600">${dateStr}</span></span>
                    <span class="font-bold ${isCurrentScore ? 'text-blue-600' : ''}">${scoreData.score} <span class="text-sm font-normal">(${scoreData.words} words)</span></span>
                `;
                
                highScoresList.appendChild(scoreRow);
            });
        }

        function showOpeningUI() {
            document.getElementById('opening-ui').classList.remove('hidden');
            document.getElementById('game-container').classList.add('hidden');

            // Load and display leaderboard
            displayOpeningLeaderboard();
        }

        function hideOpeningUI() {
            document.getElementById('opening-ui').classList.add('hidden');
            document.getElementById('game-container').classList.remove('hidden');
        }

        function startGame(mode) {
            currentGameMode = mode;
            GRID_SIZE = currentBoardSize; // Use selected board size

            // Reset daily challenge state for regular games
            isDailyChallenge = false;
            currentChallengeId = null;

            hideOpeningUI();
            updateGridLayout();
            init();
        }

        function updateGridLayout() {
            const gridContainer = document.getElementById('grid-container');
            const gridSizeIndicator = document.getElementById('current-grid-size');
            const gridSizeBadge = document.getElementById('grid-size-badge');

            if (gridContainer) {
                // Remove existing grid classes
                gridContainer.classList.remove('grid-cols-4', 'grid-cols-5', 'gap-3', 'gap-4', 'md:gap-4', 'md:gap-5', 'max-w-xs', 'max-w-sm', 'max-w-md');

                // Add appropriate grid class and spacing
                gridContainer.classList.add(`grid-cols-${GRID_SIZE}`);

                if (GRID_SIZE === 5) {
                    // 5x5 grid: larger container, slightly smaller gaps to fit
                    gridContainer.classList.add('gap-3', 'md:gap-4', 'max-w-sm');
                } else {
                    // 4x4 grid: original spacing with generous gaps
                    gridContainer.classList.add('gap-4', 'md:gap-5', 'max-w-xs');
                }
            }

            // Update grid size indicators
            const sizeText = `${GRID_SIZE}√ó${GRID_SIZE}`;
            const modeText = GRID_SIZE === 4 ? 'CLASSIC' : 'CHALLENGE';

            if (gridSizeIndicator) {
                gridSizeIndicator.textContent = `${sizeText} GRID ‚Ä¢ ${modeText}`;
            }

            if (gridSizeBadge) {
                gridSizeBadge.textContent = sizeText;
                // Change badge color based on grid size
                if (GRID_SIZE === 5) {
                    gridSizeBadge.classList.remove('bg-purple-600');
                    gridSizeBadge.classList.add('bg-orange-600');
                } else {
                    gridSizeBadge.classList.remove('bg-orange-600');
                    gridSizeBadge.classList.add('bg-purple-600');
                }
            }
        }

        function displayOpeningLeaderboard() {
            const leaderboardEl = document.getElementById('opening-leaderboard');

            // Determine current mode from active tab
            let currentMode = GAME_MODE.TIMED; // Default
            if (document.getElementById('leaderboard-timed-tab').classList.contains('text-blue-600')) {
                currentMode = GAME_MODE.TIMED;
            } else if (document.getElementById('leaderboard-unlimited-tab').classList.contains('text-blue-600')) {
                currentMode = GAME_MODE.UNLIMITED;
            }

            leaderboardEl.innerHTML = '';

            // For Timed and Unlimited modes, show both board sizes
            const boardSizes = [BOARD_SIZE.SMALL, BOARD_SIZE.LARGE];

            boardSizes.forEach(boardSize => {
                const key = getHighScoreKey(currentMode, boardSize);
                let scores = [];
                try {
                    const savedScores = localStorage.getItem(key);
                    if (savedScores) {
                        scores = JSON.parse(savedScores);
                    }
                } catch (error) {
                    console.error("Error loading scores:", error);
                }

                // Create section for this board size
                const sectionTitle = document.createElement('div');
                sectionTitle.className = 'flex items-center justify-between mb-2 mt-4 first:mt-0';

                const titleText = document.createElement('span');
                titleText.className = 'text-sm font-semibold text-gray-700';
                titleText.textContent = `${boardSize}√ó${boardSize} Grid`;

                const badge = document.createElement('span');
                badge.className = `text-xs font-bold px-2 py-1 rounded-full text-white ${boardSize === 4 ? 'bg-purple-500' : 'bg-orange-500'}`;
                badge.textContent = boardSize === 4 ? 'CLASSIC' : 'CHALLENGE';

                sectionTitle.appendChild(titleText);
                sectionTitle.appendChild(badge);
                leaderboardEl.appendChild(sectionTitle);

                if (scores.length === 0) {
                    const noScores = document.createElement('div');
                    noScores.className = 'text-center py-2 text-gray-500 text-sm';
                    noScores.textContent = 'No scores yet';
                    leaderboardEl.appendChild(noScores);
                    return;
                }

                scores.slice(0, 3).forEach((scoreData, index) => {
                    const scoreRow = document.createElement('div');
                    scoreRow.className = 'flex justify-between items-center py-2 px-3 bg-gray-50 rounded-lg mb-1';

                    let rankDisplay = `${index + 1}.`;
                    if (index === 0) rankDisplay = 'ü•á';
                    else if (index === 1) rankDisplay = 'ü•à';
                    else if (index === 2) rankDisplay = 'ü•â';

                    const scoreDate = new Date(scoreData.date);
                    const dateStr = scoreDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });

                    scoreRow.innerHTML = `
                        <span class="font-medium text-sm">${rankDisplay} <span class="text-gray-600 text-xs">${dateStr}</span></span>
                        <span class="font-bold text-blue-600 text-sm">${scoreData.score} <span class="text-xs font-normal text-gray-500">(${scoreData.words}w)</span></span>
                    `;

                    leaderboardEl.appendChild(scoreRow);
                });
            });
        }

        function init() {
            // Reset game state
            score = 0;
            timer = GAME_TIME;
            foundWords = new Set();
            currentPath = [];

            // Reset achievement tracking variables
            gameStartTime = Date.now();
            wordsFoundInTime = 0;
            currentStreak = 0;
            invalidWordCount = 0;
            firstWordTime = 0;
            tilesUsed.clear();
            sessionBackgrounds.clear();
            activeEffectsCount = 0;

            // Reset power-up state
            powerupSpawns.clear();
            activePowerups.clear();
            powerupEffects = {
                timeFreeze: false,
                pointMultiplier: 1,
                wordMagnet: false
            };

            // Update power-up inventory display
            updatePowerupInventoryDisplay();

            // Clear word search cache for new grid
            wordSearchCache.gridHash = null;
            wordSearchCache.words = null;

            // Check time-based achievements
            checkAchievements(['time']);

            // Update UI elements
            const scoreEl = document.getElementById('score');
            if (scoreEl) scoreEl.textContent = '0';

            // Update timer display based on game mode
            const timerDisplayEl = document.getElementById('timer-display');
            if (timerDisplayEl) {
                if (currentGameMode === GAME_MODE.TIMED) {
                    updateTimerDisplay();
                } else {
                    timerDisplayEl.textContent = "End Game";
                    timerDisplayEl.classList.add('bg-red-500', 'hover:bg-red-600', 'cursor-pointer');
                    timerDisplayEl.title = "Click to end the game";
                }
            }

            const wordCountEl = document.getElementById('word-count');
            if (wordCountEl) wordCountEl.textContent = '0';

            const currentWordDisplayEl = document.getElementById('current-word-display');
            if (currentWordDisplayEl) {
                currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
            }

            // Hide game over modal
            const gameOverModal = document.getElementById('game-over-modal');
            if (gameOverModal) {
                gameOverModal.classList.add('hidden');
                const modalContent = gameOverModal.querySelector('div');
                if (modalContent) {
                    modalContent.classList.add('scale-95', 'opacity-0');
                }
            }

            // Generate and render the grid
            generateGrid();
            renderGrid();

            // Start the timer and add event listeners
            if (currentGameMode === GAME_MODE.TIMED) {
                startTimer();
            } else {
                // For unlimited mode, just show "--:--" in the timer
                const timerDisplayEl = document.getElementById('timer-display');
                if (timerDisplayEl) {
                    timerDisplayEl.textContent = "END GAME";
                }
            }

            addEventListeners();

            console.log(`Game initialized in ${currentGameMode} mode with grid:`, grid);
        }

        function generateGrid() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                const row = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    const randomIndex = Math.floor(Math.random() * LETTER_DISTRIBUTION.length);
                    const randomLetter = LETTER_DISTRIBUTION[randomIndex];
                    row.push(randomLetter);
                }
                grid.push(row);
            }
            console.log("Generated grid:", grid);
        }

        function renderGrid() {
            const gridContainer = document.getElementById('grid-container');
            if (!gridContainer) {
                console.error("Grid container not found!");
                return;
            }

            gridContainer.innerHTML = '';

            grid.forEach((row, rowIndex) => {
                row.forEach((letter, colIndex) => {
                    const tile = document.createElement('div');
                    tile.textContent = letter;
                    tile.dataset.row = rowIndex;
                    tile.dataset.col = colIndex;

                    // Use original tile styling with appropriate text size for grid size
                    if (GRID_SIZE === 5) {
                        tile.classList.add('tile', 'flex', 'items-center', 'justify-center', 'text-xl', 'md:text-2xl', 'font-bold', 'rounded-md', 'cursor-pointer');
                    } else {
                        tile.classList.add('tile', 'flex', 'items-center', 'justify-center', 'text-2xl', 'md:text-3xl', 'font-bold', 'rounded-md', 'cursor-pointer');
                    }

                    gridContainer.appendChild(tile);
                });
            });

            console.log("Grid rendered with", gridContainer.children.length, "tiles");
        }
        
        function addEventListeners() {
            const events = [
                ['mousedown', handleInteractionStart],
                ['mouseup', handleInteractionEnd],
                ['mouseover', handleInteractionMove],
                ['touchstart', handleInteractionStart, { passive: false }],
                ['touchend', handleInteractionEnd],
                ['touchmove', handleInteractionMove, { passive: false }]
            ];
            
            // Cleanup previous listeners
            events.forEach(([event, handler, options]) => {
                const target = ['mouseup', 'touchend'].includes(event) ? document : gridContainer;
                target.removeEventListener(event, handler, options);
            });
            
            // Add new listeners
            events.forEach(([event, handler, options]) => {
                const target = ['mouseup', 'touchend'].includes(event) ? document : gridContainer;
                target.addEventListener(event, handler, options);
            });
        }
        
        function updateTimerDisplay() {
            const timerDisplayEl = document.getElementById('timer-display');
            if (!timerDisplayEl) {
                console.error("Timer display element not found!");
                return;
            }
            
            const minutes = Math.floor(timer / 60).toString().padStart(2, '0');
            const seconds = (timer % 60).toString().padStart(2, '0');
            timerDisplayEl.textContent = `${minutes}:${seconds}`;
            console.log("Timer updated:", timerDisplayEl.textContent);
        }

        function startTimer() {
            clearInterval(timerInterval);
            updateTimerDisplay(); // Update immediately

            timerInterval = setInterval(() => {
                // Check if time freeze is active
                if (!powerupEffects.timeFreeze) {
                    timer--;
                    updateTimerDisplay();

                    if (timer <= 0) {
                        endGame();
                    }
                } else {
                    // Time is frozen, just update display to show freeze effect
                    updateTimerDisplay();
                }
            }, 1000);

            console.log("Timer started with", timer, "seconds");
        }

        // End the game
        function endGame() {
            // Clear the timer interval
            clearInterval(timerInterval);

            // Update statistics for achievements
            gamesPlayed++;
            totalScore += score;
            totalWordsFound += foundWords.size;
            if (score > bestScore) {
                bestScore = score;
            }

            // Handle daily challenge completion
            if (isDailyChallenge) {
                completeDailyChallenge();
                return;
            }

            // Check achievements (comprehensive check at game end)
            checkAchievements(['games', 'perfect', 'words_single', 'words_total']);

            // Update the final score
            const finalScoreEl = document.getElementById('final-score');
            if (finalScoreEl) {
                finalScoreEl.textContent = score;
            }
            
            // Update the game over title based on game mode
            const gameOverTitle = document.getElementById('game-over-title');
            if (gameOverTitle) {
                gameOverTitle.textContent = currentGameMode === GAME_MODE.TIMED ? "Time's Up!" : "Game Over!";
            }
            
            // Update high scores
            updateHighScores();
            
            // Reset the all possible words section
            const allPossibleWordsSection = document.getElementById('all-possible-words');
            if (allPossibleWordsSection) {
                allPossibleWordsSection.classList.add('hidden');
            }
            
            // Show the game over modal
            const gameOverModal = document.getElementById('game-over-modal');
            if (gameOverModal) {
                // Update the high scores section title to include mode
                const highScoresTitle = gameOverModal.querySelector('h3');
                if (highScoresTitle) {
                    highScoresTitle.textContent = `High Scores (${currentGameMode === GAME_MODE.TIMED ? 'Timed Mode' : 'Unlimited Mode'})`;
                }
                
                // Add mode switching tabs if they don't exist
                if (!gameOverModal.querySelector('.mode-tabs')) {
                    const highScoresSection = gameOverModal.querySelector('.mb-6.bg-gray-50.p-4.rounded-lg');
                    if (highScoresSection) {
                        const modeTabs = document.createElement('div');
                        modeTabs.className = 'mode-tabs flex mb-3 border-b border-gray-200';
                        modeTabs.innerHTML = `
                            <button class="flex-1 py-2 px-3 text-sm font-medium ${currentGameMode === GAME_MODE.TIMED ? 'text-blue-600 border-b-2 border-blue-500' : 'text-gray-500 hover:text-gray-700'}" data-mode="timed">
                                Timed Mode
                            </button>
                            <button class="flex-1 py-2 px-3 text-sm font-medium ${currentGameMode === GAME_MODE.UNLIMITED ? 'text-blue-600 border-b-2 border-blue-500' : 'text-gray-500 hover:text-gray-700'}" data-mode="unlimited">
                                Unlimited Mode
                            </button>
                        `;
                        
                        // Insert tabs before the high scores list
                        highScoresSection.insertBefore(modeTabs, highScoresSection.querySelector('h3'));
                        
                        // Add event listeners to the tabs
                        modeTabs.querySelectorAll('button').forEach(tab => {
                            tab.addEventListener('click', () => {
                                const mode = tab.getAttribute('data-mode');
                                
                                // Update active tab styling
                                modeTabs.querySelectorAll('button').forEach(t => {
                                    t.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                                    t.classList.add('text-gray-500', 'hover:text-gray-700');
                                });
                                tab.classList.remove('text-gray-500', 'hover:text-gray-700');
                                tab.classList.add('text-blue-600', 'border-b-2', 'border-blue-500');
                                
                                // Load and display high scores for the selected mode
                                const tempCurrentMode = currentGameMode;
                                currentGameMode = mode === 'timed' ? GAME_MODE.TIMED : GAME_MODE.UNLIMITED;
                                loadHighScores();
                                displayHighScores();
                                
                                // Update the high scores section title
                                const highScoresTitle = highScoresSection.querySelector('h3');
                                if (highScoresTitle) {
                                    highScoresTitle.textContent = `High Scores (${currentGameMode === GAME_MODE.TIMED ? 'Timed Mode' : 'Unlimited Mode'})`;
                                }
                                
                                // Restore the actual current mode (for when the game restarts)
                                currentGameMode = tempCurrentMode;
                            });
                        });
                    }
                } else {
                    // Update active tab styling
                    const modeTabs = gameOverModal.querySelector('.mode-tabs');
                    if (modeTabs) {
                        modeTabs.querySelectorAll('button').forEach(tab => {
                            const mode = tab.getAttribute('data-mode');
                            if ((mode === 'timed' && currentGameMode === GAME_MODE.TIMED) || 
                                (mode === 'unlimited' && currentGameMode === GAME_MODE.UNLIMITED)) {
                                tab.classList.remove('text-gray-500', 'hover:text-gray-700');
                                tab.classList.add('text-blue-600', 'border-b-2', 'border-blue-500');
                            } else {
                                tab.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                                tab.classList.add('text-gray-500', 'hover:text-gray-700');
                            }
                        });
                    }
                }
                
                gameOverModal.classList.remove('hidden');

                // Animate the modal
                setTimeout(() => {
                    const modalContent = gameOverModal.querySelector('div');
                    if (modalContent) {
                        modalContent.classList.remove('scale-95', 'opacity-0');
                    }
                }, 50);
            }
            
            console.log(`Game ended in ${currentGameMode} mode with score:`, score);
        }

        // Make endGame available globally for console access
        window.endGame = endGame;
        
        function handleInteractionStart(e) {
            e.preventDefault();
            isMouseDown = true;
            const tile = getTileFromEvent(e);
            if (tile) {
                startPath(tile);
            }
        }

        function handleInteractionMove(e) {
            if (!isMouseDown) return;
            e.preventDefault();
            const tile = getTileFromEvent(e);
            if (tile) {
                continuePath(tile);
            }
        }
        
        async function handleInteractionEnd(e) {
            if (!isMouseDown) return;
            isMouseDown = false;
            
            const word = getWordFromPath();
            if (word.length >= 3) {
                // Check word immediately without delay
                await checkWord(word);
            } else {
                // For words shorter than 3 letters, just reset the path
                currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                resetPath();
            }
        }
        
        function getTileFromEvent(e) {
            let target;
            if (e.touches && e.touches.length > 0) {
                const touch = e.touches[0];
                target = document.elementFromPoint(touch.clientX, touch.clientY);
            } else {
                target = e.target;
            }
            return target && target.classList.contains('tile') ? target : null;
        }

        function startPath(tile) {
            currentPath.push({ row: parseInt(tile.dataset.row), col: parseInt(tile.dataset.col) });
            tile.classList.add('selected');
            updateCurrentWord();
        }

        function continuePath(tile) {
            if (currentPath.length === 0) {
                startPath(tile);
                return;
            }
            
            const row = parseInt(tile.dataset.row);
            const col = parseInt(tile.dataset.col);
            
            if (currentPath.some(p => p.row === row && p.col === col)) return;

            const lastTile = currentPath[currentPath.length - 1];
            const isAdjacent = Math.abs(lastTile.row - row) <= 1 && Math.abs(lastTile.col - col) <= 1;

            if (isAdjacent) {
                currentPath.push({ row, col });
                tile.classList.add('selected');
                updateCurrentWord();
            }
        }
        
        function getWordFromPath() {
             return currentPath.map(p => grid[p.row][p.col]).join('');
        }
        
        function calculatePoints(wordLength) {
            if (wordLength === 3) return 100;
            if (wordLength === 4) return 400;
            if (wordLength === 5) return 800;
            if (wordLength === 6) return 1400;
            if (wordLength === 7) return 1800;
            if (wordLength >= 8) return 2200;
            return 0;
        }

        function updateCurrentWord() {
            const word = getWordFromPath();
            if (word) {
                // Don't show points yet, just show the word
                currentWordEl.textContent = word;
                currentWordDisplayEl.classList.remove('opacity-0', 'transform', '-translate-y-2');
            }
        }
        
        function animatePath(animationClass) {
            currentPath.forEach(p => {
                const tile = gridContainer.querySelector(`[data-row='${p.row}'][data-col='${p.col}']`);
                if (tile) {
                    tile.classList.add(animationClass);
                    setTimeout(() => tile.classList.remove(animationClass), 500);
                }
            });
        }

        function resetPath() {
            // Remove the 'selected' class from all tiles
            document.querySelectorAll('.tile.selected').forEach(tile => {
                tile.classList.remove('selected');
            });
            
            // Clear the current path
            currentPath = [];
        }

        async function checkWord(word) {
            // First check if the word has already been found
            if (foundWords.has(word)) {
                // Show the word with 0 points
                currentWordEl.textContent = `${word} (+0)`;
                // Immediately animate and reset
                animatePath('incorrect');
                setTimeout(() => {
                    currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                    resetPath();
                }, 500);
                return;
            }

            // Check if the word is in our dictionary first (faster than API call)
            if (englishWords.has(word)) {
                // Valid word - show points and update score immediately
                const points = calculatePoints(word.length);
                currentWordEl.textContent = `${word} (+${points})`;
                foundWords.add(word);
                updateScore(word);
                animatePath('correct');
                setTimeout(() => {
                    resetPath();
                }, 300);
                return;
            }

            // If not in our dictionary, try the API as a backup
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (response.ok) {
                    // Valid word - show points and update score immediately
                    const points = calculatePoints(word.length);
                    currentWordEl.textContent = `${word} (+${points})`;
                    foundWords.add(word);
                    updateScore(word);
                    animatePath('correct');
                    setTimeout(() => {
                        resetPath();
                    }, 300);
                } else {
                    // Invalid word - show 0 points
                    currentWordEl.textContent = `${word} (+0)`;
                    animatePath('incorrect');

                    // Track invalid words for achievements
                    invalidWordCount++;
                    currentStreak = 0; // Reset streak on invalid word

                    setTimeout(() => {
                        currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                        resetPath();
                    }, 500);
                }
            } catch (error) {
                console.error("Dictionary API error:", error);
                // In case of API error, treat as invalid
                currentWordEl.textContent = `${word} (+0)`;
                animatePath('incorrect');
                setTimeout(() => {
                    currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                    resetPath();
                }, 500);
            }
        }

        function updateScore(word) {
            // Apply power-up multipliers
            const basePoints = calculatePoints(word.length);
            const multipliedPoints = Math.floor(basePoints * powerupEffects.pointMultiplier);

            score += multipliedPoints;
            scoreEl.textContent = score;
            wordCountEl.textContent = foundWords.size;

            // Check for power-up collection on current path
            currentPath.forEach(pos => {
                if (collectPowerup(pos.row, pos.col)) {
                    // Power-up was collected, no need to continue checking this path
                }
            });

            // Chance to spawn new power-up after finding a word
            if (Math.random() < 0.15) { // 15% chance per word
                spawnPowerup();
            }

            // Track first word time
            if (foundWords.size === 1) {
                firstWordTime = Date.now() - gameStartTime;
            }

            // Track speed achievements
            const currentTime = Date.now();
            if (currentTime - gameStartTime < 30000) { // Within 30 seconds
                wordsFoundInTime++;
            }

            // Track streak (consecutive valid words)
            currentStreak++;

            // Track tiles used for grid exploration
            currentPath.forEach(pos => {
                tilesUsed.add(`${pos.row}-${pos.col}`);
            });

            // Check for immediate achievements
            checkAchievements(['score', 'word_length', 'speed', 'palindrome', 'vowel_word', 'no_vowel_word', 'matrix_play', 'combo', 'exact_score', 'speed_burst', 'efficiency', 'word_variety', 'perfect_accuracy', 'quick_start']);
        }
        
        playAgainBtn.addEventListener('click', init);
        window.onload = init;

        // Optimized function to find all possible words on the board with caching
        function findAllPossibleWords() {
            const startTime = performance.now();

            // Create a hash of the current grid for caching
            const gridHash = createGridHash();

            // Check if we have cached results for this grid
            if (wordSearchCache.gridHash === gridHash && wordSearchCache.words) {
                console.log(`Using cached results (${wordSearchCache.words.length} words)`);
                return wordSearchCache.words;
            }

            console.log("Finding all possible words (optimized)...");

            // Pre-compute adjacency list for faster neighbor lookup
            const adjacencyList = precomputeAdjacencyList();

            // Create or reuse trie for faster word validation
            let trie = wordSearchCache.trie;
            if (!trie) {
                trie = buildTrieFromDictionary();
                wordSearchCache.trie = trie; // Cache the trie
            }

            // Use a Set for O(1) duplicate checking
            const possibleWords = new Set();

            // Pre-allocate visited array once
            const visited = new Array(GRID_SIZE * GRID_SIZE).fill(false);

            // Try starting from each cell
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const startIndex = i * GRID_SIZE + j;
                    optimizedDFS(startIndex, grid[i][j], trie, visited, possibleWords, adjacencyList);
                }
            }

            // Convert to array and filter by length
            const validWords = Array.from(possibleWords).filter(word => word.length >= 3);

            // Cache the results
            wordSearchCache.gridHash = gridHash;
            wordSearchCache.words = validWords;

            const endTime = performance.now();
            console.log(`Found ${validWords.length} possible words in ${(endTime - startTime).toFixed(2)}ms`);
            return validWords;
        }

        // Create a hash of the current grid for caching
        function createGridHash() {
            let hash = '';
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    hash += grid[i][j];
                }
            }
            return hash + '_' + GRID_SIZE; // Include grid size in hash
        }

        // Pre-compute adjacency list for O(1) neighbor lookup
        function precomputeAdjacencyList() {
            const adjacencyList = new Array(GRID_SIZE * GRID_SIZE);

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const index = i * GRID_SIZE + j;
                    const neighbors = [];

                    // Check all 8 directions
                    for (let di = -1; di <= 1; di++) {
                        for (let dj = -1; dj <= 1; dj++) {
                            if (di === 0 && dj === 0) continue;

                            const ni = i + di;
                            const nj = j + dj;

                            if (ni >= 0 && ni < GRID_SIZE && nj >= 0 && nj < GRID_SIZE) {
                                neighbors.push(ni * GRID_SIZE + nj);
                            }
                        }
                    }

                    adjacencyList[index] = neighbors;
                }
            }

            return adjacencyList;
        }

        // Build a trie from the dictionary for faster prefix checking
        function buildTrieFromDictionary() {
            const trie = { children: {}, isWord: false };

            // Only build trie for words that could possibly be found (reasonable length)
            for (const word of englishWords) {
                if (word.length >= 3 && word.length <= 15) {
                    let node = trie;
                    for (const char of word) {
                        if (!node.children[char]) {
                            node.children[char] = { children: {}, isWord: false };
                        }
                        node = node.children[char];
                    }
                    node.isWord = true;
                }
            }

            return trie;
        }

        // Optimized DFS using flat array indexing and trie pruning
        function optimizedDFS(currentIndex, currentWord, trieNode, visited, possibleWords, adjacencyList) {
            const lastChar = currentWord[currentWord.length - 1];

            // Check if current word prefix exists in trie (early pruning)
            if (!trieNode.children[lastChar]) {
                return; // Prune: no words start with this prefix
            }

            const nextTrieNode = trieNode.children[lastChar];

            // Mark current cell as visited
            visited[currentIndex] = true;

            // If this forms a valid word, add it
            if (currentWord.length >= 3 && nextTrieNode.isWord) {
                possibleWords.add(currentWord);
            }

            // Early termination: don't explore paths longer than reasonable word length
            // Also check if there are any possible continuations in the trie
            if (currentWord.length < 15 && Object.keys(nextTrieNode.children).length > 0) {
                // Explore neighbors
                const neighbors = adjacencyList[currentIndex];
                for (let i = 0; i < neighbors.length; i++) {
                    const neighborIndex = neighbors[i];

                    if (!visited[neighborIndex]) {
                        const row = Math.floor(neighborIndex / GRID_SIZE);
                        const col = neighborIndex % GRID_SIZE;
                        const nextChar = grid[row][col];

                        // Quick check: does this character exist as a child in the trie?
                        if (nextTrieNode.children[nextChar]) {
                            const nextWord = currentWord + nextChar;
                            optimizedDFS(neighborIndex, nextWord, nextTrieNode, visited, possibleWords, adjacencyList);
                        }
                    }
                }
            }

            // Backtrack
            visited[currentIndex] = false;
        }

        // Show all possible words in the modal
        function showAllPossibleWords() {
            console.log("Showing all possible words...");
            
            const allPossibleWordsSection = document.getElementById('all-possible-words');
            const possibleWordsList = document.getElementById('possible-words-list');
            const possibleWordsCount = document.getElementById('possible-words-count');
            
            // Show loading indicator
            possibleWordsList.innerHTML = '<div class="col-span-2 text-center py-4">Finding all possible words...</div>';
            allPossibleWordsSection.classList.remove('hidden');
            
            // Use setTimeout to allow the UI to update before starting the intensive calculation
            setTimeout(() => {
                try {
                    // Find all possible words
                    const possibleWords = findAllPossibleWords();
                    
                    // Store the words in a global variable for sorting
                    window.allPossibleWords = possibleWords.map(word => ({
                        word: word,
                        length: word.length,
                        value: calculatePoints(word.length),
                        found: foundWords.has(word.toLowerCase())
                    }));
                    
                    // Display the words (default sort by length)
                    displayPossibleWords('length-desc');
                    
                    // Set up sorting buttons
                    setupSortingButtons();
                    
                } catch (error) {
                    console.error("Error finding possible words:", error);
                    possibleWordsList.innerHTML = '<div class="col-span-2 text-center py-4 text-red-500">Error finding words</div>';
                }
            }, 100);
        }

        // Display possible words with the specified sorting
        function displayPossibleWords(sortType) {
            const possibleWordsList = document.getElementById('possible-words-list');
            const possibleWordsCount = document.getElementById('possible-words-count');
            
            if (!possibleWordsList || !window.allPossibleWords) return;
            
            // Clear the list
            possibleWordsList.innerHTML = '';
            
            if (window.allPossibleWords.length === 0) {
                possibleWordsList.innerHTML = '<div class="col-span-2 text-center py-4">No words found</div>';
                return;
            }
            
            // Sort the words based on the selected sort type
            let sortedWords = [...window.allPossibleWords];
            
            switch (sortType) {
                case 'alpha':
                    sortedWords.sort((a, b) => a.word.localeCompare(b.word));
                    break;
                case 'length-desc':
                    sortedWords.sort((a, b) => b.length - a.length || a.word.localeCompare(b.word));
                    break;
                case 'value-desc':
                    sortedWords.sort((a, b) => b.value - a.value || a.word.localeCompare(b.word));
                    break;
                case 'value-asc':
                    sortedWords.sort((a, b) => a.value - b.value || a.word.localeCompare(b.word));
                    break;
            }
            
            // Group words by length or value depending on sort type
            const groupBy = sortType.startsWith('length') ? 'length' : 
                           (sortType === 'alpha' ? null : 'value');
            
            if (groupBy) {
                // Group by length or value
                const wordsByGroup = {};
                sortedWords.forEach(wordObj => {
                    const groupValue = wordObj[groupBy];
                    if (!wordsByGroup[groupValue]) {
                        wordsByGroup[groupValue] = [];
                    }
                    wordsByGroup[groupValue].push(wordObj);
                });
                
                // Get group keys and sort them
                let groupKeys = Object.keys(wordsByGroup).map(Number);
                if (sortType === 'length-desc' || sortType === 'value-desc') {
                    groupKeys.sort((a, b) => b - a);
                } else {
                    groupKeys.sort((a, b) => a - b);
                }
                
                // Display words grouped by length or value
                groupKeys.forEach(groupValue => {
                    // Create a section for this group
                    const groupSection = document.createElement('div');
                    groupSection.className = 'col-span-2 mt-2 first:mt-0';
                    
                    const groupLabel = groupBy === 'length' ? 
                        `${groupValue}-letter words (${wordsByGroup[groupValue].length})` : 
                        `${groupValue} points (${wordsByGroup[groupValue].length})`;
                        
                    groupSection.innerHTML = `<h4 class="font-semibold text-sm text-gray-700">${groupLabel}</h4>`;
                    possibleWordsList.appendChild(groupSection);
                    
                    // Add each word
                    wordsByGroup[groupValue].forEach(wordObj => {
                        const wordEl = document.createElement('div');
                        wordEl.className = 'px-2 py-1 text-sm';
                        
                        // Highlight words that were found by the player
                        if (wordObj.found) {
                            wordEl.className += ' bg-green-100 text-green-800 rounded';
                            wordEl.innerHTML = `${wordObj.word} <span class="text-xs">‚úì</span>`;
                        } else {
                            wordEl.textContent = wordObj.word;
                        }
                        
                        possibleWordsList.appendChild(wordEl);
                    });
                });
            } else {
                // Alphabetical sort - no grouping
                sortedWords.forEach(wordObj => {
                    const wordEl = document.createElement('div');
                    wordEl.className = 'px-2 py-1 text-sm';
                    
                    // Highlight words that were found by the player
                    if (wordObj.found) {
                        wordEl.className += ' bg-green-100 text-green-800 rounded';
                        wordEl.innerHTML = `${wordObj.word} <span class="text-xs">‚úì</span>`;
                    } else {
                        wordEl.textContent = wordObj.word;
                    }
                    
                    possibleWordsList.appendChild(wordEl);
                });
            }
            
            // Update the count
            const foundCount = window.allPossibleWords.filter(wordObj => wordObj.found).length;
            possibleWordsCount.textContent = `You found ${foundCount} out of ${window.allPossibleWords.length} possible words (${Math.round((foundCount / window.allPossibleWords.length) * 100) || 0}%)`;
        }

        // Set up sorting buttons
        function setupSortingButtons() {
            const sortButtons = [
                { id: 'sort-length-desc', type: 'length-desc' },
                { id: 'sort-alpha', type: 'alpha' },
                { id: 'sort-value-desc', type: 'value-desc' },
                { id: 'sort-value-asc', type: 'value-asc' }
            ];
            
            sortButtons.forEach(button => {
                const buttonEl = document.getElementById(button.id);
                if (buttonEl) {
                    buttonEl.addEventListener('click', () => {
                        // Update active button styling
                        sortButtons.forEach(b => {
                            const el = document.getElementById(b.id);
                            if (el) {
                                el.classList.remove('bg-blue-100', 'text-blue-800', 'active-sort');
                                el.classList.add('bg-gray-100', 'text-gray-800');
                            }
                        });
                        
                        buttonEl.classList.remove('bg-gray-100', 'text-gray-800');
                        buttonEl.classList.add('bg-blue-100', 'text-blue-800', 'active-sort');
                        
                        // Display words with the selected sorting
                        displayPossibleWords(button.type);
                    });
                }
            });
        }

        // Set up event listeners
        function setupEventListeners() {
            // Play again button
            const playAgainBtn = document.getElementById('play-again-btn');
            if (playAgainBtn) {
                playAgainBtn.addEventListener('click', () => {
                    // Hide the game over modal
                    const gameOverModal = document.getElementById('game-over-modal');
                    if (gameOverModal) {
                        const modalContent = gameOverModal.querySelector('div');
                        if (modalContent) {
                            modalContent.classList.add('scale-95', 'opacity-0');
                        }

                        setTimeout(() => {
                            gameOverModal.classList.add('hidden');
                            // Return to opening UI
                            showOpeningUI();
                        }, 300);
                    }
                });
            }
            
            // Show all words button
            const showAllWordsBtn = document.getElementById('show-all-words-btn');
            if (showAllWordsBtn) {
                showAllWordsBtn.addEventListener('click', () => {
                    console.log("Show all words button clicked");
                    showAllPossibleWords();
                });
            }
            
            // Game mode toggle buttons
            const timedModeBtn = document.getElementById('timed-mode-btn');
            const unlimitedModeBtn = document.getElementById('unlimited-mode-btn');

            if (timedModeBtn && unlimitedModeBtn) {
                timedModeBtn.addEventListener('click', () => {
                    if (currentGameMode !== GAME_MODE.TIMED) {
                        setGameMode(GAME_MODE.TIMED);
                    }
                });

                unlimitedModeBtn.addEventListener('click', () => {
                    if (currentGameMode !== GAME_MODE.UNLIMITED) {
                        setGameMode(GAME_MODE.UNLIMITED);
                    }
                });
            }
            
            // Add end game button for unlimited mode
            const timerDisplayEl = document.getElementById('timer-display');
            if (timerDisplayEl) {
                timerDisplayEl.addEventListener('click', () => {
                    if (currentGameMode === GAME_MODE.UNLIMITED) {
                        endGame();
                    }
                });
            }

            // Customize button
            const customizeBtn = document.getElementById('customize-btn');
            if (customizeBtn) {
                customizeBtn.addEventListener('click', () => {
                    openCustomizeMenu();
                });
            }

            // Back to menu button
            const backToMenuBtn = document.getElementById('back-to-menu-btn');
            if (backToMenuBtn) {
                backToMenuBtn.addEventListener('click', () => {
                    showOpeningUI();
                });
            }

            // Reset confirmation modal buttons
            const confirmResetBtn = document.getElementById('confirm-reset-btn');
            const cancelResetBtn = document.getElementById('cancel-reset-btn');

            if (confirmResetBtn) {
                confirmResetBtn.addEventListener('click', () => {
                    hideResetConfirmationModal();
                    resetAllData();
                });
            }

            if (cancelResetBtn) {
                cancelResetBtn.addEventListener('click', () => {
                    hideResetConfirmationModal();
                });
            }
        }

        // Add mobile touch pattern detection for secret menu
        function setupMobileTouchPattern() {
            const gridContainer = document.getElementById('grid-container');
            if (!gridContainer) return;

            let touchStartTime = 0;
            let touchPattern = [];

            gridContainer.addEventListener('touchstart', (e) => {
                // Disable mobile secret access for Daily Challenge mode
                if (isDailyChallenge) {
                    return; // No secret access in competitive modes
                }

                if (e.touches.length === 1) {
                    touchStartTime = Date.now();
                    const touch = e.touches[0];
                    const rect = gridContainer.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;

                    // Determine which area was touched
                    const area = getTouchArea(x, y, rect.width, rect.height);

                    // Only add to pattern if it's a quick tap (less than 300ms)
                    setTimeout(() => {
                        if (Date.now() - touchStartTime < 300) {
                            touchPattern.push(area);

                            // Reset pattern after 4 seconds of inactivity
                            clearTimeout(secretTouchTimeout);
                            secretTouchTimeout = setTimeout(() => {
                                touchPattern = [];
                            }, 4000);

                            // Check if pattern matches
                            if (touchPattern.length === SECRET_TOUCH_PATTERN.length) {
                                const isCorrect = touchPattern.every((area, index) =>
                                    area === SECRET_TOUCH_PATTERN[index]
                                );

                                if (isCorrect) {
                                    touchPattern = [];
                                    showMobileSecretAccess();
                                } else {
                                    touchPattern = [];
                                }
                            }
                        }
                    }, 300);
                }
            });
        }

        function getTouchArea(x, y, width, height) {
            const thirdW = width / 3;
            const thirdH = height / 3;

            if (x < thirdW && y < thirdH) return 'top-left';
            if (x > 2 * thirdW && y < thirdH) return 'top-right';
            if (x < thirdW && y > 2 * thirdH) return 'bottom-left';
            if (x > 2 * thirdW && y > 2 * thirdH) return 'bottom-right';
            if (x > thirdW && x < 2 * thirdW && y > thirdH && y < 2 * thirdH) return 'center';
            return 'other';
        }

        function showMobileSecretAccess() {
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 left-4 bg-purple-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 text-sm';
            notification.innerHTML = 'üì± Mobile secret access granted!';
            document.body.appendChild(notification);

            setTimeout(() => {
                document.body.removeChild(notification);
                openSecretMenu();
            }, 1500);
        }

        // Setup opening UI event listeners
        function setupOpeningUI() {
            // Board size selection buttons
            const board4x4Btn = document.getElementById('board-4x4-btn');
            const board5x5Btn = document.getElementById('board-5x5-btn');

            if (board4x4Btn && board5x5Btn) {
                board4x4Btn.addEventListener('click', () => {
                    currentBoardSize = BOARD_SIZE.SMALL;
                    updateBoardSizeSelection();
                });

                board5x5Btn.addEventListener('click', () => {
                    currentBoardSize = BOARD_SIZE.LARGE;
                    updateBoardSizeSelection();
                });
            }
        }

        function updateBoardSizeSelection() {
            const board4x4Btn = document.getElementById('board-4x4-btn');
            const board5x5Btn = document.getElementById('board-5x5-btn');
            const selectedText = document.getElementById('selected-board-size');
            const selected4x4 = document.getElementById('selected-4x4');
            const selected5x5 = document.getElementById('selected-5x5');

            if (currentBoardSize === BOARD_SIZE.SMALL) {
                // Update 4x4 button styling
                board4x4Btn.classList.remove('border-transparent');
                board4x4Btn.classList.add('border-purple-300', 'shadow-lg');
                board5x5Btn.classList.remove('border-orange-300', 'shadow-lg');
                board5x5Btn.classList.add('border-transparent');

                // Update selection indicators
                selected4x4.classList.remove('opacity-0');
                selected5x5.classList.add('opacity-0');
                selectedText.textContent = '4√ó4 Classic';
                selectedText.className = 'font-bold text-purple-600';
            } else {
                // Update 5x5 button styling
                board5x5Btn.classList.remove('border-transparent');
                board5x5Btn.classList.add('border-orange-300', 'shadow-lg');
                board4x4Btn.classList.remove('border-purple-300', 'shadow-lg');
                board4x4Btn.classList.add('border-transparent');

                // Update selection indicators
                selected5x5.classList.remove('opacity-0');
                selected4x4.classList.add('opacity-0');
                selectedText.textContent = '5√ó5 Challenge';
                selectedText.className = 'font-bold text-orange-600';
            }

            // Start game buttons
            const startTimedBtn = document.getElementById('start-timed-btn');
            const startUnlimitedBtn = document.getElementById('start-unlimited-btn');

            if (startTimedBtn) {
                startTimedBtn.addEventListener('click', () => {
                    startGame(GAME_MODE.TIMED);
                });
            }

            if (startUnlimitedBtn) {
                startUnlimitedBtn.addEventListener('click', () => {
                    startGame(GAME_MODE.UNLIMITED);
                });
            }

            // Opening customize button
            const openingCustomizeBtn = document.getElementById('opening-customize-btn');
            if (openingCustomizeBtn) {
                openingCustomizeBtn.addEventListener('click', () => {
                    openCustomizeMenu();
                });
            }

            // Opening achievements button
            const openingAchievementsBtn = document.getElementById('opening-achievements-btn');
            if (openingAchievementsBtn) {
                openingAchievementsBtn.addEventListener('click', () => {
                    openAchievementsMenu();
                });
            }

            // Opening daily challenge button
            const openingDailyChallengeBtn = document.getElementById('opening-daily-challenge-btn');
            if (openingDailyChallengeBtn) {
                openingDailyChallengeBtn.addEventListener('click', () => {
                    openDailyChallengeModal();
                });
            }

            // Data reset button
            const resetDataBtn = document.getElementById('reset-data-btn');
            if (resetDataBtn) {
                resetDataBtn.addEventListener('click', () => {
                    showResetConfirmationModal();
                });
            }

            // Leaderboard tabs
            const timedTab = document.getElementById('leaderboard-timed-tab');
            const unlimitedTab = document.getElementById('leaderboard-unlimited-tab');

            if (timedTab && unlimitedTab) {
                timedTab.addEventListener('click', () => {
                    // Update tab styling
                    timedTab.classList.remove('text-gray-500', 'hover:text-gray-700');
                    timedTab.classList.add('text-blue-600', 'border-b-2', 'border-blue-500');
                    unlimitedTab.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                    unlimitedTab.classList.add('text-gray-500', 'hover:text-gray-700');

                    // Update leaderboard
                    displayOpeningLeaderboard();
                });

                unlimitedTab.addEventListener('click', () => {
                    // Update tab styling
                    unlimitedTab.classList.remove('text-gray-500', 'hover:text-gray-700');
                    unlimitedTab.classList.add('text-blue-600', 'border-b-2', 'border-blue-500');
                    timedTab.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                    timedTab.classList.add('text-gray-500', 'hover:text-gray-700');

                    // Update leaderboard
                    displayOpeningLeaderboard();
                });
            }
        }

        // Set the game mode
        function setGameMode(mode) {
            if (mode === currentGameMode) return;

            currentGameMode = mode;

            // Update UI to reflect the current mode
            const timedModeBtn = document.getElementById('timed-mode-btn');
            const unlimitedModeBtn = document.getElementById('unlimited-mode-btn');
            const timerDisplayEl = document.getElementById('timer-display');

            if (timedModeBtn && unlimitedModeBtn) {
                // Reset all buttons
                timedModeBtn.classList.remove('bg-blue-500', 'text-white');
                timedModeBtn.classList.add('text-gray-700');
                unlimitedModeBtn.classList.remove('bg-blue-500', 'text-white');
                unlimitedModeBtn.classList.add('text-gray-700');

                if (mode === GAME_MODE.TIMED) {
                    timedModeBtn.classList.add('bg-blue-500', 'text-white');
                    timedModeBtn.classList.remove('text-gray-700');

                    // Show timer display
                    if (timerDisplayEl) {
                        timerDisplayEl.textContent = `${Math.floor(timer / 60).toString().padStart(2, '0')}:${(timer % 60).toString().padStart(2, '0')}`;
                        timerDisplayEl.classList.remove('bg-red-500', 'hover:bg-red-600', 'cursor-pointer');
                        timerDisplayEl.title = "";
                    }
                } else {
                    unlimitedModeBtn.classList.add('bg-blue-500', 'text-white');
                    unlimitedModeBtn.classList.remove('text-gray-700');

                    // Replace timer with end game button
                    if (timerDisplayEl) {
                        clearInterval(timerInterval);
                        timerDisplayEl.textContent = "End Game";
                        timerDisplayEl.classList.add('bg-red-500', 'hover:bg-red-600', 'cursor-pointer');
                        timerDisplayEl.title = "Click to end the game";
                    }
                }
            }

            // Load high scores for the selected mode
            loadHighScores();

            // Start a new game with the new mode
            init();

            console.log(`Game mode changed to: ${mode}`);
        }

        // Data reset functions
        function showResetConfirmationModal() {
            const modal = document.getElementById('reset-confirmation-modal');
            modal.classList.remove('hidden');
            setTimeout(() => {
                const content = modal.querySelector('div');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function hideResetConfirmationModal() {
            const modal = document.getElementById('reset-confirmation-modal');
            const content = modal.querySelector('div');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        function resetAllData() {
            try {
                console.log('Starting data reset...');

                // Debug: Show all localStorage keys
                const allKeys = Object.keys(localStorage);
                console.log('All localStorage keys:', allKeys);

                // Get all localStorage keys that belong to this game
                const gameKeys = allKeys.filter(key =>
                    key.includes('wordHunt') ||
                    key.includes('WordHunt') ||
                    key.includes('wordhunt')
                );

                console.log('Found game keys:', gameKeys);
                console.log('Total game keys to remove:', gameKeys.length);

                // Remove all game-related keys
                gameKeys.forEach(key => {
                    console.log('Removing key:', key);
                    localStorage.removeItem(key);
                });

                // Also remove any keys that might have different naming
                const additionalKeys = [
                    'wordHuntHighScoresTimed4x4',
                    'wordHuntHighScoresUnlimited4x4',
                    'wordHuntHighScoresTimed5x5',
                    'wordHuntHighScoresUnlimited5x5',
                    'wordHuntDailyChallenges',
                    'wordHuntDailyStreak',
                    'wordHuntAchievements',
                    'wordHuntPowerups',
                    'wordHuntSettings',
                    'wordHuntCustomizations',
                    'wordHuntBackgrounds',
                    'wordHuntEffects'
                ];

                additionalKeys.forEach(key => {
                    if (localStorage.getItem(key)) {
                        console.log('Removing additional key:', key);
                        localStorage.removeItem(key);
                    }
                });

                // Remove all daily challenge leaderboards (they start with specific prefix)
                allKeys.forEach(key => {
                    if (key.includes('wordHuntDailyLeaderboard')) {
                        console.log('Removing daily leaderboard key:', key);
                        localStorage.removeItem(key);
                    }
                });

                console.log('All game data has been reset');

                // Show success notification
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-500';
                notification.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="text-xl">‚úÖ</span>
                        <div>
                            <div class="font-bold">Data Reset Complete</div>
                            <div class="text-sm opacity-90">All game data has been cleared</div>
                        </div>
                    </div>
                `;

                document.body.appendChild(notification);

                // Animate in
                setTimeout(() => {
                    notification.classList.remove('translate-x-full');
                }, 100);

                // Auto-hide after 3 seconds
                setTimeout(() => {
                    notification.classList.add('translate-x-full');
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 500);
                }, 3000);

                // Verify the reset worked
                const remainingKeys = Object.keys(localStorage).filter(key =>
                    key.includes('wordHunt') || key.includes('WordHunt') || key.includes('wordhunt')
                );

                if (remainingKeys.length > 0) {
                    console.warn('Some keys were not removed:', remainingKeys);
                    // Try to remove them one more time
                    remainingKeys.forEach(key => {
                        try {
                            localStorage.removeItem(key);
                        } catch (e) {
                            console.warn('Could not remove key:', key, e);
                        }
                    });
                } else {
                    console.log('All game keys successfully removed');
                }

                // Reload the page to reset everything
                setTimeout(() => {
                    window.location.reload();
                }, 2000);

            } catch (error) {
                console.error('Error resetting data:', error);

                // Show error notification with more details
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 bg-red-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 max-w-sm';
                notification.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="text-xl">‚ùå</span>
                        <div>
                            <div class="font-bold">Reset Failed</div>
                            <div class="text-sm opacity-90">Error: ${error.message}</div>
                            <div class="text-xs opacity-75 mt-1">Check console for details</div>
                        </div>
                    </div>
                `;

                document.body.appendChild(notification);

                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 5000);
            }
        }

        // Debug function to check localStorage
        function debugLocalStorage() {
            console.log('=== localStorage Debug ===');
            const allKeys = Object.keys(localStorage);
            console.log('Total keys:', allKeys.length);

            const gameKeys = allKeys.filter(key =>
                key.includes('wordHunt') ||
                key.includes('WordHunt') ||
                key.includes('wordhunt')
            );

            console.log('Game-related keys:', gameKeys);
            gameKeys.forEach(key => {
                const value = localStorage.getItem(key);
                console.log(`${key}:`, value ? value.substring(0, 100) + '...' : 'null');
            });

            return {
                totalKeys: allKeys.length,
                gameKeys: gameKeys,
                allKeys: allKeys
            };
        }

        // Load the English words dictionary from multiple sources
        async function loadDictionary() {
            console.log('Loading comprehensive dictionary...');

            // Start with built-in words for immediate functionality
            englishWords = new Set(BUILT_IN_WORDS.map(word => word.toUpperCase()));
            console.log(`Loaded ${englishWords.size} built-in words`);

            // Load additional words from online sources
            let totalLoaded = englishWords.size;

            for (const url of DICTIONARY_URLS) {
                try {
                    console.log(`Loading additional words from: ${url}`);
                    const response = await fetch(url);

                    if (response.ok) {
                        const text = await response.text();
                        const words = text.split('\n')
                            .map(word => word.trim().toUpperCase())
                            .filter(word => word.length >= 3 && word.length <= 15) // Reasonable word length
                            .filter(word => /^[A-Z]+$/.test(word)); // Only letters

                        // Add new words to the set
                        const beforeSize = englishWords.size;
                        words.forEach(word => englishWords.add(word));
                        const newWords = englishWords.size - beforeSize;

                        console.log(`Added ${newWords} new words from ${url}`);
                        totalLoaded += newWords;
                    } else {
                        console.warn(`Failed to load from ${url}: ${response.status}`);
                    }
                } catch (error) {
                    console.warn(`Error loading from ${url}:`, error.message);
                }
            }

            // Add common word variations and plurals
            addWordVariations();

            console.log(`Dictionary loading complete! Total words: ${englishWords.size}`);
        }

        // Add common word variations to expand the dictionary
        function addWordVariations() {
            const originalWords = Array.from(englishWords);
            let addedVariations = 0;

            originalWords.forEach(word => {
                // Add common plurals
                if (word.length >= 3 && word.length <= 12) {
                    // Add 'S' plural
                    if (!word.endsWith('S')) {
                        englishWords.add(word + 'S');
                        addedVariations++;
                    }

                    // Add 'ES' plural for words ending in certain letters
                    if (word.endsWith('CH') || word.endsWith('SH') || word.endsWith('X') || word.endsWith('Z')) {
                        englishWords.add(word + 'ES');
                        addedVariations++;
                    }

                    // Add 'IES' plural for words ending in 'Y'
                    if (word.endsWith('Y') && word.length > 3) {
                        const stem = word.slice(0, -1);
                        englishWords.add(stem + 'IES');
                        addedVariations++;
                    }
                }

                // Add common verb forms
                if (word.length >= 3 && word.length <= 10) {
                    // Add 'ED' past tense
                    if (!word.endsWith('ED')) {
                        englishWords.add(word + 'ED');
                        addedVariations++;

                        // Double consonant + ED (e.g., RUN -> RUNNED, though not always correct)
                        if (word.length >= 3 && /[BCDFGHJKLMNPQRSTVWXYZ]$/.test(word)) {
                            const lastChar = word.slice(-1);
                            englishWords.add(word + lastChar + 'ED');
                            addedVariations++;
                        }
                    }

                    // Add 'ING' present participle
                    if (!word.endsWith('ING')) {
                        englishWords.add(word + 'ING');
                        addedVariations++;

                        // Double consonant + ING
                        if (word.length >= 3 && /[BCDFGHJKLMNPQRSTVWXYZ]$/.test(word)) {
                            const lastChar = word.slice(-1);
                            englishWords.add(word + lastChar + 'ING');
                            addedVariations++;
                        }
                    }

                    // Add 'ER' comparative/agent
                    if (!word.endsWith('ER') && word.length <= 8) {
                        englishWords.add(word + 'ER');
                        addedVariations++;
                    }

                    // Add 'EST' superlative
                    if (!word.endsWith('EST') && word.length <= 7) {
                        englishWords.add(word + 'EST');
                        addedVariations++;
                    }
                }
            });

            console.log(`Added ${addedVariations} word variations`);
        }

        // Add secret menu functionality
        function setupSecretMenu() {
            // Listen for key presses to detect secret code
            document.addEventListener('keydown', (e) => {
                // Disable secret commands for Daily Challenge mode
                if (isDailyChallenge) {
                    return; // No secret commands in competitive modes
                }

                // Only capture letter keys
                if (/^[a-zA-Z]$/.test(e.key)) {
                    secretCode += e.key.toUpperCase();

                    // Reset the timeout
                    clearTimeout(secretCodeTimeout);

                    // Check if the current code matches any commands
                    Object.keys(SECRET_COMMANDS).forEach(command => {
                        if (secretCode.endsWith(command)) {
                            // Mark that secret commands were used in this game
                            secretCommandsUsed = true;

                            // Execute the command
                            SECRET_COMMANDS[command]();

                            // Show a notification
                            showSecretCommandNotification(command);

                            // Update UI to show secret commands indicator
                            updatePowerupInventoryDisplay();

                            // Reset the code
                            secretCode = '';
                            return;
                        }
                    });

                    // Set a timeout to reset the code after 2 seconds of inactivity
                    secretCodeTimeout = setTimeout(() => {
                        secretCode = '';
                    }, 2000);
                }
            });

            console.log("Secret menu initialized. Try typing secret commands!");
        }

        // Secret command functions
        function enableGodMode() {
            godModeEnabled = !godModeEnabled;
            console.log(`God Mode ${godModeEnabled ? 'enabled' : 'disabled'}`);
            
            if (godModeEnabled) {
                // In God Mode, all words are valid
                window.originalCheckWord = checkWord;
                checkWord = function(word) {
                    if (word.length < 3) return;
                    
                    // Always treat as valid word
                    const points = calculatePoints(word.length) * 2; // Double points in God Mode
                    currentWordEl.textContent = `${word} (+${points}) GOD MODE!`;
                    foundWords.add(word);
                    
                    // Update score
                    score += points;
                    scoreEl.textContent = score;
                    wordCountEl.textContent = foundWords.size;
                    
                    // Animate
                    animatePath('correct');
                    setTimeout(() => {
                        resetPath();
                    }, 300);
                };
            } else {
                // Restore original function
                if (window.originalCheckWord) {
                    checkWord = window.originalCheckWord;
                }
            }
        }

        function showAllWordsCheat() {
            // Find all possible words and highlight them on the grid
            const possibleWords = findAllPossibleWords();
            console.log(`Cheat activated: Found ${possibleWords.length} possible words`);
            
            // Show a temporary overlay with some of the words
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50';
            overlay.innerHTML = `
                <div class="bg-white p-6 rounded-xl max-w-md max-h-96 overflow-auto">
                    <h3 class="text-xl font-bold mb-3">Secret Cheat: Word List</h3>
                    <p class="mb-3 text-sm text-gray-600">Here are some of the highest-scoring words:</p>
                    <div class="grid grid-cols-2 gap-2">
                        ${possibleWords
                            .sort((a, b) => calculatePoints(b.length) - calculatePoints(a.length))
                            .slice(0, 20)
                            .map(word => `<div class="bg-blue-100 px-2 py-1 rounded text-blue-800">${word} (${calculatePoints(word.length)})</div>`)
                            .join('')
                        }
                    </div>
                    <p class="mt-4 text-xs text-gray-500">Click anywhere to close</p>
                </div>
            `;
            
            document.body.appendChild(overlay);
            overlay.addEventListener('click', () => {
                document.body.removeChild(overlay);
            });
        }

        function addExtraTime() {
            if (currentGameMode === GAME_MODE.TIMED) {
                timer += 30; // Add 30 seconds
                updateTimerDisplay();
                console.log("Extra time added: +30 seconds");
            } else {
                console.log("Extra time can only be added in timed modes");
            }
        }

        function enableRainbowMode() {
            rainbowModeEnabled = !rainbowModeEnabled;
            console.log(`Rainbow Mode ${rainbowModeEnabled ? 'enabled' : 'disabled'}`);
            
            const tiles = document.querySelectorAll('.tile');
            
            if (rainbowModeEnabled) {
                // Add rainbow animation to all tiles
                tiles.forEach(tile => {
                    tile.classList.add('rainbow-animation');
                });
                
                // Add CSS for rainbow animation if it doesn't exist
                if (!document.getElementById('rainbow-style')) {
                    const style = document.createElement('style');
                    style.id = 'rainbow-style';
                    style.textContent = `
                        @keyframes rainbow {
                            0% { background-color: #ff0000; }
                            14% { background-color: #ff7f00; }
                            28% { background-color: #ffff00; }
                            42% { background-color: #00ff00; }
                            57% { background-color: #0000ff; }
                            71% { background-color: #4b0082; }
                            85% { background-color: #9400d3; }
                            100% { background-color: #ff0000; }
                        }
                        .rainbow-animation {
                            animation: rainbow 5s linear infinite;
                            color: white !important;
                            text-shadow: 0 0 3px black;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                // Remove rainbow animation
                tiles.forEach(tile => {
                    tile.classList.remove('rainbow-animation');
                });
            }
        }

        function enableBigPointsMode() {
            bigPointsModeEnabled = !bigPointsModeEnabled;
            console.log(`Big Points Mode ${bigPointsModeEnabled ? 'enabled' : 'disabled'}`);
            
            // Store original function if not already stored
            if (!window.originalCalculatePoints) {
                window.originalCalculatePoints = calculatePoints;
            }
            
            if (bigPointsModeEnabled) {
                // Override the points calculation
                calculatePoints = function(wordLength) {
                    // 5x normal points
                    if (wordLength === 3) return 500;
                    if (wordLength === 4) return 2000;
                    if (wordLength === 5) return 4000;
                    if (wordLength === 6) return 7000;
                    if (wordLength === 7) return 9000;
                    if (wordLength >= 8) return 11000;
                    return 0;
                };
            } else {
                // Restore original function
                if (window.originalCalculatePoints) {
                    calculatePoints = window.originalCalculatePoints;
                }
            }
        }

        function showSecretCommandNotification(command) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-purple-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-300';
            notification.innerHTML = `
                <div class="flex items-center">
                    <span class="text-lg mr-2">üîÆ</span>
                    <div>
                        <div class="font-bold">Secret Command Activated!</div>
                        <div class="text-sm">${command}</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Add a secret dot only to the game score header during gameplay (requires 5 clicks)
        function addSecretDot() {
            // Disable secret menu for Daily Challenge mode
            if (isDailyChallenge) {
                return; // No secret access in competitive modes
            }

            // Only add to the game score header when game is active
            const gameContainer = document.getElementById('game-container');
            if (!gameContainer || gameContainer.classList.contains('hidden')) {
                return; // Don't add if game is not active
            }

            const scoreHeader = document.querySelector('#game-container .bg-white.rounded-xl.shadow-lg');
            if (!scoreHeader || scoreHeader.querySelector('.secret-dot')) {
                return; // Don't add if already exists
            }

            // Create the secret dot (small but visible)
            const secretDot = document.createElement('div');
            secretDot.className = 'secret-dot absolute top-2 right-2 w-2 h-2 rounded-full bg-gray-400 cursor-pointer';
            secretDot.style.opacity = '0.3';
            secretDot.style.transition = 'all 0.2s ease';
            secretDot.title = 'Secret access';

            // Make sure the score header has position relative
            scoreHeader.style.position = 'relative';

            // Add the dot to the score header
            scoreHeader.appendChild(secretDot);

            secretDot.addEventListener('click', () => {
                secretDotClicks++;

                // Visual feedback
                secretDot.style.transform = 'scale(1.5)';
                secretDot.style.opacity = '0.8';
                setTimeout(() => {
                    secretDot.style.transform = 'scale(1)';
                    secretDot.style.opacity = '0.3';
                }, 150);

                // Reset click count after 3 seconds of inactivity
                clearTimeout(secretDotClickTimeout);
                secretDotClickTimeout = setTimeout(() => {
                    secretDotClicks = 0;
                    resetSecretDotAppearance();
                }, 3000);

                // Progressive visual changes
                if (secretDotClicks >= 2) {
                    secretDot.style.opacity = '0.5';
                    secretDot.className = secretDot.className.replace('bg-gray-400', 'bg-yellow-500');
                }
                if (secretDotClicks >= 4) {
                    secretDot.style.opacity = '0.7';
                    secretDot.className = secretDot.className.replace('bg-yellow-500', 'bg-green-500');
                }

                // After 5 clicks, open secret menu
                if (secretDotClicks >= REQUIRED_DOT_CLICKS) {
                    clearTimeout(secretDotClickTimeout);
                    secretDotClicks = 0;
                    resetSecretDotAppearance();
                    openSecretMenu();
                }
            });

            function resetSecretDotAppearance() {
                secretDot.style.opacity = '0.3';
                secretDot.className = secretDot.className.replace('bg-yellow-500', 'bg-gray-400').replace('bg-green-500', 'bg-gray-400');
            }
        }

        // Helper function to create mobile-responsive menu
        function createMobileMenu(id, title, position = 'right') {
            const menuPanel = document.createElement('div');
            menuPanel.id = id;
            menuPanel.className = `mobile-menu-panel ${position}`;

            const menuContent = document.createElement('div');
            menuContent.className = 'mobile-menu-content';

            menuContent.innerHTML = `
                <div class="mobile-menu-header">
                    <h3 class="text-lg font-bold text-purple-800">${title}</h3>
                    <button class="close-menu-btn text-gray-500 hover:text-gray-800 p-1 rounded-lg hover:bg-gray-100 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="mobile-menu-body">
                    <!-- Content will be added here -->
                </div>
                <div class="mobile-menu-footer">
                    <div class="text-xs text-gray-500 text-center">
                        <!-- Footer content will be added here -->
                    </div>
                </div>
            `;

            menuPanel.appendChild(menuContent);
            return { menuPanel, menuContent };
        }

        // Helper function to show mobile menu with animation
        function showMobileMenu(menuPanel) {
            document.body.appendChild(menuPanel);

            // Force reflow
            menuPanel.offsetHeight;

            // Show with animation
            const content = menuPanel.querySelector('.mobile-menu-content');
            content.classList.add('show');

            // Set up close handlers
            const closeBtn = menuPanel.querySelector('.close-menu-btn');
            closeBtn.addEventListener('click', () => closeMobileMenu(menuPanel));

            // Close on backdrop click (mobile only)
            if (window.innerWidth < 768) {
                menuPanel.addEventListener('click', (e) => {
                    if (e.target === menuPanel) {
                        closeMobileMenu(menuPanel);
                    }
                });
            } else {
                // Desktop: close on outside click
                setTimeout(() => {
                    document.addEventListener('click', function handleOutsideClick(e) {
                        if (!menuPanel.contains(e.target)) {
                            closeMobileMenu(menuPanel);
                            document.removeEventListener('click', handleOutsideClick);
                        }
                    });
                }, 100);
            }
        }

        // Helper function to close mobile menu with animation
        function closeMobileMenu(menuPanel) {
            const content = menuPanel.querySelector('.mobile-menu-content');
            content.classList.remove('show');

            setTimeout(() => {
                if (menuPanel.parentNode) {
                    document.body.removeChild(menuPanel);
                }
            }, 200);
        }

        // Open the secret menu
        function openSecretMenu() {
            console.log("Secret menu opened");

            // Mark that secret commands were used in this game
            secretCommandsUsed = true;

            // Update UI to show secret commands indicator
            updatePowerupInventoryDisplay();

            // Unlock secret finder achievement
            if (!achievements.secret_finder.unlocked) {
                achievements.secret_finder.unlocked = true;
                showAchievementNotification([achievements.secret_finder]);
                saveAchievements();
            }

            // Create the mobile-responsive secret menu
            const { menuPanel, menuContent } = createMobileMenu('secret-menu-panel', 'üîÆ Secret Menu', 'right');

            // Get the menu body to add content
            const menuBody = menuContent.querySelector('.mobile-menu-body');
            const menuFooter = menuContent.querySelector('.mobile-menu-footer div');

            // Create the menu content with new commands
            menuBody.innerHTML = `
                <div class="space-y-1">
                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-purple-500 to-indigo-600 text-white" data-command="GODMODE">
                        <div>
                            <div class="font-medium">üîÆ God Mode</div>
                            <div class="text-xs opacity-75">All words valid</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-blue-500 to-teal-400 text-white" data-command="ALLWORDS">
                        <div>
                            <div class="font-medium">üìñ Show All Words</div>
                            <div class="text-xs opacity-75">Cheat sheet</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-yellow-500 to-orange-500 text-white" data-command="EXTRATIME">
                        <div>
                            <div class="font-medium">‚è∞ Extra Time</div>
                            <div class="text-xs opacity-75">+30 seconds</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-green-500 to-emerald-500 text-white" data-command="BIGPOINTS">
                        <div>
                            <div class="font-medium">üíé Big Points</div>
                            <div class="text-xs opacity-75">5x scoring</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-blue-400 to-cyan-500 text-white" data-command="SLOWTIME">
                        <div>
                            <div class="font-medium">üêå Slow Time</div>
                            <div class="text-xs opacity-75">Half speed timer</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-amber-400 to-yellow-500 text-white" data-command="SHUFFLE">
                        <div>
                            <div class="font-medium">üîÄ Shuffle</div>
                            <div class="text-xs opacity-75">New letters</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-cyan-400 to-blue-500 text-white" data-command="FREEZE">
                        <div>
                            <div class="font-medium">‚ùÑÔ∏è Freeze Timer</div>
                            <div class="text-xs opacity-75">Stop the clock</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-emerald-400 to-teal-500 text-white" data-command="BOOST">
                        <div>
                            <div class="font-medium">üöÄ Score Boost</div>
                            <div class="text-xs opacity-75">+1000 points</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-violet-400 to-purple-500 text-white" data-command="HINT">
                        <div>
                            <div class="font-medium">üí° Show Hint</div>
                            <div class="text-xs opacity-75">Word suggestion</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-yellow-400 to-amber-500 text-white" data-command="LUCKY">
                        <div>
                            <div class="font-medium">üçÄ Lucky Grid</div>
                            <div class="text-xs opacity-75">Easy letters</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-rose-400 to-red-500 text-white" data-command="RESET">
                        <div>
                            <div class="font-medium">üîÑ Reset Score</div>
                            <div class="text-xs opacity-75">Back to zero</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-lime-400 to-green-500 text-white" data-command="DOUBLE">
                        <div>
                            <div class="font-medium">‚ú® Double Points</div>
                            <div class="text-xs opacity-75">2x scoring</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-amber-400 to-orange-400 text-white" data-command="REVEAL">
                        <div>
                            <div class="font-medium">üëÅÔ∏è Reveal Grid</div>
                            <div class="text-xs opacity-75">Highlight tiles</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-sky-400 to-blue-400 text-white" data-command="SPEED">
                        <div>
                            <div class="font-medium">‚ö° Speed Mode</div>
                            <div class="text-xs opacity-75">Fast animations</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-indigo-500 to-purple-600 text-white" data-command="INFINITE">
                        <div>
                            <div class="font-medium">‚ôæÔ∏è Infinite Time</div>
                            <div class="text-xs opacity-75">No timer limit</div>
                        </div>
                    </button>

                    <div class="border-t border-gray-300 my-3 pt-3">
                        <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-gray-600 to-gray-800 text-white font-bold" data-command="REMOVE_ALL_SECRET">
                            <div>
                                <div class="font-medium">üßπ Remove All Effects</div>
                                <div class="text-xs opacity-75">Clear all secret effects</div>
                            </div>
                        </button>
                    </div>

                    <div class="border-t border-red-300 my-3 pt-3">
                        <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-red-600 to-red-800 text-white" data-command="ENDGAME">
                            <div>
                                <div class="font-medium">üèÅ End Game</div>
                                <div class="text-xs opacity-75">Finish current game</div>
                            </div>
                        </button>
                    </div>
                </div>

                <div class="mt-4 text-xs text-gray-500 text-center border-t border-gray-200 pt-3">
                    üí° Type command names during gameplay
                </div>
            `;

            // Set footer content
            menuFooter.textContent = 'üéÆ Secret commands activated!';

            // Show the menu using the mobile-responsive system
            showMobileMenu(menuPanel);

            // Set up command buttons
            const commandButtons = menuPanel.querySelectorAll('.secret-command-btn');
            commandButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const command = button.getAttribute('data-command');
                    if (command && SECRET_COMMANDS[command]) {
                        SECRET_COMMANDS[command]();
                        showSecretCommandNotification(command);
                        closeMobileMenu(menuPanel);
                    }
                });
            });
        }

        // Close the secret menu (legacy function for compatibility)
        function closeSecretMenu() {
            const menuPanel = document.getElementById('secret-menu-panel');
            if (menuPanel) {
                closeMobileMenu(menuPanel);
            }
        }

        // Open the customize menu
        function openCustomizeMenu() {
            console.log("Customize menu opened");

            // Create the mobile-responsive customize menu
            const { menuPanel, menuContent } = createMobileMenu('customize-menu-panel', 'üé® Customize', 'left');

            // Get the menu body to add content
            const menuBody = menuContent.querySelector('.mobile-menu-body');
            const menuFooter = menuContent.querySelector('.mobile-menu-footer div');

            // Create the menu content
            menuBody.innerHTML = `
                <div class="space-y-1">
                    <h4 class="text-sm font-bold text-gray-700 mb-2">‚ú® Visual Effects</h4>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-red-500 to-pink-500 text-white" data-effect="RAINBOW">
                        <div>
                            <div class="font-medium">üåà Rainbow Mode</div>
                            <div class="text-xs opacity-75">Colorful tiles</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-gray-700 to-gray-900 text-white" data-effect="DARKMODE">
                        <div>
                            <div class="font-medium">üåô Dark Mode</div>
                            <div class="text-xs opacity-75">Night theme</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-pink-400 to-purple-400 text-white" data-effect="CONFETTI">
                        <div>
                            <div class="font-medium">üéâ Confetti</div>
                            <div class="text-xs opacity-75">Celebration!</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-orange-400 to-red-400 text-white" data-effect="FLASH">
                        <div>
                            <div class="font-medium">‚ö° Flash Mode</div>
                            <div class="text-xs opacity-75">Disco lights!</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-indigo-400 to-purple-400 text-white" data-effect="ZOOM">
                        <div>
                            <div class="font-medium">üîç Zoom Grid</div>
                            <div class="text-xs opacity-75">Bigger tiles</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-teal-400 to-cyan-400 text-white" data-effect="SPIN">
                        <div>
                            <div class="font-medium">üåÄ Spin Grid</div>
                            <div class="text-xs opacity-75">360¬∞ rotation</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-emerald-400 to-green-400 text-white" data-effect="GLOW">
                        <div>
                            <div class="font-medium">‚ú® Glow Mode</div>
                            <div class="text-xs opacity-75">Glowing border</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-green-400 to-green-600 text-white" data-effect="MATRIX">
                        <div>
                            <div class="font-medium">üï∂Ô∏è Matrix Mode</div>
                            <div class="text-xs opacity-75">Enter the Matrix</div>
                        </div>
                    </button>

                    <div class="border-t border-gray-300 my-3 pt-3">
                        <h4 class="text-sm font-bold text-gray-700 mb-2">üé® Popular Effects</h4>

                        <div class="grid grid-cols-2 gap-2 mb-3">
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-pink-500 to-violet-500 text-white text-sm" data-effect="NEON">
                                <div class="text-center">
                                    <div class="font-medium">üí° Neon</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-blue-300 to-white text-gray-800 text-sm" data-effect="SNOW">
                                <div class="text-center">
                                    <div class="font-medium">‚ùÑÔ∏è Snow</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-red-500 to-orange-500 text-white text-sm" data-effect="FIRE">
                                <div class="text-center">
                                    <div class="font-medium">üî• Fire</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-purple-400 to-blue-400 text-white text-sm" data-effect="PULSE">
                                <div class="text-center">
                                    <div class="font-medium">üíì Pulse</div>
                                </div>
                            </button>
                        </div>
                    </div>

                    <div class="border-t border-gray-300 my-3 pt-3">
                        <h4 class="text-sm font-bold text-gray-700 mb-2">üåà Background Themes</h4>

                        <div class="grid grid-cols-2 gap-2 mb-3">
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-blue-400 to-blue-600 text-white text-sm" data-effect="BG_BLUE">
                                <div class="text-center">
                                    <div class="font-medium">üîµ Blue</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-purple-400 to-purple-600 text-white text-sm" data-effect="BG_PURPLE">
                                <div class="text-center">
                                    <div class="font-medium">üü£ Purple</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-green-400 to-green-600 text-white text-sm" data-effect="BG_GREEN">
                                <div class="text-center">
                                    <div class="font-medium">üü¢ Green</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-orange-400 to-pink-500 text-white text-sm" data-effect="BG_SUNSET">
                                <div class="text-center">
                                    <div class="font-medium">üåÖ Sunset</div>
                                </div>
                            </button>
                        </div>
                    </div>

                    <div class="border-t border-yellow-300 my-3 pt-3">
                        <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-yellow-500 to-orange-500 text-white font-bold" data-effect="ACHIEVEMENTS">
                            <div>
                                <div class="font-medium">üèÜ Achievements</div>
                                <div class="text-xs opacity-75">View your progress</div>
                            </div>
                        </button>
                    </div>

                    <div class="border-t border-red-300 my-3 pt-3">
                        <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-red-600 to-red-800 text-white font-bold" data-effect="REMOVE_ALL_CUSTOMIZE">
                            <div>
                                <div class="font-medium">üßπ Remove All Effects</div>
                                <div class="text-xs opacity-75">Clear all customizations</div>
                            </div>
                        </button>
                    </div>
                </div>

                <div class="mt-4 text-xs text-gray-500 text-center border-t border-gray-200 pt-3">
                    üé® Click effects to toggle ‚Ä¢ Mix and match!
                </div>
            `;

            // Set footer content
            menuFooter.textContent = '‚ú® Customize your experience!';

            // Show the menu using the mobile-responsive system
            showMobileMenu(menuPanel);

            // Set up effect buttons
            const effectButtons = menuPanel.querySelectorAll('.customize-effect-btn');
            effectButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const effect = button.getAttribute('data-effect');
                    if (effect && CUSTOMIZE_EFFECTS[effect]) {
                        CUSTOMIZE_EFFECTS[effect]();
                        showCustomizeNotification(effect);

                        // Track customize effects for achievements
                        if (!effect.startsWith('BG_') && effect !== 'REMOVE_ALL_CUSTOMIZE' && effect !== 'ACHIEVEMENTS') {
                            customizeEffectsUsed.add(effect);
                            checkAchievements(['customize']);
                        }
                    }
                });
            });
        }

        // Close the customize menu (legacy function for compatibility)
        function closeCustomizeMenu() {
            const menuPanel = document.getElementById('customize-menu-panel');
            if (menuPanel) {
                closeMobileMenu(menuPanel);
            }
        }

        // Show customize notification
        function showCustomizeNotification(effect) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 left-4 bg-purple-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transform -translate-x-full transition-transform duration-300';
            notification.innerHTML = `
                <div class="flex items-center">
                    <span class="text-lg mr-2">üé®</span>
                    <div>
                        <div class="font-bold">Effect Applied!</div>
                        <div class="text-sm">${effect}</div>
                    </div>
                </div>
            `;

            document.body.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.classList.remove('-translate-x-full');
            }, 100);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.classList.add('-translate-x-full');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // New secret commands
        function enableSlowTimeMode() {
            slowTimeEnabled = !slowTimeEnabled;
            console.log(`Slow Time Mode ${slowTimeEnabled ? 'enabled' : 'disabled'}`);
            
            if (slowTimeEnabled) {
                // Slow down the timer in timed mode
                if (currentGameMode === GAME_MODE.TIMED) {
                    clearInterval(timerInterval);
                    timerInterval = setInterval(() => {
                        // Only decrease timer every other second
                        if (Math.floor(Date.now() / 1000) % 2 === 0) {
                            timer--;
                            updateTimerDisplay();
                            
                            if (timer <= 0) {
                                endGame();
                            }
                        }
                    }, 1000);
                    
                    // Add visual indicator
                    const timerEl = document.getElementById('timer-display');
                    if (timerEl) {
                        timerEl.classList.add('text-blue-400', 'animate-pulse');
                    }
                }
            } else {
                // Restore normal timer
                if (currentGameMode === GAME_MODE.TIMED) {
                    clearInterval(timerInterval);
                    startTimer();
                    
                    // Remove visual indicator
                    const timerEl = document.getElementById('timer-display');
                    if (timerEl) {
                        timerEl.classList.remove('text-blue-400', 'animate-pulse');
                    }
                }
            }
        }

        function toggleDarkMode() {
            darkModeEnabled = !darkModeEnabled;
            console.log(`Dark Mode ${darkModeEnabled ? 'enabled' : 'disabled'}`);
            
            const gameContainer = document.getElementById('game-container');
            const body = document.body;
            
            if (darkModeEnabled) {
                // Enable dark mode
                body.classList.add('bg-gray-900');
                
                // Update UI elements
                document.querySelectorAll('.bg-white').forEach(el => {
                    el.classList.remove('bg-white');
                    el.classList.add('bg-gray-800', 'text-white');
                });
                
                document.querySelectorAll('.text-gray-800').forEach(el => {
                    el.classList.remove('text-gray-800');
                    el.classList.add('text-gray-200');
                });
                
                document.querySelectorAll('.text-gray-600').forEach(el => {
                    el.classList.remove('text-gray-600');
                    el.classList.add('text-gray-400');
                });
                
                // Update grid
                const gridContainer = document.getElementById('grid-container');
                if (gridContainer) {
                    gridContainer.classList.remove('bg-green-800/50');
                    gridContainer.classList.add('bg-blue-900/50');
                }
                
                // Add dark mode style
                if (!document.getElementById('dark-mode-style')) {
                    const style = document.createElement('style');
                    style.id = 'dark-mode-style';
                    style.textContent = `
                        .tile {
                            background-color: #2d3748 !important;
                            color: #e2e8f0 !important;
                            border-color: #4a5568 !important;
                        }
                        .tile.selected {
                            background-color: #4299e1 !important;
                        }
                        .tile.correct {
                            background-color: #38a169 !important;
                        }
                        .tile.incorrect {
                            background-color: #e53e3e !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                // Disable dark mode
                body.classList.remove('bg-gray-900');
                
                // Update UI elements
                document.querySelectorAll('.bg-gray-800').forEach(el => {
                    el.classList.remove('bg-gray-800', 'text-white');
                    el.classList.add('bg-white');
                });
                
                document.querySelectorAll('.text-gray-200').forEach(el => {
                    el.classList.remove('text-gray-200');
                    el.classList.add('text-gray-800');
                });
                
                document.querySelectorAll('.text-gray-400').forEach(el => {
                    el.classList.remove('text-gray-400');
                    el.classList.add('text-gray-600');
                });
                
                // Update grid
                const gridContainer = document.getElementById('grid-container');
                if (gridContainer) {
                    gridContainer.classList.remove('bg-blue-900/50');
                    gridContainer.classList.add('bg-green-800/50');
                }
                
                // Remove dark mode style
                const darkModeStyle = document.getElementById('dark-mode-style');
                if (darkModeStyle) {
                    darkModeStyle.remove();
                }
            }
        }

        function triggerConfetti() {
            console.log("Confetti triggered!");
            
            // Create confetti effect
            for (let i = 0; i < 100; i++) {
                createConfettiPiece();
            }
        }

        function createConfettiPiece() {
            const colors = ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#577590'];
            const confetti = document.createElement('div');
            
            // Random position, color, and rotation
            const left = Math.random() * 100;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const rotation = Math.random() * 360;
            const size = Math.random() * 10 + 5;
            
            confetti.style.cssText = `
                position: fixed;
                top: -20px;
                left: ${left}vw;
                width: ${size}px;
                height: ${size}px;
                background-color: ${color};
                transform: rotate(${rotation}deg);
                z-index: 1000;
                pointer-events: none;
            `;
            
            document.body.appendChild(confetti);
            
            // Animate falling
            const duration = Math.random() * 3000 + 2000;
            const keyframes = [
                { transform: `translateY(0) rotate(${rotation}deg)`, opacity: 1 },
                { transform: `translateY(${window.innerHeight + 100}px) rotate(${rotation + 360}deg)`, opacity: 0 }
            ];
            
            const animation = confetti.animate(keyframes, {
                duration: duration,
                easing: 'cubic-bezier(0.1, 0.8, 0.3, 1)',
                fill: 'forwards'
            });
            
            animation.onfinish = () => {
                confetti.remove();
            };
        }

        function shuffleGrid() {
            console.log("Grid shuffled!");
            
            // Animate the shuffle
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                // Add shake animation
                tile.classList.add('animate-shake');
                
                // Remove animation after it completes
                setTimeout(() => {
                    tile.classList.remove('animate-shake');
                }, 500);
            });
            
            // Regenerate the grid after animation
            setTimeout(() => {
                generateGrid();
                renderGrid();
            }, 500);
            
            // Add shake animation CSS if it doesn't exist
            if (!document.getElementById('shake-animation')) {
                const style = document.createElement('style');
                style.id = 'shake-animation';
                style.textContent = `
                    @keyframes shake {
                        0% { transform: translate(0, 0) rotate(0deg); }
                        20% { transform: translate(-5px, 0) rotate(-5deg); }
                        40% { transform: translate(5px, 0) rotate(5deg); }
                        60% { transform: translate(-3px, 0) rotate(-3deg); }
                        80% { transform: translate(3px, 0) rotate(3deg); }
                        100% { transform: translate(0, 0) rotate(0deg); }
                    }
                    .animate-shake {
                        animation: shake 0.5s ease-in-out;
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function enableMatrixMode() {
            matrixModeEnabled = !matrixModeEnabled;
            console.log(`Matrix Mode ${matrixModeEnabled ? 'enabled' : 'disabled'}`);
            
            if (matrixModeEnabled) {
                // Create matrix background
                const canvas = document.createElement('canvas');
                canvas.id = 'matrix-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: -1;
                `;
                document.body.appendChild(canvas);
                
                // Initialize matrix effect
                initMatrix(canvas);
                
                // Make game elements more visible
                document.querySelectorAll('.bg-white, .tile').forEach(el => {
                    el.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.5)';
                });
            } else {
                // Remove matrix background
                const canvas = document.getElementById('matrix-canvas');
                if (canvas) {
                    canvas.remove();
                }
                
                // Remove box shadows
                document.querySelectorAll('.bg-white, .tile').forEach(el => {
                    el.style.boxShadow = '';
                });
            }
        }

        function initMatrix(canvas) {
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Matrix characters
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const fontSize = 14;
            const columns = canvas.width / fontSize;
            
            // Array to track the y position of each column
            const drops = [];
            for (let i = 0; i < columns; i++) {
                drops[i] = 1;
            }
            
            // Drawing the characters
            function draw() {
                // Black BG with opacity for the trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#0f0'; // Green text
                ctx.font = fontSize + 'px monospace';
                
                // Loop through drops
                for (let i = 0; i < drops.length; i++) {
                    // Random character
                    const text = chars.charAt(Math.floor(Math.random() * chars.length));
                    
                    // x = i * fontSize, y = drops[i] * fontSize
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    // Randomly reset some drops to the top
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    
                    // Increment y coordinate
                    drops[i]++;
                }
            }
            
            // Animation loop
            const matrixInterval = setInterval(draw, 33);
            
            // Store interval ID for cleanup
            canvas.matrixInterval = matrixInterval;
            
            // Resize handler
            window.addEventListener('resize', () => {
                if (matrixModeEnabled) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
            });
        }

        function endGameCommand() {
            console.log("End Game command activated");
            
            // Create a confirmation dialog
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50';
            overlay.innerHTML = `
                <div class="bg-white p-6 rounded-xl max-w-md w-11/12 text-center">
                    <h3 class="text-xl font-bold text-red-600 mb-3">‚ö†Ô∏è End Game?</h3>
                    <p class="mb-4">Are you sure you want to end the current game?</p>
                    <div class="flex space-x-3">
                        <button id="cancel-end-game" class="flex-1 py-2 px-4 bg-gray-200 hover:bg-gray-300 rounded-lg transition-colors">
                            Cancel
                        </button>
                        <button id="confirm-end-game" class="flex-1 py-2 px-4 bg-red-500 hover:bg-red-600 text-white rounded-lg transition-colors">
                            End Game
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Set up event listeners
            document.getElementById('cancel-end-game').addEventListener('click', () => {
                document.body.removeChild(overlay);
            });
            
            document.getElementById('confirm-end-game').addEventListener('click', () => {
                document.body.removeChild(overlay);
                // End the game with a slight delay for better UX
                setTimeout(() => {
                    endGame();
                }, 300);
            });
        }

        // New secret commands
        function freezeTimer() {
            if (currentGameMode === GAME_MODE.TIMED) {
                clearInterval(timerInterval);
                console.log("Timer frozen!");
            }
        }

        function scoreBoost() {
            score += 1000;
            scoreEl.textContent = score;
            console.log("Score boosted by 1000!");
        }

        function showHint() {
            const possibleWords = findAllPossibleWords();
            const unFoundWords = possibleWords.filter(word => !foundWords.has(word));

            if (unFoundWords.length === 0) {
                showHintPopup("üéâ Amazing!", "You've found all possible words!", "success");
                return;
            }

            const hint = unFoundWords[Math.floor(Math.random() * unFoundWords.length)];
            const points = calculatePoints(hint.length);
            showHintPopup("üí° Hint", `Try finding "${hint}" (${hint.length} letters, ${points} points)`, "hint");
        }

        function showHintPopup(title, message, type = "hint") {
            // Remove any existing hint popup
            const existingPopup = document.getElementById('hint-popup');
            if (existingPopup) {
                existingPopup.remove();
            }

            // Create the hint popup
            const popup = document.createElement('div');
            popup.id = 'hint-popup';
            popup.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 transition-all duration-300 scale-95 opacity-0';

            const bgColor = type === "success" ? "bg-green-500" : "bg-blue-500";
            const borderColor = type === "success" ? "border-green-300" : "border-blue-300";

            popup.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl border-2 ${borderColor} p-6 max-w-sm mx-4">
                    <div class="text-center">
                        <div class="w-16 h-16 ${bgColor} rounded-full flex items-center justify-center mx-auto mb-4">
                            <span class="text-2xl text-white">${type === "success" ? "üéâ" : "üí°"}</span>
                        </div>
                        <h3 class="text-xl font-bold text-gray-800 mb-2">${title}</h3>
                        <p class="text-gray-600 mb-4">${message}</p>
                        <button id="close-hint-popup" class="px-6 py-2 ${bgColor} text-white rounded-lg hover:opacity-90 transition-all font-medium">
                            Got it!
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(popup);

            // Animate in
            setTimeout(() => {
                popup.classList.remove('scale-95', 'opacity-0');
                popup.classList.add('scale-100', 'opacity-100');
            }, 10);

            // Set up close button
            popup.querySelector('#close-hint-popup').addEventListener('click', () => {
                closeHintPopup();
            });

            // Auto-close after 5 seconds
            setTimeout(() => {
                closeHintPopup();
            }, 5000);

            // Close when clicking outside
            popup.addEventListener('click', (e) => {
                if (e.target === popup) {
                    closeHintPopup();
                }
            });
        }

        function closeHintPopup() {
            const popup = document.getElementById('hint-popup');
            if (!popup) return;

            popup.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.remove();
                }
            }, 300);
        }

        function luckyGrid() {
            // Replace grid with vowel-heavy letters for easier words
            const luckyLetters = "AEIOURSTLNAEIOURSTN";
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    grid[i][j] = luckyLetters[Math.floor(Math.random() * luckyLetters.length)];
                }
            }
            renderGrid();
            console.log("Lucky grid generated!");
        }

        function resetScore() {
            score = 0;
            foundWords.clear();
            scoreEl.textContent = score;
            wordCountEl.textContent = foundWords.size;
            console.log("Score reset!");
        }

        function flashMode() {
            document.body.style.animation = 'flash 0.5s ease-in-out 3';
            setTimeout(() => document.body.style.animation = '', 1500);
        }

        function zoomMode() {
            const grid = document.getElementById('grid-container');
            grid.style.transform = grid.style.transform === 'scale(1.2)' ? 'scale(1)' : 'scale(1.2)';
            grid.style.transition = 'transform 0.3s ease';
        }

        function spinGrid() {
            const grid = document.getElementById('grid-container');
            grid.style.transform = 'rotate(360deg)';
            grid.style.transition = 'transform 1s ease';
            setTimeout(() => {
                grid.style.transform = 'rotate(0deg)';
            }, 1000);
        }

        function doublePoints() {
            if (!window.originalCalculatePoints) {
                window.originalCalculatePoints = calculatePoints;
                calculatePoints = (length) => window.originalCalculatePoints(length) * 2;
                console.log("Double points activated!");
            } else {
                calculatePoints = window.originalCalculatePoints;
                window.originalCalculatePoints = null;
                console.log("Double points deactivated!");
            }
        }

        function revealWord() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.style.backgroundColor = '#fbbf24';
                tile.style.color = '#000';
            });
            setTimeout(() => {
                tiles.forEach(tile => {
                    tile.style.backgroundColor = '';
                    tile.style.color = '';
                });
            }, 2000);
        }

        function shakeGrid() {
            const grid = document.getElementById('grid-container');
            grid.style.animation = 'shake 0.5s ease-in-out';
            setTimeout(() => grid.style.animation = '', 500);
        }

        function glowMode() {
            const grid = document.getElementById('grid-container');
            grid.style.boxShadow = grid.style.boxShadow ? '' : '0 0 20px #4ade80, 0 0 40px #4ade80';
            grid.style.transition = 'box-shadow 0.3s ease';
        }

        function speedMode() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.style.transition = 'all 0.05s ease';
            });
            setTimeout(() => {
                tiles.forEach(tile => {
                    tile.style.transition = '';
                });
            }, 10000);
        }

        function magicGrid() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    tile.style.transform = 'scale(1.2) rotate(180deg)';
                    setTimeout(() => {
                        tile.style.transform = '';
                    }, 300);
                }, i * 50);
            });
        }

        // New customize effects
        function neonMode() {
            const grid = document.getElementById('grid-container');
            const isNeon = grid.classList.contains('neon-mode');

            if (!isNeon) {
                grid.classList.add('neon-mode');
                if (!document.getElementById('neon-style')) {
                    const style = document.createElement('style');
                    style.id = 'neon-style';
                    style.textContent = `
                        .neon-mode .tile {
                            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff) !important;
                            box-shadow: 0 0 10px #ff006e, 0 0 20px #8338ec, 0 0 30px #3a86ff !important;
                            color: white !important;
                            text-shadow: 0 0 5px white !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                grid.classList.remove('neon-mode');
            }
        }

        function retroMode() {
            const body = document.body;
            const isRetro = body.classList.contains('retro-mode');

            if (!isRetro) {
                body.classList.add('retro-mode');
                if (!document.getElementById('retro-style')) {
                    const style = document.createElement('style');
                    style.id = 'retro-style';
                    style.textContent = `
                        .retro-mode {
                            background: linear-gradient(45deg, #ff9a9e, #fecfef, #fecfef, #ff9a9e) !important;
                            font-family: 'Courier New', monospace !important;
                        }
                        .retro-mode .tile {
                            background: #ff6b6b !important;
                            border: 2px solid #4ecdc4 !important;
                            color: white !important;
                            font-weight: bold !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                body.classList.remove('retro-mode');
            }
        }

        function snowEffect() {
            if (document.getElementById('snow-container')) {
                document.getElementById('snow-container').remove();
                return;
            }

            const snowContainer = document.createElement('div');
            snowContainer.id = 'snow-container';
            snowContainer.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                pointer-events: none; z-index: 1000;
            `;
            document.body.appendChild(snowContainer);

            for (let i = 0; i < 50; i++) {
                createSnowflake(snowContainer);
            }
        }

        function createSnowflake(container) {
            const snowflake = document.createElement('div');
            snowflake.innerHTML = '‚ùÑÔ∏è';
            snowflake.style.cssText = `
                position: absolute; top: -20px; font-size: ${Math.random() * 20 + 10}px;
                left: ${Math.random() * 100}%; animation: fall ${Math.random() * 3 + 2}s linear infinite;
            `;

            if (!document.getElementById('snow-animation')) {
                const style = document.createElement('style');
                style.id = 'snow-animation';
                style.textContent = `
                    @keyframes fall {
                        to { transform: translateY(100vh) rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }

            container.appendChild(snowflake);
            setTimeout(() => snowflake.remove(), 5000);
        }

        function fireEffect() {
            const grid = document.getElementById('grid-container');
            const isFire = grid.classList.contains('fire-mode');

            if (!isFire) {
                grid.classList.add('fire-mode');
                if (!document.getElementById('fire-style')) {
                    const style = document.createElement('style');
                    style.id = 'fire-style';
                    style.textContent = `
                        .fire-mode {
                            background: radial-gradient(circle, #ff4500, #ff6347, #ff0000) !important;
                        }
                        .fire-mode .tile {
                            background: linear-gradient(45deg, #ff4500, #ff6347) !important;
                            animation: flicker 0.5s ease-in-out infinite alternate !important;
                        }
                        @keyframes flicker {
                            0% { box-shadow: 0 0 5px #ff4500; }
                            100% { box-shadow: 0 0 20px #ff0000, 0 0 30px #ff4500; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                grid.classList.remove('fire-mode');
            }
        }

        function bubbleMode() {
            if (document.getElementById('bubble-container')) {
                document.getElementById('bubble-container').remove();
                return;
            }

            const bubbleContainer = document.createElement('div');
            bubbleContainer.id = 'bubble-container';
            bubbleContainer.style.cssText = `
                position: fixed; bottom: 0; left: 0; width: 100%; height: 100%;
                pointer-events: none; z-index: 999;
            `;
            document.body.appendChild(bubbleContainer);

            setInterval(() => createBubble(bubbleContainer), 300);
        }

        function createBubble(container) {
            const bubble = document.createElement('div');
            const size = Math.random() * 30 + 10;
            bubble.style.cssText = `
                position: absolute; bottom: -50px; left: ${Math.random() * 100}%;
                width: ${size}px; height: ${size}px; border-radius: 50%;
                background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(0,150,255,0.3));
                animation: float ${Math.random() * 4 + 3}s ease-in-out;
            `;

            if (!document.getElementById('bubble-animation')) {
                const style = document.createElement('style');
                style.id = 'bubble-animation';
                style.textContent = `
                    @keyframes float {
                        to { transform: translateY(-100vh) translateX(${Math.random() * 100 - 50}px); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }

            container.appendChild(bubble);
            setTimeout(() => bubble.remove(), 7000);
        }

        function pulseMode() {
            const tiles = document.querySelectorAll('.tile');
            const isPulsing = tiles[0]?.classList.contains('pulse-mode');

            if (!isPulsing) {
                tiles.forEach(tile => tile.classList.add('pulse-mode'));
                if (!document.getElementById('pulse-style')) {
                    const style = document.createElement('style');
                    style.id = 'pulse-style';
                    style.textContent = `
                        .pulse-mode {
                            animation: pulse 2s ease-in-out infinite !important;
                        }
                        @keyframes pulse {
                            0%, 100% { transform: scale(1); }
                            50% { transform: scale(1.05); }
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                tiles.forEach(tile => tile.classList.remove('pulse-mode'));
            }
        }

        function gradientMode() {
            const grid = document.getElementById('grid-container');
            const isGradient = grid.classList.contains('gradient-mode');

            if (!isGradient) {
                grid.classList.add('gradient-mode');
                if (!document.getElementById('gradient-style')) {
                    const style = document.createElement('style');
                    style.id = 'gradient-style';
                    style.textContent = `
                        .gradient-mode .tile {
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
                            color: white !important;
                        }
                        .gradient-mode .tile:nth-child(even) {
                            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%) !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                grid.classList.remove('gradient-mode');
            }
        }

        function mirrorMode() {
            const grid = document.getElementById('grid-container');
            const isMirrored = grid.style.transform.includes('scaleX(-1)');

            if (!isMirrored) {
                grid.style.transform = (grid.style.transform || '') + ' scaleX(-1)';
            } else {
                grid.style.transform = grid.style.transform.replace('scaleX(-1)', '').trim();
            }
        }

        function waveEffect() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    tile.style.transform = 'translateY(-10px)';
                    setTimeout(() => {
                        tile.style.transform = '';
                    }, 200);
                }, i * 100);
            });
        }

        // Background customization functions
        function setBlueBackground() {
            document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('blue');
            backgroundsUsed.add('blue');
            sessionBackgrounds.add('blue');
        }

        function setPurpleBackground() {
            document.body.style.background = 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('purple');
            backgroundsUsed.add('purple');
            sessionBackgrounds.add('purple');
        }

        function setGreenBackground() {
            document.body.style.background = 'linear-gradient(135deg, #d299c2 0%, #fef9d7 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('green');
            backgroundsUsed.add('green');
            sessionBackgrounds.add('green');
        }

        function setSunsetBackground() {
            document.body.style.background = 'linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('sunset');
        }

        function setOceanBackground() {
            document.body.style.background = 'linear-gradient(135deg, #667db6 0%, #0082c8 25%, #0082c8 50%, #667db6 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('ocean');
        }

        function setForestBackground() {
            document.body.style.background = 'linear-gradient(135deg, #134e5e 0%, #71b280 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('forest');
        }

        function setSpaceBackground() {
            document.body.style.background = 'linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('space');

            // Add stars effect
            if (!document.getElementById('stars-container')) {
                const starsContainer = document.createElement('div');
                starsContainer.id = 'stars-container';
                starsContainer.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    pointer-events: none; z-index: -1;
                `;

                // Create stars
                for (let i = 0; i < 100; i++) {
                    const star = document.createElement('div');
                    star.style.cssText = `
                        position: absolute; width: 2px; height: 2px; background: white;
                        border-radius: 50%; top: ${Math.random() * 100}%; left: ${Math.random() * 100}%;
                        animation: twinkle ${Math.random() * 3 + 1}s ease-in-out infinite alternate;
                    `;
                    starsContainer.appendChild(star);
                }

                // Add twinkle animation
                if (!document.getElementById('twinkle-animation')) {
                    const style = document.createElement('style');
                    style.id = 'twinkle-animation';
                    style.textContent = `
                        @keyframes twinkle {
                            0% { opacity: 0.3; }
                            100% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(starsContainer);
            }
        }

        function setRainbowBackground() {
            document.body.style.background = 'linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)';
            document.body.style.backgroundSize = '400% 400%';
            document.body.style.backgroundAttachment = 'fixed';
            document.body.style.animation = 'rainbow-shift 8s ease infinite';
            updateTileTheme('rainbow');

            if (!document.getElementById('rainbow-animation')) {
                const style = document.createElement('style');
                style.id = 'rainbow-animation';
                style.textContent = `
                    @keyframes rainbow-shift {
                        0% { background-position: 0% 50%; }
                        50% { background-position: 100% 50%; }
                        100% { background-position: 0% 50%; }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function setDotsPattern() {
            document.body.style.background = `
                radial-gradient(circle at 25% 25%, #ffffff 2px, transparent 2px),
                radial-gradient(circle at 75% 75%, #ffffff 2px, transparent 2px),
                linear-gradient(135deg, #667eea 0%, #764ba2 100%)
            `;
            document.body.style.backgroundSize = '50px 50px, 50px 50px, 100% 100%';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('dots');
        }

        function setStripesPattern() {
            document.body.style.background = `
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 10px,
                    rgba(255,255,255,0.1) 10px,
                    rgba(255,255,255,0.1) 20px
                ),
                linear-gradient(135deg, #667eea 0%, #764ba2 100%)
            `;
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('stripes');
        }

        function setWavesPattern() {
            document.body.style.background = `
                linear-gradient(135deg, #667eea 0%, #764ba2 100%)
            `;
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('waves');

            // Add animated wave overlay
            if (!document.getElementById('waves-overlay')) {
                const wavesOverlay = document.createElement('div');
                wavesOverlay.id = 'waves-overlay';
                wavesOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    pointer-events: none; z-index: -1; opacity: 0.3;
                    background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.1'%3E%3Cpath d='M30 30c0-11.046-8.954-20-20-20s-20 8.954-20 20 8.954 20 20 20 20-8.954 20-20zm0 0c0 11.046 8.954 20 20 20s20-8.954 20-20-8.954-20-20-20-20 8.954-20 20z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
                    animation: wave-move 20s ease-in-out infinite;
                `;

                if (!document.getElementById('wave-animation')) {
                    const style = document.createElement('style');
                    style.id = 'wave-animation';
                    style.textContent = `
                        @keyframes wave-move {
                            0%, 100% { transform: translateX(0) translateY(0); }
                            25% { transform: translateX(-20px) translateY(-10px); }
                            50% { transform: translateX(20px) translateY(10px); }
                            75% { transform: translateX(-10px) translateY(20px); }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(wavesOverlay);
            }
        }

        function resetBackground() {
            // Remove all custom backgrounds and effects
            document.body.style.background = '';
            document.body.style.backgroundSize = '';
            document.body.style.backgroundAttachment = '';
            document.body.style.animation = '';

            // Remove special effect containers
            const starsContainer = document.getElementById('stars-container');
            if (starsContainer) starsContainer.remove();

            const wavesOverlay = document.getElementById('waves-overlay');
            if (wavesOverlay) wavesOverlay.remove();

            // Reset to original gradient
            document.body.className = 'flex items-center justify-center min-h-screen';
            document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            updateTileTheme('default');
        }

        // Function to update tile themes based on background
        function updateTileTheme(theme) {
            // Remove existing theme styles
            const existingStyle = document.getElementById('tile-theme-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            // Create new theme style
            const style = document.createElement('style');
            style.id = 'tile-theme-style';

            let tileStyles = '';

            switch(theme) {
                case 'blue':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%) !important;
                            border-color: #2196f3 !important;
                            color: #1565c0 !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'purple':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%) !important;
                            border-color: #9c27b0 !important;
                            color: #6a1b9a !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'green':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%) !important;
                            border-color: #4caf50 !important;
                            color: #2e7d32 !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'sunset':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #fff3e0 0%, #ffcc80 100%) !important;
                            border-color: #ff9800 !important;
                            color: #e65100 !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'ocean':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #e0f2f1 0%, #80cbc4 100%) !important;
                            border-color: #00796b !important;
                            color: #004d40 !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #00796b 0%, #00695c 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'forest':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #e8f5e8 0%, #a5d6a7 100%) !important;
                            border-color: #388e3c !important;
                            color: #1b5e20 !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #388e3c 0%, #2e7d32 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'space':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #263238 0%, #37474f 100%) !important;
                            border-color: #607d8b !important;
                            color: #eceff1 !important;
                            box-shadow: 0 0 10px rgba(96, 125, 139, 0.3) !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #607d8b 0%, #455a64 100%) !important;
                            color: white !important;
                            box-shadow: 0 0 15px rgba(96, 125, 139, 0.6) !important;
                        }
                    `;
                    break;
                case 'rainbow':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(45deg, #ff9a9e 0%, #fecfef 25%, #fecfef 50%, #ff9a9e 100%) !important;
                            border-color: #ff6b6b !important;
                            color: #d63031 !important;
                            animation: rainbow-tile 3s ease-in-out infinite !important;
                        }
                        .tile.selected {
                            background: linear-gradient(45deg, #ff6b6b 0%, #ee5a6f 100%) !important;
                            color: white !important;
                        }
                        @keyframes rainbow-tile {
                            0%, 100% { filter: hue-rotate(0deg); }
                            50% { filter: hue-rotate(180deg); }
                        }
                    `;
                    break;
                case 'dots':
                case 'stripes':
                case 'waves':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%) !important;
                            border-color: #6c757d !important;
                            color: #495057 !important;
                            backdrop-filter: blur(5px) !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #6c757d 0%, #495057 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                default:
                    tileStyles = `
                        .tile {
                            background-color: #f4e4bc !important;
                            border-color: #d4b896 !important;
                            color: #5d4037 !important;
                        }
                        .tile.selected {
                            background-color: #4ade80 !important;
                            color: white !important;
                            border-color: #22c55e !important;
                        }
                    `;
                    break;
            }

            style.textContent = tileStyles;
            document.head.appendChild(style);
        }

        // New secret command functions
        function infiniteTime() {
            if (currentGameMode === GAME_MODE.TIMED) {
                clearInterval(timerInterval);
                timer = 999999;
                updateTimerDisplay();
                console.log("Infinite time activated!");
            }
        }

        function vowelGrid() {
            const vowels = "AEIOUAEIOUAEIOU";
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    grid[i][j] = vowels[Math.floor(Math.random() * vowels.length)];
                }
            }
            renderGrid();
            console.log("Vowel grid activated!");
        }

        function megaPoints() {
            if (!window.originalCalculatePoints) {
                window.originalCalculatePoints = calculatePoints;
                calculatePoints = (length) => window.originalCalculatePoints(length) * 10;
                console.log("Mega points (10x) activated!");
                showCustomizeNotification("Mega Points ON - 10x scoring!");
            } else {
                calculatePoints = window.originalCalculatePoints;
                window.originalCalculatePoints = null;
                console.log("Mega points deactivated!");
                showCustomizeNotification("Mega Points OFF - Normal scoring restored");
            }
        }

        function ghostMode() {
            const tiles = document.querySelectorAll('.tile');
            const isGhost = tiles[0]?.style.opacity === '0.3';

            tiles.forEach(tile => {
                tile.style.opacity = isGhost ? '1' : '0.3';
                tile.style.transition = 'opacity 0.5s ease';
            });

            if (isGhost) {
                console.log("Ghost mode deactivated!");
                showCustomizeNotification("Ghost Mode OFF - Tiles visible");
            } else {
                console.log("Ghost mode activated!");
                showCustomizeNotification("Ghost Mode ON - Tiles transparent");
            }
        }

        function matrixRain() {
            if (document.getElementById('matrix-rain')) {
                document.getElementById('matrix-rain').remove();
                matrixModeActive = false;
                return;
            }

            matrixModeActive = true;

            const matrixContainer = document.createElement('div');
            matrixContainer.id = 'matrix-rain';
            matrixContainer.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                pointer-events: none; z-index: 1000; overflow: hidden;
            `;

            for (let i = 0; i < 20; i++) {
                const column = document.createElement('div');
                column.style.cssText = `
                    position: absolute; top: -100px; left: ${i * 5}%;
                    color: #00ff00; font-family: monospace; font-size: 14px;
                    animation: matrix-fall ${Math.random() * 3 + 2}s linear infinite;
                `;
                column.textContent = '01010101010101010101';
                matrixContainer.appendChild(column);
            }

            if (!document.getElementById('matrix-animation')) {
                const style = document.createElement('style');
                style.id = 'matrix-animation';
                style.textContent = `
                    @keyframes matrix-fall {
                        to { transform: translateY(100vh); }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(matrixContainer);
            setTimeout(() => matrixContainer.remove(), 10000);
        }

        function teleportTiles() {
            const tiles = document.querySelectorAll('.tile');
            const positions = Array.from(tiles).map(tile => ({
                top: tile.style.top,
                left: tile.style.left,
                transform: tile.style.transform
            }));

            tiles.forEach((tile, i) => {
                const randomIndex = Math.floor(Math.random() * positions.length);
                tile.style.transition = 'all 0.5s ease';
                tile.style.transform = 'scale(0)';

                setTimeout(() => {
                    tile.style.transform = 'scale(1) rotate(360deg)';
                }, 250);
            });

            setTimeout(() => {
                tiles.forEach(tile => {
                    tile.style.transform = '';
                    tile.style.transition = '';
                });
            }, 1000);
        }

        function quantumGrid() {
            const tiles = document.querySelectorAll('.tile');

            // Check if quantum is already active
            if (window.quantumInterval) {
                clearInterval(window.quantumInterval);
                window.quantumInterval = null;
                tiles.forEach(tile => {
                    tile.style.opacity = '1';
                });
                console.log("Quantum grid deactivated!");
                showCustomizeNotification("Quantum Grid OFF - Stable tiles");
                return;
            }

            // Start quantum mode
            window.quantumInterval = setInterval(() => {
                tiles.forEach(tile => {
                    tile.style.opacity = Math.random() > 0.5 ? '1' : '0.3';
                });
            }, 500);

            console.log("Quantum grid activated!");
            showCustomizeNotification("Quantum Grid ON - Phasing tiles");
        }

        function laserMode() {
            const grid = document.getElementById('grid-container');
            grid.style.boxShadow = '0 0 50px #ff0000, inset 0 0 50px #ff0000';
            grid.style.border = '2px solid #ff0000';

            setTimeout(() => {
                grid.style.boxShadow = '';
                grid.style.border = '';
            }, 5000);
        }

        function portalEffect() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    tile.style.transform = 'rotateY(180deg) scale(0.8)';
                    tile.style.background = 'radial-gradient(circle, #8b5cf6, #3b82f6)';

                    setTimeout(() => {
                        tile.style.transform = '';
                        tile.style.background = '';
                    }, 1000);
                }, i * 100);
            });
        }

        function chaosMode() {
            const effects = [shuffleGrid, spinGrid, shakeGrid, flashMode, revealWord];
            const randomEffect = effects[Math.floor(Math.random() * effects.length)];
            randomEffect();

            setTimeout(() => {
                const anotherEffect = effects[Math.floor(Math.random() * effects.length)];
                anotherEffect();
            }, 1000);

            console.log("Chaos mode activated!");
        }

        // New customize effect functions
        function discoMode() {
            const tiles = document.querySelectorAll('.tile');
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];

            // Check if disco is already active
            if (window.discoInterval) {
                clearInterval(window.discoInterval);
                window.discoInterval = null;
                tiles.forEach(tile => {
                    tile.style.backgroundColor = '';
                    tile.style.color = '';
                });
                console.log("Disco mode deactivated!");
                return;
            }

            // Start disco mode
            window.discoInterval = setInterval(() => {
                tiles.forEach(tile => {
                    tile.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    tile.style.color = 'white';
                });
            }, 200);

            console.log("Disco mode activated! Click again to stop.");
        }

        function hologramEffect() {
            const grid = document.getElementById('grid-container');
            const isHologram = grid.classList.contains('hologram-mode');

            if (!isHologram) {
                grid.classList.add('hologram-mode');
                if (!document.getElementById('hologram-style')) {
                    const style = document.createElement('style');
                    style.id = 'hologram-style';
                    style.textContent = `
                        .hologram-mode {
                            background: linear-gradient(45deg, transparent 30%, rgba(0,255,255,0.3) 50%, transparent 70%) !important;
                            animation: hologram-scan 2s ease-in-out infinite !important;
                        }
                        .hologram-mode .tile {
                            background: rgba(0,255,255,0.1) !important;
                            border: 1px solid #00ffff !important;
                            color: #00ffff !important;
                            text-shadow: 0 0 10px #00ffff !important;
                        }
                        @keyframes hologram-scan {
                            0%, 100% { filter: hue-rotate(0deg) brightness(1); }
                            50% { filter: hue-rotate(180deg) brightness(1.2); }
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                grid.classList.remove('hologram-mode');
            }
        }

        function cyberpunkTheme() {
            const body = document.body;
            const isCyberpunk = body.classList.contains('cyberpunk-mode');

            if (!isCyberpunk) {
                body.classList.add('cyberpunk-mode');
                if (!document.getElementById('cyberpunk-style')) {
                    const style = document.createElement('style');
                    style.id = 'cyberpunk-style';
                    style.textContent = `
                        .cyberpunk-mode {
                            background: linear-gradient(135deg, #0a0a0a 0%, #1a0033 50%, #000000 100%) !important;
                        }
                        .cyberpunk-mode .tile {
                            background: linear-gradient(45deg, #ff00ff, #00ffff) !important;
                            border: 2px solid #ff00ff !important;
                            color: #000000 !important;
                            font-weight: bold !important;
                            text-shadow: 0 0 5px #ffffff !important;
                            box-shadow: 0 0 15px #ff00ff !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                body.classList.remove('cyberpunk-mode');
            }
        }

        function vintageFilter() {
            const body = document.body;
            const isVintage = body.classList.contains('vintage-mode');

            if (!isVintage) {
                body.classList.add('vintage-mode');
                if (!document.getElementById('vintage-style')) {
                    const style = document.createElement('style');
                    style.id = 'vintage-style';
                    style.textContent = `
                        .vintage-mode {
                            filter: sepia(0.8) contrast(1.2) brightness(0.9) !important;
                            background: linear-gradient(135deg, #8b7355 0%, #d2b48c 100%) !important;
                        }
                        .vintage-mode .tile {
                            background: #f5deb3 !important;
                            border: 2px solid #8b4513 !important;
                            color: #654321 !important;
                            font-family: 'Times New Roman', serif !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                body.classList.remove('vintage-mode');
            }
        }

        function glitchEffect() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    tile.style.animation = 'glitch 0.3s ease-in-out';
                    tile.style.filter = 'hue-rotate(180deg) contrast(2)';

                    setTimeout(() => {
                        tile.style.animation = '';
                        tile.style.filter = '';
                    }, 300);
                }, i * 50);
            });

            if (!document.getElementById('glitch-animation')) {
                const style = document.createElement('style');
                style.id = 'glitch-animation';
                style.textContent = `
                    @keyframes glitch {
                        0%, 100% { transform: translateX(0); }
                        20% { transform: translateX(-2px) skew(-5deg); }
                        40% { transform: translateX(2px) skew(5deg); }
                        60% { transform: translateX(-1px) skew(-2deg); }
                        80% { transform: translateX(1px) skew(2deg); }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function auroraEffect() {
            const body = document.body;
            const isAurora = body.classList.contains('aurora-mode');

            if (!isAurora) {
                body.classList.add('aurora-mode');
                if (!document.getElementById('aurora-style')) {
                    const style = document.createElement('style');
                    style.id = 'aurora-style';
                    style.textContent = `
                        .aurora-mode {
                            background: linear-gradient(45deg, #001122, #003366, #004488, #0066aa) !important;
                            background-size: 400% 400% !important;
                            animation: aurora-shift 8s ease infinite !important;
                        }
                        .aurora-mode .tile {
                            background: rgba(0,255,150,0.2) !important;
                            border: 1px solid #00ff96 !important;
                            color: #ffffff !important;
                            box-shadow: 0 0 20px rgba(0,255,150,0.3) !important;
                        }
                        @keyframes aurora-shift {
                            0%, 100% { background-position: 0% 50%; }
                            50% { background-position: 100% 50%; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                body.classList.remove('aurora-mode');
            }
        }

        function crystalTheme() {
            const tiles = document.querySelectorAll('.tile');
            const isCrystal = tiles[0]?.classList.contains('crystal-mode');

            if (!isCrystal) {
                tiles.forEach(tile => tile.classList.add('crystal-mode'));
                if (!document.getElementById('crystal-style')) {
                    const style = document.createElement('style');
                    style.id = 'crystal-style';
                    style.textContent = `
                        .crystal-mode {
                            background: linear-gradient(135deg, #e8f4fd 0%, #b3d9ff 50%, #e8f4fd 100%) !important;
                            border: 2px solid #4da6ff !important;
                            color: #0066cc !important;
                            box-shadow: 0 0 20px rgba(77,166,255,0.5), inset 0 0 20px rgba(255,255,255,0.3) !important;
                            transform: perspective(100px) rotateX(10deg) !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                tiles.forEach(tile => tile.classList.remove('crystal-mode'));
            }
        }

        function lavaEffect() {
            const grid = document.getElementById('grid-container');
            const isLava = grid.classList.contains('lava-mode');

            if (!isLava) {
                grid.classList.add('lava-mode');
                if (!document.getElementById('lava-style')) {
                    const style = document.createElement('style');
                    style.id = 'lava-style';
                    style.textContent = `
                        .lava-mode {
                            background: radial-gradient(circle, #ff4500, #ff6347, #ff0000) !important;
                            animation: lava-bubble 3s ease-in-out infinite !important;
                        }
                        .lava-mode .tile {
                            background: linear-gradient(45deg, #ff4500, #ff6347) !important;
                            border: 2px solid #ff0000 !important;
                            color: #ffffff !important;
                            animation: lava-glow 2s ease-in-out infinite alternate !important;
                        }
                        @keyframes lava-bubble {
                            0%, 100% { transform: scale(1); }
                            50% { transform: scale(1.02); }
                        }
                        @keyframes lava-glow {
                            0% { box-shadow: 0 0 10px #ff4500; }
                            100% { box-shadow: 0 0 30px #ff0000; }
                        }
                    `;
                    document.head.appendChild(style);
                }
                console.log("Lava effect activated!");
            } else {
                grid.classList.remove('lava-mode');
                console.log("Lava effect deactivated!");
            }
        }

        function electricEffect() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    tile.style.boxShadow = '0 0 20px #ffff00, 0 0 40px #ffff00';
                    tile.style.backgroundColor = '#ffff00';
                    tile.style.color = '#000000';

                    setTimeout(() => {
                        tile.style.boxShadow = '';
                        tile.style.backgroundColor = '';
                        tile.style.color = '';
                    }, 200);
                }, Math.random() * 1000);
            });
        }

        function cosmicTheme() {
            const body = document.body;
            const isCosmic = body.classList.contains('cosmic-mode');

            if (!isCosmic) {
                body.classList.add('cosmic-mode');
                if (!document.getElementById('cosmic-style')) {
                    const style = document.createElement('style');
                    style.id = 'cosmic-style';
                    style.textContent = `
                        .cosmic-mode {
                            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%) !important;
                        }
                        .cosmic-mode .tile {
                            background: linear-gradient(45deg, #4a00e0, #8e2de2) !important;
                            border: 1px solid #a8edea !important;
                            color: #ffffff !important;
                            box-shadow: 0 0 15px rgba(168,237,234,0.5) !important;
                            animation: cosmic-float 4s ease-in-out infinite !important;
                        }
                        @keyframes cosmic-float {
                            0%, 100% { transform: translateY(0px); }
                            50% { transform: translateY(-5px); }
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                body.classList.remove('cosmic-mode');
            }
        }

        // Remove all effects functions
        function removeAllSecretEffects() {
            // Reset all secret command effects

            // Reset god mode
            if (window.originalCheckWord) {
                checkWord = window.originalCheckWord;
                window.originalCheckWord = null;
                godModeEnabled = false;
            }

            // Reset points multipliers
            if (window.originalCalculatePoints) {
                calculatePoints = window.originalCalculatePoints;
                window.originalCalculatePoints = null;
                bigPointsModeEnabled = false;
            }

            // Reset timer effects
            if (currentGameMode === GAME_MODE.TIMED && !slowTimeEnabled) {
                clearInterval(timerInterval);
                startTimer();
            }
            slowTimeEnabled = false;

            // Reset tile effects
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.style.opacity = '';
                tile.style.transition = '';
                tile.style.transform = '';
                tile.style.animation = '';
                tile.style.filter = '';
                tile.style.backgroundColor = '';
                tile.style.color = '';
                tile.style.boxShadow = '';
            });

            // Reset grid effects
            const grid = document.getElementById('grid-container');
            if (grid) {
                grid.style.boxShadow = '';
                grid.style.border = '';
                grid.style.animation = '';
                grid.style.transform = '';
            }

            // Remove special effect containers
            const matrixRain = document.getElementById('matrix-rain');
            if (matrixRain) matrixRain.remove();

            // Clear any intervals
            clearInterval(window.discoInterval);
            clearInterval(window.quantumInterval);

            console.log("All secret effects removed!");
        }

        function removeAllCustomizeEffects() {
            // Remove all customize effect classes and styles
            const body = document.body;
            const grid = document.getElementById('grid-container');
            const tiles = document.querySelectorAll('.tile');

            // Remove body classes
            body.classList.remove(
                'retro-mode', 'cyberpunk-mode', 'vintage-mode',
                'aurora-mode', 'cosmic-mode'
            );

            // Remove grid classes
            if (grid) {
                grid.classList.remove(
                    'neon-mode', 'hologram-mode', 'fire-mode',
                    'lava-mode', 'gradient-mode'
                );
                grid.style.boxShadow = '';
                grid.style.animation = '';
                grid.style.transform = '';
                grid.style.filter = '';
            }

            // Remove tile classes
            tiles.forEach(tile => {
                tile.classList.remove(
                    'pulse-mode', 'crystal-mode'
                );
                tile.style.animation = '';
                tile.style.transform = '';
                tile.style.filter = '';
                tile.style.backgroundColor = '';
                tile.style.color = '';
                tile.style.boxShadow = '';
                tile.style.border = '';
                tile.style.textShadow = '';
                tile.style.fontFamily = '';
                tile.style.transition = '';
            });

            // Remove special effect containers
            const effectContainers = [
                'snow-container', 'bubble-container', 'stars-container',
                'waves-overlay', 'matrix-rain'
            ];
            effectContainers.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.remove();
            });

            // Remove dynamic styles
            const dynamicStyles = [
                'neon-style', 'retro-style', 'snow-animation', 'bubble-animation',
                'fire-style', 'pulse-style', 'gradient-style', 'hologram-style',
                'cyberpunk-style', 'vintage-style', 'glitch-animation', 'aurora-style',
                'crystal-style', 'lava-style', 'cosmic-style', 'twinkle-animation',
                'rainbow-animation', 'wave-animation', 'matrix-animation'
            ];
            dynamicStyles.forEach(id => {
                const style = document.getElementById(id);
                if (style) style.remove();
            });

            // Clear intervals
            clearInterval(window.discoInterval);
            clearInterval(window.bubbleInterval);

            // Reset background to default
            resetBackground();

            console.log("All customize effects removed!");
        }

        // Achievement system functions
        function loadAchievements() {
            const saved = localStorage.getItem('wordHuntAchievements');
            if (saved) {
                const savedAchievements = JSON.parse(saved);
                Object.keys(savedAchievements).forEach(key => {
                    if (achievements[key]) {
                        achievements[key].unlocked = savedAchievements[key].unlocked;
                    }
                });
            }

            const savedStats = localStorage.getItem('wordHuntStats');
            if (savedStats) {
                const stats = JSON.parse(savedStats);
                gamesPlayed = stats.gamesPlayed || 0;
                totalScore = stats.totalScore || 0;
                bestScore = stats.bestScore || 0;
                totalWordsFound = stats.totalWordsFound || 0;
                customizeEffectsUsed = new Set(stats.customizeEffectsUsed || []);
            }
        }

        function saveAchievements() {
            // Debounce saving to prevent excessive localStorage writes
            if (window.saveTimeout) {
                clearTimeout(window.saveTimeout);
            }

            window.saveTimeout = setTimeout(() => {
                try {
                    localStorage.setItem('wordHuntAchievements', JSON.stringify(achievements));
                    localStorage.setItem('wordHuntStats', JSON.stringify({
                        gamesPlayed,
                        totalScore,
                        bestScore,
                        totalWordsFound,
                        customizeEffectsUsed: Array.from(customizeEffectsUsed)
                    }));
                } catch (error) {
                    console.warn('Failed to save achievements:', error);
                }
            }, 500);
        }

        function checkAchievements(specificTypes = null) {
            // Debounce achievement checking to prevent excessive calls
            if (window.achievementCheckTimeout) {
                clearTimeout(window.achievementCheckTimeout);
            }

            window.achievementCheckTimeout = setTimeout(() => {
                const newUnlocks = [];

                Object.keys(achievements).forEach(key => {
                    const achievement = achievements[key];
                    if (!achievement.unlocked) {
                        // Skip checking if specific types are provided and this isn't one of them
                        if (specificTypes && !specificTypes.includes(achievement.type)) {
                            return;
                        }

                        let shouldUnlock = false;

                        switch (achievement.type) {
                            case 'games':
                                shouldUnlock = gamesPlayed >= achievement.requirement;
                                break;
                            case 'score':
                                shouldUnlock = score >= achievement.requirement;
                                break;
                            case 'words_single':
                                shouldUnlock = foundWords.size >= achievement.requirement;
                                break;
                            case 'words_total':
                                shouldUnlock = totalWordsFound >= achievement.requirement;
                                break;
                            case 'perfect':
                                // Only check perfect game at game end to avoid performance issues
                                if (specificTypes && specificTypes.includes('perfect')) {
                                    const allWords = findAllPossibleWords();
                                    shouldUnlock = foundWords.size === allWords.length && allWords.length > 0;
                                }
                                break;
                            case 'speed':
                                shouldUnlock = wordsFoundInTime >= achievement.requirement;
                                break;
                            case 'word_length':
                                shouldUnlock = Array.from(foundWords).some(word => word.length >= achievement.requirement);
                                break;
                            case 'customize':
                                shouldUnlock = customizeEffectsUsed.size >= achievement.requirement;
                                break;
                            case 'backgrounds':
                                shouldUnlock = backgroundsUsed.size >= achievement.requirement;
                                break;
                            case 'total_score':
                                shouldUnlock = totalScore >= achievement.requirement;
                                break;
                            case 'daily_streak':
                                shouldUnlock = consecutiveDays >= achievement.requirement;
                                break;
                            case 'combo':
                                shouldUnlock = currentStreak >= achievement.requirement;
                                break;
                            case 'exact_score':
                                shouldUnlock = score === achievement.requirement;
                                break;
                            case 'speed_burst':
                                // Check if 3 words found in under 10 seconds
                                shouldUnlock = wordsFoundInTime >= achievement.requirement && (Date.now() - gameStartTime) < 10000;
                                break;
                            case 'efficiency':
                                // Score 2000+ with under 15 words
                                shouldUnlock = score >= 2000 && foundWords.size < 15;
                                break;
                            case 'word_variety':
                                // Find words of every length 3-10+
                                const lengths = Array.from(foundWords).map(w => w.length);
                                const uniqueLengths = new Set(lengths);
                                shouldUnlock = uniqueLengths.size >= achievement.requirement;
                                break;
                            case 'perfect_accuracy':
                                shouldUnlock = invalidWordCount === 0 && foundWords.size > 0;
                                break;
                            case 'quick_start':
                                shouldUnlock = firstWordTime > 0 && firstWordTime < 5000;
                                break;
                            case 'endurance':
                                shouldUnlock = currentGameMode === GAME_MODE.TIMED && timer <= 0;
                                break;
                            case 'time':
                                const currentHour = new Date().getHours();
                                if (key === 'night_owl') {
                                    shouldUnlock = currentHour >= 0 && currentHour < 6;
                                } else if (key === 'early_bird') {
                                    shouldUnlock = currentHour >= 0 && currentHour < 6;
                                }
                                break;
                            case 'palindrome':
                                shouldUnlock = Array.from(foundWords).some(word =>
                                    word.toLowerCase() === word.toLowerCase().split('').reverse().join('')
                                );
                                break;
                            case 'vowel_word':
                                shouldUnlock = Array.from(foundWords).some(word => {
                                    const vowels = ['a', 'e', 'i', 'o', 'u'];
                                    return vowels.every(vowel => word.toLowerCase().includes(vowel));
                                });
                                break;
                            case 'no_vowel_word':
                                shouldUnlock = Array.from(foundWords).some(word => {
                                    const vowels = ['a', 'e', 'i', 'o', 'u'];
                                    return !vowels.some(vowel => word.toLowerCase().includes(vowel)) && word.length >= 3;
                                });
                                break;
                            case 'matrix_play':
                                shouldUnlock = matrixModeActive && foundWords.size > 0;
                                break;
                        }

                        if (shouldUnlock) {
                            achievement.unlocked = true;
                            newUnlocks.push(achievement);
                        }
                    }
                });

                if (newUnlocks.length > 0) {
                    showAchievementNotification(newUnlocks);
                    saveAchievements();
                }
            }, 100); // Small delay to batch multiple checks
        }

        function showAchievementNotification(achievements) {
            // Use requestAnimationFrame for better performance
            achievements.forEach((achievement, index) => {
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        const notification = document.createElement('div');
                        notification.className = 'fixed top-4 left-1/2 bg-gradient-to-r from-yellow-400 to-orange-500 text-white px-4 py-3 rounded-lg shadow-lg z-50';
                        notification.style.transform = 'translate(-50%, -20px)';
                        notification.style.opacity = '0';
                        notification.style.transition = 'all 0.3s ease-out';

                        notification.innerHTML = `
                            <div class="flex items-center space-x-2">
                                <div class="text-xl">${achievement.icon}</div>
                                <div>
                                    <div class="font-bold text-sm">Achievement Unlocked!</div>
                                    <div class="text-xs">${achievement.name}</div>
                                </div>
                            </div>
                        `;

                        document.body.appendChild(notification);

                        // Animate in
                        requestAnimationFrame(() => {
                            notification.style.transform = 'translate(-50%, 0)';
                            notification.style.opacity = '1';
                        });

                        // Remove after 3 seconds
                        setTimeout(() => {
                            notification.style.transform = 'translate(-50%, -20px)';
                            notification.style.opacity = '0';
                            setTimeout(() => {
                                if (notification.parentNode) {
                                    notification.remove();
                                }
                            }, 300);
                        }, 3000);
                    });
                }, index * 500); // Reduced stagger time
            });
        }

        function getAchievementProgress(achievement) {
            let current = 0;
            let required = achievement.requirement;

            switch (achievement.type) {
                case 'games':
                    current = gamesPlayed;
                    break;
                case 'score':
                    current = bestScore;
                    break;
                case 'words_single':
                    current = foundWords ? foundWords.size : 0;
                    break;
                case 'words_total':
                    current = totalWordsFound;
                    break;
                case 'customize':
                    current = customizeEffectsUsed.size;
                    break;
                case 'backgrounds':
                    current = backgroundsUsed.size;
                    break;
                case 'total_score':
                    current = totalScore;
                    break;
                case 'daily_streak':
                    current = consecutiveDays;
                    break;
                case 'speed':
                    current = wordsFoundInTime;
                    break;
                case 'word_length':
                    current = foundWords ? Math.max(...Array.from(foundWords).map(w => w.length), 0) : 0;
                    break;
                case 'combo':
                    current = currentStreak;
                    break;
                case 'exact_score':
                    current = score === achievement.requirement ? 1 : 0;
                    required = 1;
                    break;
                case 'perfect':
                case 'secret':
                case 'time':
                case 'palindrome':
                case 'vowel_word':
                case 'no_vowel_word':
                case 'matrix_play':
                case 'weekend':
                case 'holiday':
                case 'exact_time':
                case 'duplicate_words':
                case 'alphabet_variety':
                case 'reverse_word':
                case 'theme_session':
                case 'alphabetical':
                case 'multi_effects':
                case 'minimalist':
                case 'maximalist':
                case 'full_grid':
                case 'corners':
                case 'center_tile':
                case 'edge_only':
                case 'zigzag':
                case 'mode_variety':
                case 'grid_variety':
                case 'easter_word':
                case 'speed_burst':
                case 'efficiency':
                case 'word_variety':
                case 'perfect_accuracy':
                case 'quick_start':
                case 'endurance':
                    current = achievement.unlocked ? 1 : 0;
                    required = 1;
                    break;
                default:
                    current = 0;
            }

            // Cap current at required to avoid >100%
            current = Math.min(current, required);
            const percent = Math.round((current / required) * 100);

            return { current, required, percent };
        }

        function openAchievementsMenu() {
            const unlockedCount = Object.values(achievements).filter(a => a.unlocked).length;
            const totalCount = Object.keys(achievements).length;
            const completionPercent = Math.round((unlockedCount / totalCount) * 100);

            // Create the mobile-responsive achievements menu
            const { menuPanel, menuContent } = createMobileMenu('achievements-menu-panel', 'üèÜ Achievements', 'right');

            // Get the menu body to add content
            const menuBody = menuContent.querySelector('.mobile-menu-body');
            const menuFooter = menuContent.querySelector('.mobile-menu-footer div');

            // Simple category grouping
            const categories = {
                'long-term': { name: 'Long-term', icon: 'üìà', achievements: [] },
                'skill': { name: 'Skill', icon: 'üéØ', achievements: [] },
                'hidden': { name: 'Hidden', icon: 'üîç', achievements: [] }
            };

            Object.entries(achievements).forEach(([key, achievement]) => {
                const category = achievement.category || 'skill';
                if (categories[category]) {
                    categories[category].achievements.push({ key, ...achievement });
                }
            });

            let currentCategory = 'long-term';

            // Create mobile-friendly achievements content
            menuBody.innerHTML = `
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-sm font-bold text-gray-700">Progress Overview</h4>
                        <span class="text-xs text-gray-500">${unlockedCount}/${totalCount} (${completionPercent}%)</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded h-2">
                        <div class="bg-yellow-500 h-2 rounded transition-all duration-300" style="width: ${completionPercent}%"></div>
                    </div>
                </div>

                <div class="mb-4">
                    <h4 class="text-sm font-bold text-gray-700 mb-2">Categories</h4>
                    <div class="flex border border-gray-200 rounded-lg overflow-hidden">
                        ${Object.keys(categories).map(key => `
                            <button class="flex-1 py-2 px-2 text-xs font-medium category-tab ${key === currentCategory ? 'bg-blue-100 text-blue-700' : 'text-gray-500 hover:text-gray-700 hover:bg-gray-50'}" data-category="${key}">
                                <div class="text-center">
                                    <div>${categories[key].icon}</div>
                                    <div class="text-xs">${categories[key].name}</div>
                                </div>
                            </button>
                        `).join('')}
                    </div>
                </div>

                <div id="category-content">
                    <!-- Content will be populated by renderCategory -->
                </div>
            `;

            function renderCategory(categoryKey) {
                const category = categories[categoryKey];
                const categoryUnlocked = category.achievements.filter(a => a.unlocked).length;
                const categoryPercent = category.achievements.length > 0 ? Math.round((categoryUnlocked / category.achievements.length) * 100) : 0;

                return `
                    <div>
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="font-bold text-sm">${category.icon} ${category.name}</h4>
                            <span class="text-xs text-gray-500">${categoryUnlocked}/${category.achievements.length}</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded h-1 mb-3">
                            <div class="bg-blue-500 h-1 rounded transition-all duration-300" style="width: ${categoryPercent}%"></div>
                        </div>
                        <div class="space-y-2">
                            ${category.achievements.map(achievement => {
                                const progress = getAchievementProgress(achievement);
                                return `
                                    <div class="flex items-center space-x-3 p-3 rounded-lg border ${achievement.unlocked ? 'bg-green-50 border-green-200' : 'bg-gray-50 border-gray-200'}">
                                        <div class="text-lg ${achievement.unlocked ? '' : 'grayscale opacity-50'}">${achievement.icon}</div>
                                        <div class="flex-1 min-w-0">
                                            <div class="font-medium text-sm ${achievement.unlocked ? 'text-green-700' : 'text-gray-700'}">${achievement.name}</div>
                                            <div class="text-xs text-gray-500 mt-1">${achievement.description}</div>
                                            ${achievement.unlocked ?
                                                '<div class="text-xs text-green-600 font-medium mt-1">‚úì Unlocked</div>' :
                                                `<div class="text-xs text-gray-400 mt-1">${progress.current}/${progress.required} (${progress.percent}%)</div>`
                                            }
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Set initial content
            menuContent.querySelector('#category-content').innerHTML = renderCategory(currentCategory);

            // Set footer content
            menuFooter.innerHTML = `Games: ${gamesPlayed} | Best: ${bestScore} | Words: ${totalWordsFound}`;

            // Show the menu using the mobile-responsive system
            showMobileMenu(menuPanel);

            // Add event listeners for category tabs
            menuPanel.querySelectorAll('.category-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const category = tab.dataset.category;
                    currentCategory = category;

                    // Update active tab
                    menuPanel.querySelectorAll('.category-tab').forEach(t => {
                        t.className = 'flex-1 py-2 px-2 text-xs font-medium category-tab text-gray-500 hover:text-gray-700 hover:bg-gray-50';
                    });
                    tab.className = 'flex-1 py-2 px-2 text-xs font-medium category-tab bg-blue-100 text-blue-700';

                    // Update content
                    menuPanel.querySelector('#category-content').innerHTML = renderCategory(category);
                });
            });
        }









        // Power-ups Functions
        function loadPowerupInventory() {
            try {
                const saved = localStorage.getItem(POWERUPS_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    powerupInventory = new Map(parsed);
                }
            } catch (error) {
                console.error('Error loading power-up inventory:', error);
            }
        }

        function savePowerupInventory() {
            try {
                localStorage.setItem(POWERUPS_KEY, JSON.stringify(Array.from(powerupInventory.entries())));
            } catch (error) {
                console.error('Error saving power-up inventory:', error);
            }
        }

        function spawnPowerup() {
            // Disable power-ups for Daily Challenge mode
            if (isDailyChallenge) {
                return; // No power-ups in competitive modes
            }

            // Check if we should spawn a power-up
            const totalChance = Object.values(POWERUP_SPAWN_RATES).reduce((sum, rate) => sum + rate, 0);
            const roll = Math.random() * 100;

            if (roll > totalChance) return; // No power-up spawned

            // Determine rarity
            let rarity = 'common';
            let cumulativeChance = 0;

            for (const [rarityLevel, chance] of Object.entries(POWERUP_SPAWN_RATES)) {
                cumulativeChance += chance;
                if (roll <= cumulativeChance) {
                    rarity = rarityLevel;
                    break;
                }
            }

            // Get power-ups of this rarity
            const powerupsOfRarity = Object.values(POWERUP_TYPES).filter(p => p.rarity === rarity);
            if (powerupsOfRarity.length === 0) return;

            // Select random power-up
            const selectedPowerup = powerupsOfRarity[Math.floor(Math.random() * powerupsOfRarity.length)];

            // Find empty position on grid
            const emptyPositions = [];
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const posKey = `${row}-${col}`;
                    if (!powerupSpawns.has(posKey)) {
                        emptyPositions.push({row, col, key: posKey});
                    }
                }
            }

            if (emptyPositions.length === 0) return; // No empty positions

            // Place power-up
            const position = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
            powerupSpawns.set(position.key, selectedPowerup);

            // Add visual indicator to grid tile
            addPowerupToGrid(position.row, position.col, selectedPowerup);

            console.log(`Spawned ${selectedPowerup.name} at ${position.row},${position.col}`);
        }

        function addPowerupToGrid(row, col, powerup) {
            const tile = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (!tile) return;

            // Create power-up indicator
            const powerupIndicator = document.createElement('div');
            powerupIndicator.className = 'absolute top-0 right-0 w-4 h-4 rounded-full flex items-center justify-center text-xs transform translate-x-1 -translate-y-1 animate-pulse';
            powerupIndicator.classList.add(powerup.color);
            powerupIndicator.textContent = powerup.icon;
            powerupIndicator.style.fontSize = '10px';
            powerupIndicator.setAttribute('data-powerup', powerup.id);

            // Make tile position relative if not already
            tile.style.position = 'relative';
            tile.appendChild(powerupIndicator);
        }

        function collectPowerup(row, col) {
            const posKey = `${row}-${col}`;
            const powerup = powerupSpawns.get(posKey);

            if (!powerup) return false;

            // Add to inventory
            const currentCount = powerupInventory.get(powerup.id) || 0;
            powerupInventory.set(powerup.id, currentCount + 1);
            savePowerupInventory();

            // Track power-up collection achievements
            const totalCollected = Array.from(powerupInventory.values()).reduce((sum, count) => sum + count, 0);

            // Check collection achievements
            if (!achievements.power_collector.unlocked && totalCollected >= 1) {
                achievements.power_collector.unlocked = true;
                showAchievementNotification([achievements.power_collector]);
            }

            if (!achievements.power_hoarder.unlocked && totalCollected >= 10) {
                achievements.power_hoarder.unlocked = true;
                showAchievementNotification([achievements.power_hoarder]);
            }

            // Check rarity achievements
            if (!achievements.lucky_finder.unlocked && powerup.rarity === 'epic') {
                achievements.lucky_finder.unlocked = true;
                showAchievementNotification([achievements.lucky_finder]);
            }

            saveAchievements();

            // Remove from spawns
            powerupSpawns.delete(posKey);

            // Remove visual indicator
            const tile = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (tile) {
                const indicator = tile.querySelector('[data-powerup]');
                if (indicator) {
                    indicator.remove();
                }
            }

            // Show collection modal
            showPowerupCollectionModal(powerup);

            // Update inventory display
            updatePowerupInventoryDisplay();

            return true;
        }

        function showPowerupCollectionModal(powerup) {
            const modal = document.getElementById('powerup-collection-modal');

            document.getElementById('collected-powerup-icon').textContent = powerup.icon;
            document.getElementById('collected-powerup-name').textContent = powerup.name;
            document.getElementById('collected-powerup-description').textContent = powerup.description;

            const totalCount = Array.from(powerupInventory.values()).reduce((sum, count) => sum + count, 0);
            document.getElementById('powerup-inventory-count').textContent = totalCount;

            modal.classList.remove('hidden');
            setTimeout(() => {
                const content = modal.querySelector('div');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);

            // Auto-close after 3 seconds
            setTimeout(() => {
                closePowerupCollectionModal();
            }, 3000);
        }

        function closePowerupCollectionModal() {
            const modal = document.getElementById('powerup-collection-modal');
            const content = modal.querySelector('div');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        function updatePowerupInventoryDisplay() {
            const container = document.getElementById('powerups-inventory');
            const panel = document.getElementById('powerups-panel');
            const competitiveIndicator = document.getElementById('competitive-mode-indicator');
            const secretIndicator = document.getElementById('secret-commands-indicator');

            // Hide power-ups panel and show competitive indicator for Daily Challenge mode
            if (isDailyChallenge) {
                if (panel) {
                    panel.style.display = 'none';
                }
                if (competitiveIndicator) {
                    competitiveIndicator.classList.remove('hidden');
                    competitiveIndicator.querySelector('.font-mono').textContent = 'üèÜ Daily Challenge';
                }
                if (secretIndicator) {
                    secretIndicator.classList.add('hidden');
                }
                return;
            } else {
                if (panel) {
                    panel.style.display = 'block';
                }
                if (competitiveIndicator) {
                    competitiveIndicator.classList.add('hidden');
                }
            }

            // Show secret commands indicator if secret commands were used
            if (secretIndicator) {
                if (secretCommandsUsed) {
                    secretIndicator.classList.remove('hidden');
                } else {
                    secretIndicator.classList.add('hidden');
                }
            }

            container.innerHTML = '';

            // Show only power-ups that the player has
            const availablePowerups = Object.values(POWERUP_TYPES).filter(powerup => {
                const count = powerupInventory.get(powerup.id) || 0;
                return count > 0;
            });

            if (availablePowerups.length === 0) {
                // Show a compact message when no power-ups available
                const emptyEl = document.createElement('div');
                emptyEl.className = 'text-xs text-white/60 font-mono';
                emptyEl.textContent = 'none';
                container.appendChild(emptyEl);
                return;
            }

            // Show available power-ups in compact format matching timer style
            availablePowerups.forEach(powerup => {
                const count = powerupInventory.get(powerup.id) || 0;

                const powerupEl = document.createElement('div');
                powerupEl.className = 'relative bg-white/20 hover:bg-white/30 rounded-full w-6 h-6 cursor-pointer transition-all flex items-center justify-center text-xs';
                powerupEl.innerHTML = `
                    ${powerup.icon}
                    ${count > 1 ? `<div class="absolute -top-1 -right-1 w-3 h-3 bg-yellow-400 text-black text-xs rounded-full flex items-center justify-center font-bold" style="font-size: 8px;">${count}</div>` : ''}
                `;

                powerupEl.addEventListener('click', () => usePowerup(powerup.id));
                powerupEl.title = `${powerup.name}: ${powerup.description} (${count} available)`;

                container.appendChild(powerupEl);
            });
        }

        function usePowerup(powerupId) {
            // Disable power-up usage for Daily Challenge mode
            if (isDailyChallenge) {
                return; // No power-up usage in competitive modes
            }

            const count = powerupInventory.get(powerupId) || 0;
            if (count <= 0) return;

            const powerup = POWERUP_TYPES[powerupId.toUpperCase()];
            if (!powerup) return;

            // Consume power-up
            powerupInventory.set(powerup.id, count - 1);
            savePowerupInventory();

            // Apply effect
            applyPowerupEffect(powerup);

            // Track power-up usage achievements
            if (!achievements.time_master.unlocked && powerup.id === 'time_freeze') {
                achievements.time_master.unlocked = true;
                showAchievementNotification([achievements.time_master]);
                saveAchievements();
            }

            if (!achievements.multiplier_madness.unlocked && (powerup.id === 'point_multiplier' || powerup.id === 'mega_multiplier')) {
                achievements.multiplier_madness.unlocked = true;
                showAchievementNotification([achievements.multiplier_madness]);
                saveAchievements();
            }

            // Check for power combo achievement
            if (!achievements.power_combo.unlocked && activePowerups.size >= 3) {
                achievements.power_combo.unlocked = true;
                showAchievementNotification([achievements.power_combo]);
                saveAchievements();
            }

            // Update display
            updatePowerupInventoryDisplay();

            // Show usage feedback
            showPowerupUsageEffect(powerup);
        }

        function applyPowerupEffect(powerup) {
            switch (powerup.id) {
                case 'time_freeze':
                    activatePowerup('timeFreeze', powerup.duration);
                    powerupEffects.timeFreeze = true;
                    break;

                case 'word_hint':
                    showWordHint();
                    break;

                case 'letter_shuffle':
                    shuffleGridLetters();
                    break;

                case 'point_multiplier':
                    activatePowerup('pointMultiplier', powerup.duration, powerup.multiplier);
                    powerupEffects.pointMultiplier = powerup.multiplier;
                    break;

                case 'mega_multiplier':
                    activatePowerup('pointMultiplier', powerup.duration, powerup.multiplier);
                    powerupEffects.pointMultiplier = powerup.multiplier;
                    break;

                case 'extra_time':
                    if (currentGameMode === GAME_MODE.TIMED || isDailyChallenge) {
                        timer += powerup.timeBonus;
                        updateTimerDisplay();
                    }
                    break;

                case 'word_magnet':
                    activatePowerup('wordMagnet', powerup.duration);
                    powerupEffects.wordMagnet = true;
                    highlightLongWords();
                    break;

                case 'lucky_grid':
                    generateLuckyGrid();
                    break;
            }
        }

        function activatePowerup(effectName, duration, value = true) {
            const endTime = Date.now() + duration;
            activePowerups.set(effectName, {endTime, value});

            // Set up automatic deactivation
            setTimeout(() => {
                deactivatePowerup(effectName);
            }, duration);
        }

        function deactivatePowerup(effectName) {
            activePowerups.delete(effectName);

            switch (effectName) {
                case 'timeFreeze':
                    powerupEffects.timeFreeze = false;
                    break;
                case 'pointMultiplier':
                    powerupEffects.pointMultiplier = 1;
                    break;
                case 'wordMagnet':
                    powerupEffects.wordMagnet = false;
                    removeWordHighlights();
                    break;
            }
        }

        function showWordHint() {
            const possibleWords = findAllPossibleWords();
            if (possibleWords.length === 0) return;

            // Filter out already found words
            const unfoundWords = possibleWords.filter(word => !foundWords.has(word));
            if (unfoundWords.length === 0) return;

            // Select a random unfound word
            const hintWord = unfoundWords[Math.floor(Math.random() * unfoundWords.length)];

            // Show hint
            const hintEl = document.createElement('div');
            hintEl.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-yellow-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 animate-pulse';
            hintEl.innerHTML = `
                <div class="text-center">
                    <div class="text-lg font-bold">üí° Word Hint</div>
                    <div class="text-xl font-mono">${hintWord}</div>
                </div>
            `;

            document.body.appendChild(hintEl);

            setTimeout(() => {
                document.body.removeChild(hintEl);
            }, 3000);
        }

        function shuffleGridLetters() {
            // Preserve found words by not shuffling their paths
            const newGrid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                newGrid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    const randomIndex = Math.floor(Math.random() * LETTER_DISTRIBUTION.length);
                    newGrid[i][j] = LETTER_DISTRIBUTION[randomIndex];
                }
            }

            grid = newGrid;
            renderGrid();

            // Show shuffle effect
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.classList.add('animate-spin');
                setTimeout(() => {
                    tile.classList.remove('animate-spin');
                }, 500);
            });
        }

        function highlightLongWords() {
            const possibleWords = findAllPossibleWords();
            const longWords = possibleWords.filter(word => word.length >= 6);

            // This would highlight tiles that form long words
            // Implementation would depend on word path finding
            console.log('Highlighting long words:', longWords);
        }

        function removeWordHighlights() {
            // Remove any word highlighting effects
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.classList.remove('ring-2', 'ring-pink-400');
            });
        }

        function generateLuckyGrid() {
            // Generate a grid with high-value letters
            const highValueLetters = "QXZJKWVYFHPBCGMDULNTSRAOEI";
            const newGrid = [];

            for (let i = 0; i < GRID_SIZE; i++) {
                newGrid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    const randomIndex = Math.floor(Math.random() * highValueLetters.length);
                    newGrid[i][j] = highValueLetters[randomIndex];
                }
            }

            grid = newGrid;
            renderGrid();

            // Show lucky effect
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.classList.add('animate-bounce');
                setTimeout(() => {
                    tile.classList.remove('animate-bounce');
                }, 1000);
            });
        }

        function showPowerupUsageEffect(powerup) {
            const effectEl = document.createElement('div');
            effectEl.className = 'fixed top-16 left-1/2 transform -translate-x-1/2 bg-white border border-blue-300 px-3 py-1 rounded-full shadow-md z-50 animate-pulse';
            effectEl.innerHTML = `
                <div class="flex items-center space-x-1">
                    <div class="text-lg">${powerup.icon}</div>
                    <div class="text-xs font-bold text-blue-600">${powerup.name}</div>
                </div>
            `;

            document.body.appendChild(effectEl);

            setTimeout(() => {
                document.body.removeChild(effectEl);
            }, 1500);
        }

        // Daily Challenge Functions
        function getDailyChallengeId() {
            const today = new Date();
            return today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
        }

        function getDailyChallengeDate() {
            const today = new Date();
            return today.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }

        function getDailyChallengeInfo() {
            const today = new Date();
            const startDate = DAILY_CHALLENGE_CONFIG.startDate;

            // Calculate days since start
            const timeDiff = today.getTime() - startDate.getTime();
            const daysSinceStart = Math.floor(timeDiff / (1000 * 3600 * 24));

            // Handle dates before start date
            if (daysSinceStart < 0) {
                return {
                    challengeNumber: 1,
                    seed: DAILY_CHALLENGE_CONFIG.seeds[0],
                    theme: DAILY_CHALLENGE_CONFIG.themes[0],
                    isActive: false,
                    daysUntilStart: Math.abs(daysSinceStart)
                };
            }

            // Handle dates beyond our 100-day range
            if (daysSinceStart >= 100) {
                // Cycle through the challenges again
                const cycleDay = daysSinceStart % 100;
                const cycleNumber = Math.floor(daysSinceStart / 100) + 1;

                return {
                    challengeNumber: daysSinceStart + 1,
                    seed: DAILY_CHALLENGE_CONFIG.seeds[cycleDay],
                    theme: DAILY_CHALLENGE_CONFIG.themes[cycleDay % DAILY_CHALLENGE_CONFIG.themes.length],
                    isActive: true,
                    cycle: cycleNumber
                };
            }

            // Normal case: within first 100 days
            return {
                challengeNumber: daysSinceStart + 1,
                seed: DAILY_CHALLENGE_CONFIG.seeds[daysSinceStart],
                theme: DAILY_CHALLENGE_CONFIG.themes[daysSinceStart % DAILY_CHALLENGE_CONFIG.themes.length],
                isActive: true
            };
        }

        function generateDailyGrid(challengeInfo) {
            // Use the pre-generated seed for deterministic grid generation
            const seed = challengeInfo.seed;
            const random = seedRandom(seed);

            // Use theme-specific grid size
            const gridSize = challengeInfo.theme.gridSize;

            const dailyGrid = [];
            for (let i = 0; i < gridSize; i++) {
                dailyGrid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    const randomIndex = Math.floor(random() * LETTER_DISTRIBUTION.length);
                    dailyGrid[i][j] = LETTER_DISTRIBUTION[randomIndex];
                }
            }
            return dailyGrid;
        }

        function seedRandom(seed) {
            // Simple seeded random number generator
            let m = 0x80000000; // 2**31
            let a = 1103515245;
            let c = 12345;
            let state = seed ? seed : Math.floor(Math.random() * (m - 1));

            return function() {
                state = (a * state + c) % m;
                return state / (m - 1);
            };
        }

        function loadDailyChallengeData() {
            try {
                const saved = localStorage.getItem(DAILY_CHALLENGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    dailyChallengeData.currentStreak = parsed.currentStreak || 0;
                    dailyChallengeData.lastPlayedDate = parsed.lastPlayedDate;
                    dailyChallengeData.completedChallenges = new Map(parsed.completedChallenges || []);
                    dailyChallengeData.streakBadges = new Set(parsed.streakBadges || []);
                }
            } catch (error) {
                console.error('Error loading daily challenge data:', error);
            }
        }

        function saveDailyChallengeData() {
            try {
                const toSave = {
                    currentStreak: dailyChallengeData.currentStreak,
                    lastPlayedDate: dailyChallengeData.lastPlayedDate,
                    completedChallenges: Array.from(dailyChallengeData.completedChallenges.entries()),
                    streakBadges: Array.from(dailyChallengeData.streakBadges)
                };
                localStorage.setItem(DAILY_CHALLENGE_KEY, JSON.stringify(toSave));
            } catch (error) {
                console.error('Error saving daily challenge data:', error);
            }
        }

        function openDailyChallengeModal() {
            const modal = document.getElementById('daily-challenge-modal');
            const challengeId = getDailyChallengeId();
            const challengeInfo = getDailyChallengeInfo();
            currentChallengeId = challengeId;

            // Update modal content
            document.getElementById('daily-challenge-date').textContent = getDailyChallengeDate();
            document.getElementById('challenge-number').textContent = challengeInfo.challengeNumber;
            document.getElementById('current-streak').textContent = `${dailyChallengeData.currentStreak} days`;

            // Update challenge info based on theme
            const gridSizeEl = document.getElementById('challenge-grid-size');
            const timeLimitText = document.querySelector('#daily-challenge-info .text-sm .font-medium:nth-child(2)');

            if (gridSizeEl) {
                gridSizeEl.textContent = `${challengeInfo.theme.gridSize}x${challengeInfo.theme.gridSize}`;
            }

            // Update time limit display
            const timeLimitEl = gridSizeEl.parentElement.children[1];
            if (timeLimitEl) {
                timeLimitEl.innerHTML = `Time Limit: <span class="font-medium">${challengeInfo.theme.timeLimit} seconds</span>`;
            }

            // Show theme name
            const themeEl = document.createElement('div');
            themeEl.className = 'text-sm text-emerald-600 font-medium';
            themeEl.textContent = `Theme: ${challengeInfo.theme.name}`;

            // Check if challenge is active
            if (!challengeInfo.isActive) {
                document.getElementById('challenge-status').textContent = `Starts in ${challengeInfo.daysUntilStart} days`;
                document.getElementById('start-daily-challenge').textContent = '‚è≥ Coming Soon';
                document.getElementById('start-daily-challenge').disabled = true;
            } else {
                // Check if already completed today
                const todayData = dailyChallengeData.completedChallenges.get(challengeId);
                if (todayData && todayData.completed) {
                    document.getElementById('challenge-status').textContent = 'Completed';
                    document.getElementById('today-score').textContent = todayData.score;
                    document.getElementById('today-rank').textContent = `#${todayData.rank || '--'}`;
                    document.getElementById('start-daily-challenge').textContent = '‚úÖ Already Completed';
                    document.getElementById('start-daily-challenge').disabled = true;
                } else {
                    document.getElementById('challenge-status').textContent = 'Not Started';
                    document.getElementById('today-score').textContent = '--';
                    document.getElementById('today-rank').textContent = '--';
                    document.getElementById('start-daily-challenge').textContent = 'üöÄ Start Today\'s Challenge';
                    document.getElementById('start-daily-challenge').disabled = false;
                }
            }

            // Show cycle information if applicable
            if (challengeInfo.cycle) {
                const cycleInfo = document.createElement('div');
                cycleInfo.className = 'text-xs text-gray-500 mt-1';
                cycleInfo.textContent = `Cycle ${challengeInfo.cycle} ‚Ä¢ Challenge ${challengeInfo.challengeNumber}`;
                document.getElementById('daily-challenge-info').appendChild(cycleInfo);
            }

            // Update streak badges
            updateStreakBadges();

            // Show upcoming challenges
            updateUpcomingChallenges();

            // Show modal
            modal.classList.remove('hidden');
            setTimeout(() => {
                const content = modal.querySelector('div');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function updateUpcomingChallenges() {
            const container = document.getElementById('upcoming-challenges-list');
            if (!container) return;

            container.innerHTML = '';

            // Show next 3 days
            for (let i = 1; i <= 3; i++) {
                const preview = getDailyChallengePreview(i);
                if (!preview) continue;

                const challengeEl = document.createElement('div');
                challengeEl.className = 'flex justify-between items-center text-xs bg-gray-50 rounded p-2';
                challengeEl.innerHTML = `
                    <div>
                        <span class="font-medium">Day ${i}: Challenge #${preview.challengeNumber}</span>
                        <span class="text-gray-500 ml-2">${preview.theme.name}</span>
                    </div>
                    <div class="text-gray-400">
                        ${preview.theme.gridSize}x${preview.theme.gridSize} ‚Ä¢ ${preview.theme.timeLimit}s
                    </div>
                `;

                container.appendChild(challengeEl);
            }
        }

        function updateStreakBadges() {
            const badges = document.querySelectorAll('.badge-item');
            badges.forEach(badge => {
                const requiredStreak = parseInt(badge.dataset.streak);
                if (dailyChallengeData.currentStreak >= requiredStreak || dailyChallengeData.streakBadges.has(requiredStreak)) {
                    badge.classList.add('bg-yellow-100', 'text-yellow-800');
                    badge.classList.remove('bg-gray-100', 'text-gray-500');
                } else {
                    badge.classList.add('bg-gray-100', 'text-gray-500');
                    badge.classList.remove('bg-yellow-100', 'text-yellow-800');
                }
            });
        }

        function closeDailyChallengeModal() {
            const modal = document.getElementById('daily-challenge-modal');
            const content = modal.querySelector('div');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        function startDailyChallenge() {
            const challengeInfo = getDailyChallengeInfo();

            // Check if challenge is active
            if (!challengeInfo.isActive) {
                alert(`Daily challenge starts in ${challengeInfo.daysUntilStart} days!`);
                return;
            }

            isDailyChallenge = true;
            currentGameMode = GAME_MODE.DAILY_CHALLENGE;

            // Use theme-specific settings
            GRID_SIZE = challengeInfo.theme.gridSize;
            currentBoardSize = challengeInfo.theme.gridSize === 4 ? BOARD_SIZE.SMALL : BOARD_SIZE.LARGE;

            // Generate today's grid using challenge info
            grid = generateDailyGrid(challengeInfo);

            closeDailyChallengeModal();
            hideOpeningUI();
            updateGridLayout();

            // Reset game state with theme-specific timer
            score = 0;
            foundWords = new Set();
            timer = challengeInfo.theme.timeLimit;

            // Start the game
            renderGrid();
            startTimer();

            console.log(`Daily challenge started: ${challengeInfo.theme.name} (${challengeInfo.theme.gridSize}x${challengeInfo.theme.gridSize}, ${challengeInfo.theme.timeLimit}s)`);
        }

        function completeDailyChallenge() {
            if (!isDailyChallenge) return;

            // Don't save to leaderboard if secret commands were used
            if (secretCommandsUsed) {
                console.log("Daily challenge score not saved to leaderboard: secret commands were used");

                // Show notification
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 bg-red-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-500';
                notification.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="text-xl">üö´</span>
                        <div>
                            <div class="font-bold">Challenge Invalid</div>
                            <div class="text-sm opacity-90">Secret commands were used</div>
                        </div>
                    </div>
                `;

                document.body.appendChild(notification);

                // Animate in
                setTimeout(() => {
                    notification.classList.remove('translate-x-full');
                }, 100);

                // Auto-hide after 4 seconds
                setTimeout(() => {
                    notification.classList.add('translate-x-full');
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 500);
                }, 4000);

                // Reset daily challenge state and return to menu
                isDailyChallenge = false;
                currentChallengeId = null;
                showOpeningUI();
                return;
            }

            // Calculate rank (simulated for now)
            const rank = calculateDailyRank(score);

            // Update challenge data
            dailyChallengeData.completedChallenges.set(currentChallengeId, {
                score: score,
                words: foundWords.size,
                completed: true,
                rank: rank,
                date: new Date().toISOString()
            });

            // Update streak
            updateDailyStreak();

            // Save data
            saveDailyChallengeData();

            // Add to leaderboard
            addToLeaderboard(score, foundWords.size);

            // Check daily challenge achievements
            checkDailyChallengeAchievements(rank);

            // Show results modal
            showDailyChallengeResults(rank);
        }

        function updateDailyStreak() {
            const today = new Date();
            const todayStr = today.toDateString();

            if (dailyChallengeData.lastPlayedDate) {
                const lastPlayed = new Date(dailyChallengeData.lastPlayedDate);
                const lastPlayedStr = lastPlayed.toDateString();

                if (lastPlayedStr === todayStr) {
                    // Already played today, don't update streak
                    return;
                }

                const daysDiff = Math.floor((today - lastPlayed) / (1000 * 60 * 60 * 24));

                if (daysDiff === 1) {
                    // Consecutive day
                    dailyChallengeData.currentStreak++;
                } else if (daysDiff > 1) {
                    // Streak broken
                    dailyChallengeData.currentStreak = 1;
                }
            } else {
                // First time playing
                dailyChallengeData.currentStreak = 1;
            }

            dailyChallengeData.lastPlayedDate = todayStr;

            // Check for new streak badges
            checkStreakBadges();
        }

        function checkStreakBadges() {
            const streakMilestones = [3, 7, 30, 100];
            let newBadge = null;

            streakMilestones.forEach(milestone => {
                if (dailyChallengeData.currentStreak >= milestone && !dailyChallengeData.streakBadges.has(milestone)) {
                    dailyChallengeData.streakBadges.add(milestone);
                    newBadge = milestone;
                }
            });

            return newBadge;
        }

        function checkDailyChallengeAchievements(rank) {
            const achievementsToCheck = [];

            // Daily debut
            if (!achievements.daily_debut.unlocked) {
                achievements.daily_debut.unlocked = true;
                achievementsToCheck.push(achievements.daily_debut);
            }

            // Streak achievements
            if (dailyChallengeData.currentStreak >= 3 && !achievements.streak_starter.unlocked) {
                achievements.streak_starter.unlocked = true;
                achievementsToCheck.push(achievements.streak_starter);
            }

            if (dailyChallengeData.currentStreak >= 7 && !achievements.weekly_champion.unlocked) {
                achievements.weekly_champion.unlocked = true;
                achievementsToCheck.push(achievements.weekly_champion);
            }

            if (dailyChallengeData.currentStreak >= 30 && !achievements.monthly_legend.unlocked) {
                achievements.monthly_legend.unlocked = true;
                achievementsToCheck.push(achievements.monthly_legend);
            }

            if (dailyChallengeData.currentStreak >= 100 && !achievements.century_streak.unlocked) {
                achievements.century_streak.unlocked = true;
                achievementsToCheck.push(achievements.century_streak);
            }

            // Score achievements
            if (score >= 2000 && !achievements.daily_perfectionist.unlocked) {
                achievements.daily_perfectionist.unlocked = true;
                achievementsToCheck.push(achievements.daily_perfectionist);
            }

            // Rank achievements
            if (rank === 1 && !achievements.daily_champion.unlocked) {
                achievements.daily_champion.unlocked = true;
                achievementsToCheck.push(achievements.daily_champion);
            }

            if (rank <= 3 && !achievements.daily_podium.unlocked) {
                achievements.daily_podium.unlocked = true;
                achievementsToCheck.push(achievements.daily_podium);
            }

            // Show achievement notifications
            if (achievementsToCheck.length > 0) {
                showAchievementNotification(achievementsToCheck);
                saveAchievements();
            }
        }

        function calculateDailyRank(playerScore) {
            // Simulate ranking based on score
            // In a real implementation, this would query a server
            const leaderboard = getDailyLeaderboard();
            let rank = 1;

            leaderboard.forEach(entry => {
                if (entry.score > playerScore) {
                    rank++;
                }
            });

            return rank;
        }

        function addToLeaderboard(playerScore, wordsFound) {
            let leaderboard = getDailyLeaderboard();

            // Add current player's score
            leaderboard.push({
                score: playerScore,
                words: wordsFound,
                date: new Date().toISOString(),
                challengeId: currentChallengeId,
                name: 'You' // In real implementation, would use player name
            });

            // Sort by score descending
            leaderboard.sort((a, b) => b.score - a.score);

            // Keep top 100
            leaderboard = leaderboard.slice(0, 100);

            // Save leaderboard
            saveDailyLeaderboard(leaderboard);
        }

        function getDailyLeaderboard() {
            try {
                const saved = localStorage.getItem(DAILY_LEADERBOARD_KEY + '_' + currentChallengeId);
                return saved ? JSON.parse(saved) : [];
            } catch (error) {
                console.error('Error loading daily leaderboard:', error);
                return [];
            }
        }

        function saveDailyLeaderboard(leaderboard) {
            try {
                localStorage.setItem(DAILY_LEADERBOARD_KEY + '_' + currentChallengeId, JSON.stringify(leaderboard));
            } catch (error) {
                console.error('Error saving daily leaderboard:', error);
            }
        }

        function showDailyChallengeResults(rank) {
            const modal = document.getElementById('daily-results-modal');

            // Update results
            document.getElementById('final-challenge-score').textContent = score;
            document.getElementById('final-rank').textContent = `#${rank}`;
            document.getElementById('final-words').textContent = foundWords.size;
            document.getElementById('new-streak').textContent = dailyChallengeData.currentStreak;

            // Check for new badge
            const newBadge = checkStreakBadges();
            const badgeEarned = document.getElementById('badge-earned');

            if (newBadge) {
                const badgeIcon = document.getElementById('earned-badge-icon');
                const badgeText = document.getElementById('earned-badge-text');

                let icon = 'üî•';
                let text = `${newBadge}-Day Streak!`;

                if (newBadge === 7) { icon = '‚≠ê'; text = 'Week Streak!'; }
                else if (newBadge === 30) { icon = 'üíé'; text = 'Month Streak!'; }
                else if (newBadge === 100) { icon = 'üëë'; text = 'Legend Streak!'; }

                badgeIcon.textContent = icon;
                badgeText.textContent = text;
                badgeEarned.classList.remove('hidden');
            } else {
                badgeEarned.classList.add('hidden');
            }

            // Show modal
            modal.classList.remove('hidden');
            setTimeout(() => {
                const content = modal.querySelector('div');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function showDailyLeaderboard() {
            const modal = document.getElementById('daily-leaderboard-modal');
            const leaderboard = getDailyLeaderboard();
            const leaderboardList = document.getElementById('leaderboard-list');

            // Update date
            document.getElementById('leaderboard-date').textContent = getDailyChallengeDate();

            // Clear and populate leaderboard
            leaderboardList.innerHTML = '';

            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<div class="text-center py-4 text-gray-500">No scores yet today</div>';
            } else {
                leaderboard.slice(0, 20).forEach((entry, index) => {
                    const row = document.createElement('div');
                    row.className = `flex justify-between items-center py-2 px-3 rounded-lg ${entry.name === 'You' ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'}`;

                    let rankDisplay = `${index + 1}.`;
                    if (index === 0) rankDisplay = 'ü•á';
                    else if (index === 1) rankDisplay = 'ü•à';
                    else if (index === 2) rankDisplay = 'ü•â';

                    row.innerHTML = `
                        <div class="flex items-center space-x-2">
                            <span class="font-medium">${rankDisplay}</span>
                            <span class="${entry.name === 'You' ? 'font-bold text-blue-600' : ''}">${entry.name}</span>
                        </div>
                        <div class="text-right">
                            <div class="font-bold">${entry.score}</div>
                            <div class="text-xs text-gray-500">${entry.words} words</div>
                        </div>
                    `;

                    leaderboardList.appendChild(row);
                });
            }

            // Show modal
            modal.classList.remove('hidden');
            setTimeout(() => {
                const content = modal.querySelector('div');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function closeDailyLeaderboard() {
            const modal = document.getElementById('daily-leaderboard-modal');
            const content = modal.querySelector('div');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        function closeDailyResults() {
            const modal = document.getElementById('daily-results-modal');
            const content = modal.querySelector('div');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
                // Reset daily challenge state
                isDailyChallenge = false;
                currentChallengeId = null;
                // Return to opening UI
                showOpeningUI();
            }, 300);
        }

        function shareScore() {
            const challengeData = dailyChallengeData.completedChallenges.get(currentChallengeId);
            if (!challengeData) return;

            const shareText = `üéØ Word Hunt Daily Challenge #${currentChallengeId}\n` +
                             `üìä Score: ${challengeData.score} points\n` +
                             `üìù Words: ${challengeData.words}\n` +
                             `üèÜ Rank: #${challengeData.rank}\n` +
                             `üî• Streak: ${dailyChallengeData.currentStreak} days\n\n` +
                             `Play today's challenge!`;

            if (navigator.share) {
                navigator.share({
                    title: 'Word Hunt Daily Challenge',
                    text: shareText
                });
            } else {
                // Fallback: copy to clipboard
                navigator.clipboard.writeText(shareText).then(() => {
                    alert('Score copied to clipboard!');
                }).catch(() => {
                    // Final fallback: show in alert
                    alert(shareText);
                });
            }
        }

        function setupDailyChallengeListeners() {
            // Daily challenge modal buttons
            document.getElementById('start-daily-challenge').addEventListener('click', startDailyChallenge);
            document.getElementById('view-daily-leaderboard').addEventListener('click', showDailyLeaderboard);
            document.getElementById('close-daily-challenge').addEventListener('click', closeDailyChallengeModal);

            // Leaderboard modal buttons
            document.getElementById('close-leaderboard').addEventListener('click', closeDailyLeaderboard);
            document.getElementById('share-score').addEventListener('click', shareScore);

            // Results modal buttons
            document.getElementById('view-leaderboard-from-results').addEventListener('click', () => {
                closeDailyResults();
                setTimeout(showDailyLeaderboard, 100);
            });
            document.getElementById('share-daily-result').addEventListener('click', shareScore);
            document.getElementById('close-daily-results').addEventListener('click', closeDailyResults);
        }

        // Automatic daily challenge management
        function initializeDailyChallengeSystem() {
            console.log('Initializing daily challenge system...');

            // Check for new daily challenge
            checkForNewDailyChallenge();

            // Set up automatic checking every hour
            setInterval(checkForNewDailyChallenge, 60 * 60 * 1000); // Check every hour

            // Set up midnight checker for immediate updates
            scheduleNextMidnightCheck();
        }

        function checkForNewDailyChallenge() {
            const challengeInfo = getDailyChallengeInfo();
            const today = getDailyChallengeId();

            console.log(`Daily Challenge #${challengeInfo.challengeNumber}: ${challengeInfo.theme.name}`);

            // Update daily challenge button with current info
            updateDailyChallengeButton(challengeInfo);

            // Check if player has missed days (for streak tracking)
            checkMissedDays();
        }

        function updateDailyChallengeButton(challengeInfo) {
            const button = document.getElementById('opening-daily-challenge-btn');
            if (!button) return;

            const today = getDailyChallengeId();
            const todayData = dailyChallengeData.completedChallenges.get(today);
            const isCompleted = todayData && todayData.completed;

            // Update button text based on status
            if (!challengeInfo.isActive) {
                button.innerHTML = `üìÖ Daily Challenge<br><span class="text-xs opacity-75">Starts in ${challengeInfo.daysUntilStart} days</span>`;
                button.disabled = true;
                button.classList.add('opacity-50');
            } else if (isCompleted) {
                button.innerHTML = `üìÖ Daily Challenge<br><span class="text-xs opacity-75">‚úÖ Completed (#${challengeInfo.challengeNumber})</span>`;
                button.disabled = false;
                button.classList.remove('opacity-50');
            } else {
                button.innerHTML = `üìÖ Daily Challenge<br><span class="text-xs opacity-75">#${challengeInfo.challengeNumber} ‚Ä¢ ${challengeInfo.theme.name}</span>`;
                button.disabled = false;
                button.classList.remove('opacity-50');

                // Add subtle animation for new challenges
                button.classList.add('animate-pulse');
                setTimeout(() => {
                    button.classList.remove('animate-pulse');
                }, 3000);
            }
        }

        function scheduleNextMidnightCheck() {
            const now = new Date();
            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(0, 0, 1, 0); // 1 second after midnight

            const msUntilMidnight = tomorrow.getTime() - now.getTime();

            setTimeout(() => {
                console.log('üåÖ New day detected! Checking for new daily challenge...');
                checkForNewDailyChallenge();

                // Schedule the next check
                scheduleNextMidnightCheck();

                // Show notification for new challenge
                showNewDayChallengeNotification();
            }, msUntilMidnight);

            console.log(`Next daily challenge check scheduled in ${Math.round(msUntilMidnight / 1000 / 60)} minutes`);
        }

        function showNewDayChallengeNotification() {
            const challengeInfo = getDailyChallengeInfo();

            if (!challengeInfo.isActive) return;

            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-emerald-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-500';
            notification.innerHTML = `
                <div class="flex items-center space-x-2">
                    <span class="text-xl">üìÖ</span>
                    <div>
                        <div class="font-bold">New Daily Challenge!</div>
                        <div class="text-sm opacity-90">#${challengeInfo.challengeNumber} ‚Ä¢ ${challengeInfo.theme.name}</div>
                    </div>
                </div>
            `;

            document.body.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 100);

            // Auto-hide after 5 seconds
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 500);
            }, 5000);
        }

        function checkMissedDays() {
            if (!dailyChallengeData.lastPlayedDate) return;

            const lastPlayed = new Date(dailyChallengeData.lastPlayedDate);
            const today = new Date();
            const daysDiff = Math.floor((today - lastPlayed) / (1000 * 60 * 60 * 24));

            // If more than 1 day has passed, streak is broken
            if (daysDiff > 1) {
                if (dailyChallengeData.currentStreak > 0) {
                    console.log(`Streak broken: ${daysDiff} days missed`);
                    dailyChallengeData.currentStreak = 0;
                    saveDailyChallengeData();
                }
            }
        }

        function getDailyChallengePreview(daysAhead = 0) {
            const targetDate = new Date();
            targetDate.setDate(targetDate.getDate() + daysAhead);

            const startDate = DAILY_CHALLENGE_CONFIG.startDate;
            const timeDiff = targetDate.getTime() - startDate.getTime();
            const daysSinceStart = Math.floor(timeDiff / (1000 * 3600 * 24));

            if (daysSinceStart < 0 || daysSinceStart >= 100) {
                return null;
            }

            return {
                date: targetDate.toLocaleDateString(),
                challengeNumber: daysSinceStart + 1,
                theme: DAILY_CHALLENGE_CONFIG.themes[daysSinceStart % DAILY_CHALLENGE_CONFIG.themes.length],
                seed: DAILY_CHALLENGE_CONFIG.seeds[daysSinceStart]
            };
        }

        function setupPowerupListeners() {
            // Power-up collection modal
            document.getElementById('close-powerup-modal').addEventListener('click', closePowerupCollectionModal);

            // Power-up shop modal
            document.getElementById('close-powerup-shop').addEventListener('click', () => {
                const modal = document.getElementById('powerup-shop-modal');
                const content = modal.querySelector('div');
                content.classList.add('scale-95', 'opacity-0');
                setTimeout(() => {
                    modal.classList.add('hidden');
                }, 300);
            });
        }

        // Initialize the game when the page loads
        window.onload = async function() {
            console.log("Window loaded");

            // Load the dictionary first
            await loadDictionary();

            // Load achievements and statistics
            loadAchievements();

            // Load high scores
            loadHighScores();

            // Load daily challenge data
            loadDailyChallengeData();

            // Initialize daily challenge system
            initializeDailyChallengeSystem();

            // Load power-up inventory
            loadPowerupInventory();

            // Set up event listeners
            setupEventListeners();
            setupOpeningUI();
            setupDailyChallengeListeners();
            setupPowerupListeners();

            // Set up secret menu
            setupSecretMenu();

            // Add the secret dot
            addSecretDot();

            // Setup mobile touch pattern detection
            setupMobileTouchPattern();

            // Refresh secret dots periodically to ensure they appear in all modes
            setInterval(() => {
                addSecretDot();
            }, 2000);

            // Initialize board size selection
            updateBoardSizeSelection();

            // Show opening UI instead of starting game
            showOpeningUI();

            // Make key functions available globally for debugging
            window.endGame = endGame;
            window.startNewGame = init;
            window.showAllWords = showAllPossibleWords;
            window.showMenu = showOpeningUI;
            window.debugStorage = debugLocalStorage;
            window.resetData = resetAllData;

            console.log("Game ready! You can use these console commands:");
            console.log("- endGame() - End the current game");
            console.log("- startNewGame() - Start a new game");
            console.log("- showMenu() - Show the opening menu");
            console.log("- debugStorage() - Check localStorage contents");
            console.log("- resetData() - Reset all game data (use with caution)");
        }
    </script>
</body>
</html>
