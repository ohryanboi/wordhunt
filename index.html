<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Word Hunt</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            touch-action: manipulation; /* Prevents zooming on mobile */
            background-color: #15803d; /* dark green */
            background-image: 
                linear-gradient(45deg, rgba(0,0,0,0.08) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.08) 75%), 
                linear-gradient(45deg, rgba(0,0,0,0.08) 25%, transparent 25%, transparent 75%, rgba(0,0,0,0.08) 75%);
            background-size: 30px 30px;
            background-position: 0 0, 15px 15px;
        }
        .tile {
            background-color: #f4e4bc; /* Light cream/wood color */
            border: 2px solid #d4b896; /* Darker border */
            color: #5d4037; /* Dark brown text */
            border-radius: 12px; /* Rounded corners like the image */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
            transition: all 0.1s ease-in-out;
            font-weight: bold;
            aspect-ratio: 1;
            min-height: 60px;
        }
        .tile:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .tile:active {
            transform: translateY(0px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .tile.selected {
            background-color: #4ade80; /* Bright green */
            color: white;
            border-color: #22c55e;
            box-shadow: 0 4px 12px rgba(34, 197, 94, 0.4);
            transform: scale(1.05) translateY(-2px);
        }
        .tile.correct {
            animation: correct-word-animation 0.5s ease;
        }
        @keyframes correct-word-animation {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); background-color: #4ade80; }
        }
        .tile.incorrect {
             animation: incorrect-word-animation 0.5s ease;
        }
        @keyframes incorrect-word-animation {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-6px); }
            50% { transform: translateX(6px); }
            75% { transform: translateX(-6px); }
        }
        #current-word-display {
            transition: opacity 0.2s, transform 0.2s;
        }
        @keyframes flash {
            0%, 100% { background-color: #15803d; }
            50% { background-color: #fbbf24; }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        /* Lightweight achievement notification animation */
        @keyframes achievementSlide {
            0% { transform: translate(-50%, -20px); opacity: 0; }
            100% { transform: translate(-50%, 0); opacity: 1; }
        }

        .achievement-notification {
            animation: achievementSlide 0.3s ease-out;
        }

        /* Mobile-responsive menu styles */
        .mobile-menu-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 60;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .mobile-menu-content {
            background: white;
            border-radius: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            width: 100%;
            max-width: 400px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            transform: scale(0.95);
            opacity: 0;
            transition: all 0.2s ease-out;
        }

        .mobile-menu-content.show {
            transform: scale(1);
            opacity: 1;
        }

        .mobile-menu-header {
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .mobile-menu-body {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            -webkit-overflow-scrolling: touch;
        }

        .mobile-menu-footer {
            padding: 0.75rem 1rem;
            border-top: 1px solid #e5e7eb;
            background: #f9fafb;
            border-radius: 0 0 1rem 1rem;
            flex-shrink: 0;
        }

        /* Desktop menu styles for larger screens */
        @media (min-width: 768px) {
            .mobile-menu-panel {
                position: fixed;
                top: 1rem;
                left: auto;
                right: 1rem;
                bottom: auto;
                background: transparent;
                padding: 0;
                align-items: flex-start;
                justify-content: flex-end;
            }

            .mobile-menu-content {
                max-width: 320px;
                max-height: calc(100vh - 2rem);
                transform: translateX(100%);
                opacity: 1;
            }

            .mobile-menu-content.show {
                transform: translateX(0);
            }

            .mobile-menu-panel.left {
                left: 1rem;
                right: auto;
                justify-content: flex-start;
            }

            .mobile-menu-panel.left .mobile-menu-content {
                transform: translateX(-100%);
            }

            .mobile-menu-panel.left .mobile-menu-content.show {
                transform: translateX(0);
            }
        }

        /* Touch-friendly button styles */
        .mobile-touch-btn {
            min-height: 44px;
            padding: 0.75rem 1rem;
            margin: 0.25rem 0;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
            text-align: left;
            width: 100%;
            border: none;
            cursor: pointer;
        }

        .mobile-touch-btn:active {
            transform: scale(0.98);
        }

        /* Scrollbar styles for mobile menus */
        .mobile-menu-body::-webkit-scrollbar {
            width: 4px;
        }

        .mobile-menu-body::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 2px;
        }

        .mobile-menu-body::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 2px;
        }

        .mobile-menu-body::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }

        /* Tutorial System Styles */
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.2); /* Much lighter overlay for interactive tutorials */
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none; /* Allow clicks through overlay */
        }

        .tutorial-overlay.interactive {
            pointer-events: auto; /* Block clicks for modal-style tutorials */
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.7); /* Darker overlay for modal tutorials */
        }

        .tutorial-overlay.interactive .tutorial-popup {
            position: relative !important;
            z-index: auto !important;
        }

        .tutorial-overlay.show {
            opacity: 1;
        }

        .tutorial-popup {
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.25);
            border: 2px solid #3b82f6;
            max-width: 320px;
            width: 90%;
            max-height: 70vh;
            overflow-y: auto;
            transform: scale(0.9);
            transition: transform 0.3s ease;
            pointer-events: auto; /* Ensure popup can receive clicks */
        }

        .tutorial-overlay.show .tutorial-popup {
            transform: scale(1);
        }

        .tutorial-header {
            padding: 1rem 1.25rem;
            border-bottom: 1px solid #e5e7eb;
            text-align: center;
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            position: relative;
        }

        .tutorial-close {
            position: absolute;
            top: 0.5rem;
            right: 0.75rem;
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: all 0.2s ease;
        }

        .tutorial-close:hover {
            background: rgba(0, 0, 0, 0.1);
            color: #374151;
        }

        .tutorial-content {
            padding: 1rem 1.25rem;
        }

        .tutorial-footer {
            padding: 0.75rem 1.25rem;
            border-top: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f9fafb;
        }

        .tutorial-highlight {
            position: absolute;
            border: 3px solid #3b82f6;
            border-radius: 0.5rem;
            background: rgba(59, 130, 246, 0.1);
            z-index: 999;
            animation: tutorialPulse 2s infinite;
            pointer-events: none;
        }

        @keyframes tutorialPulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
            }
            50% {
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
            }
        }

        .tutorial-arrow {
            position: absolute;
            width: 0;
            height: 0;
            z-index: 1001;
        }

        .tutorial-arrow.top {
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 10px solid white;
            top: -10px;
        }

        .tutorial-arrow.bottom {
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid white;
            bottom: -10px;
        }

        .tutorial-arrow.left {
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-right: 10px solid white;
            left: -10px;
        }

        .tutorial-arrow.right {
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            border-left: 10px solid white;
            right: -10px;
        }

        /* Tooltip Styles */
        .tooltip {
            position: absolute;
            background: #1f2937;
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            max-width: 200px;
            z-index: 1000;
            opacity: 0;
            transform: translateY(5px);
            transition: all 0.2s ease;
            pointer-events: none;
        }

        .tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border: 5px solid transparent;
        }

        .tooltip.top::after {
            border-top-color: #1f2937;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .tooltip.bottom::after {
            border-bottom-color: #1f2937;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        .tooltip.left::after {
            border-left-color: #1f2937;
            left: 100%;
            top: 50%;
            transform: translateY(-50%);
        }

        .tooltip.right::after {
            border-right-color: #1f2937;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Tutorial Button Styles */
        .tutorial-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .tutorial-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .tutorial-btn:active {
            transform: translateY(0);
        }

        .tutorial-btn.secondary {
            background: #6b7280;
        }

        .tutorial-btn.secondary:hover {
            background: #4b5563;
            box-shadow: 0 4px 12px rgba(107, 114, 128, 0.4);
        }

        /* Strategy Guide Styles */
        .strategy-card {
            background: white;
            border-radius: 0.75rem;
            border: 1px solid #e5e7eb;
            padding: 1.5rem;
            margin-bottom: 1rem;
            transition: all 0.2s ease;
        }

        .strategy-card:hover {
            border-color: #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.15);
        }

        .strategy-category {
            display: inline-block;
            background: #dbeafe;
            color: #1e40af;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .strategy-category.intermediate {
            background: #fef3c7;
            color: #92400e;
        }

        .strategy-category.advanced {
            background: #fce7f3;
            color: #be185d;
        }

        /* Tutorial Progress */
        .tutorial-progress {
            background: #f3f4f6;
            border-radius: 1rem;
            height: 0.5rem;
            overflow: hidden;
            margin: 1rem 0;
        }

        .tutorial-progress-bar {
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            height: 100%;
            border-radius: 1rem;
            transition: width 0.3s ease;
        }

        /* Tutorial Path Highlighting */
        .tutorial-path-highlight {
            transition: all 0.3s ease;
            opacity: 0;
            transform: scale(0.8);
        }

        .tutorial-path-highlight.show {
            opacity: 1;
            transform: scale(1);
        }

        /* Tutorial Practice Mode Styles */
        .tutorial-mode .tile {
            transition: all 0.2s ease;
        }

        .tutorial-mode .tile:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body class="flex items-center justify-center min-h-screen">

    <!-- Opening UI -->
    <div id="opening-ui" class="w-full max-w-lg mx-auto p-6 flex flex-col items-center">

        <!-- Title -->
        <div class="text-center mb-8">
            <h1 class="text-5xl font-bold text-white mb-2 drop-shadow-lg">Word Hunt</h1>
            <p class="text-lg text-white/80">Find words in the letter grid!</p>
        </div>

        <!-- Board Size Selection -->
        <div class="bg-white rounded-xl shadow-lg p-6 w-full mb-6">
            <h2 class="text-xl font-bold text-gray-800 mb-2 text-center">Choose Board Size</h2>
            <p class="text-sm text-gray-600 text-center mb-4">Selected: <span id="selected-board-size" class="font-bold text-purple-600">4×4 Classic</span></p>

            <div class="flex space-x-4">
                <button id="board-4x4-btn" class="flex-1 p-4 bg-gradient-to-r from-purple-500 to-purple-600 text-white rounded-lg hover:from-purple-600 hover:to-purple-700 transition-all transform hover:scale-105 border-4 border-purple-300 shadow-lg">
                    <div class="text-center">
                        <div class="text-lg font-bold">4×4 Grid</div>
                        <div class="text-sm opacity-90">Classic • 16 Letters</div>
                        <div class="text-2xl mt-2">📱</div>
                        <div id="selected-4x4" class="text-xs mt-1 font-bold">✓ SELECTED</div>
                    </div>
                </button>

                <button id="board-5x5-btn" class="flex-1 p-4 bg-gradient-to-r from-orange-500 to-orange-600 text-white rounded-lg hover:from-orange-600 hover:to-orange-700 transition-all transform hover:scale-105 border-4 border-transparent">
                    <div class="text-center">
                        <div class="text-lg font-bold">5×5 Grid</div>
                        <div class="text-sm opacity-90">Challenge • 25 Letters</div>
                        <div class="text-2xl mt-2">🖥️</div>
                        <div id="selected-5x5" class="text-xs mt-1 font-bold opacity-0">✓ SELECTED</div>
                    </div>
                </button>
            </div>
        </div>

        <!-- Game Mode Selection -->
        <div class="bg-white rounded-xl shadow-lg p-6 w-full mb-6">
            <h2 class="text-xl font-bold text-gray-800 mb-4 text-center">Choose Your Mode</h2>

            <div class="space-y-4">
                <button id="start-timed-btn" class="w-full p-4 bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg hover:from-blue-600 hover:to-blue-700 transition-all transform hover:scale-105">
                    <div class="flex items-center justify-between">
                        <div class="text-left">
                            <div class="text-lg font-bold">⏱️ Timed Mode</div>
                            <div class="text-sm opacity-90">80 seconds to find as many words as possible</div>
                        </div>
                        <div class="text-2xl">🏃‍♂️</div>
                    </div>
                </button>

                <button id="start-unlimited-btn" class="w-full p-4 bg-gradient-to-r from-green-500 to-green-600 text-white rounded-lg hover:from-green-600 hover:to-green-700 transition-all transform hover:scale-105">
                    <div class="flex items-center justify-between">
                        <div class="text-left">
                            <div class="text-lg font-bold">♾️ Unlimited Mode</div>
                            <div class="text-sm opacity-90">Take your time and find every word</div>
                        </div>
                        <div class="text-2xl">🧘‍♀️</div>
                    </div>
                </button>
            </div>
        </div>

        <!-- Leaderboard -->
        <div class="bg-white rounded-xl shadow-lg p-6 w-full mb-6">
            <h2 class="text-xl font-bold text-gray-800 mb-4 text-center">🏆 Leaderboard</h2>

            <!-- Mode Tabs -->
            <div class="flex mb-4 border-b border-gray-200">
                <button id="leaderboard-timed-tab" class="flex-1 py-2 px-3 text-sm font-medium text-blue-600 border-b-2 border-blue-500">
                    Timed Mode
                </button>
                <button id="leaderboard-unlimited-tab" class="flex-1 py-2 px-3 text-sm font-medium text-gray-500 hover:text-gray-700">
                    Unlimited Mode
                </button>
            </div>

            <div id="opening-leaderboard" class="space-y-2">
                <div class="text-center py-4 text-gray-500">Loading scores...</div>
            </div>
        </div>

        <!-- Customize Button -->
        <div class="w-full mb-4">
            <button id="opening-customize-btn" class="w-full py-3 px-4 bg-gradient-to-r from-purple-500 to-indigo-600 text-white rounded-lg hover:from-purple-600 hover:to-indigo-700 transition-all text-lg font-medium transform hover:scale-105">
                🎨 Customize Game
            </button>
        </div>

        <!-- Achievements Button -->
        <div class="w-full mb-4">
            <button id="opening-achievements-btn" class="w-full py-3 px-4 bg-gradient-to-r from-yellow-500 to-orange-500 text-white rounded-lg hover:from-yellow-600 hover:to-orange-600 transition-all text-lg font-medium transform hover:scale-105">
                🏆 Achievements
            </button>
        </div>

        <!-- Analytics Button -->
        <div class="w-full mb-4">
            <button id="opening-analytics-btn" class="w-full py-3 px-4 bg-gradient-to-r from-indigo-500 to-purple-500 text-white rounded-lg hover:from-indigo-600 hover:to-purple-600 transition-all text-lg font-medium transform hover:scale-105">
                📊 Analytics
            </button>
        </div>

        <!-- Tutorial Button -->
        <div class="w-full mb-4">
            <button id="opening-tutorial-btn" class="w-full py-3 px-4 bg-gradient-to-r from-emerald-500 to-teal-500 text-white rounded-lg hover:from-emerald-600 hover:to-teal-600 transition-all text-lg font-medium transform hover:scale-105">
                🎓 Tutorial & Guides
            </button>
        </div>

        <!-- Daily Challenge Button -->
        <div class="w-full mb-4">
            <button id="opening-daily-challenge-btn" class="w-full py-3 px-4 bg-gradient-to-r from-emerald-500 to-teal-500 text-white rounded-lg hover:from-emerald-600 hover:to-teal-600 transition-all text-lg font-medium transform hover:scale-105">
                📅 Daily Challenge
            </button>
        </div>

        <!-- Data Reset Button -->
        <div class="w-full mb-6">
            <button id="reset-data-btn" class="w-full py-2 px-4 bg-gradient-to-r from-red-500 to-red-600 text-white rounded-lg hover:from-red-600 hover:to-red-700 transition-all text-sm font-medium">
                🗑️ Reset All Data
            </button>
        </div>

        <!-- Instructions -->
        <div class="bg-white/10 rounded-lg p-4 w-full text-center">
            <p class="text-white/80 text-sm">
                💡 <strong>How to play:</strong> Drag across adjacent letters to form words.
                Longer words = more points!
            </p>
        </div>

    </div>

    <!-- Game Container (hidden initially) -->
    <div id="game-container" class="w-full max-w-sm mx-auto p-4 flex flex-col items-center hidden">

        <!-- Score Header -->
        <div class="bg-white rounded-xl shadow-lg p-3 w-full max-w-xs text-center mb-4">
            <!-- Grid Size Indicator -->
            <div class="text-xs font-bold text-purple-600 mb-1">
                <span id="current-grid-size">4×4 GRID</span>
            </div>

            <div class="text-sm font-semibold text-gray-500">WORDS: <span id="word-count">0</span></div>
            <div class="text-2xl font-bold text-gray-800">SCORE: <span id="score">0</span></div>

            <!-- Game Mode Toggle -->
            <div class="mt-2 flex justify-center">
                <div class="bg-gray-200 rounded-full p-1 flex">
                    <button id="timed-mode-btn" class="px-3 py-1 rounded-full bg-blue-500 text-white text-sm font-medium transition-all">
                        Timed
                    </button>
                    <button id="unlimited-mode-btn" class="px-3 py-1 rounded-full text-gray-700 text-sm font-medium transition-all">
                        Unlimited
                    </button>
                </div>
            </div>
        </div>

        <!-- Customize Button -->
        <div class="w-full max-w-xs mb-3">
            <button id="customize-btn" class="w-full py-2 px-4 bg-gradient-to-r from-purple-500 to-indigo-600 text-white rounded-lg hover:from-purple-600 hover:to-indigo-700 transition-all text-sm font-medium">
                🎨 Customize
            </button>
        </div>

        <!-- Back to Menu Button -->
        <div class="w-full max-w-xs mb-3">
            <button id="back-to-menu-btn" class="w-full py-2 px-4 bg-gradient-to-r from-gray-500 to-gray-600 text-white rounded-lg hover:from-gray-600 hover:to-gray-700 transition-all text-sm font-medium">
                ← Back to Menu
            </button>
        </div>

        <!-- Timer -->
        <div id="timer-display" class="bg-black/25 text-white text-sm font-mono rounded-full px-3 py-1 mb-4">
            00:00
        </div>

        <!-- Current Word Preview -->
        <div id="current-word-display" class="h-10 mb-2 opacity-0 transform -translate-y-2">
             <div class="bg-green-500 text-white font-bold text-lg rounded-full px-5 py-2 shadow-md">
                <span id="current-word"></span>
            </div>
        </div>

        <!-- Power-ups Panel -->
        <div id="powerups-panel" class="bg-black/25 text-white text-sm rounded-full px-3 py-1 mb-4">
            <div class="flex items-center justify-between">
                <div class="font-mono">⚡</div>
                <div class="flex gap-1" id="powerups-inventory">
                    <!-- Power-ups will be populated here -->
                </div>
            </div>
        </div>

        <!-- Competitive Mode Indicator -->
        <div id="competitive-mode-indicator" class="bg-amber-500/90 text-white text-xs rounded-full px-3 py-1 mb-4 hidden">
            <div class="flex items-center justify-center">
                <div class="font-mono">🏆 Competitive Mode</div>
            </div>
        </div>

        <!-- Secret Commands Used Indicator -->
        <div id="secret-commands-indicator" class="bg-red-500/90 text-white text-xs rounded-full px-3 py-1 mb-4 hidden">
            <div class="flex items-center justify-center">
                <div class="font-mono">🚫 Score Won't Save</div>
            </div>
        </div>

        <!-- Game Grid -->
        <div class="relative">
            <!-- Grid Size Badge -->
            <div id="grid-size-badge" class="absolute -top-2 -right-2 bg-purple-600 text-white text-xs font-bold px-2 py-1 rounded-full z-10">
                4×4
            </div>
            <div id="grid-container" class="grid grid-cols-4 gap-3 md:gap-4 aspect-square select-none w-full max-w-xs bg-green-700 rounded-xl p-4 border-2 border-green-800">
                <!-- Tiles will be generated by JavaScript -->
            </div>
        </div>

    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-2xl shadow-2xl text-center w-11/12 max-w-md transform transition-all scale-95 opacity-0">
            <h2 class="text-4xl font-bold text-gray-800 mb-2" id="game-over-title">Time's Up!</h2>
            <p class="text-lg text-gray-600 mb-4">Your final score is:</p>
            <p id="final-score" class="text-6xl font-extrabold text-blue-500 mb-6">0</p>
            
            <!-- High Score Section -->
            <div class="mb-6 bg-gray-50 p-4 rounded-lg">
                <h3 class="text-xl font-semibold mb-2 text-gray-700">High Scores</h3>
                <div id="high-scores-list" class="text-left">
                    <div class="flex justify-between items-center py-1 border-b border-gray-200">
                        <span class="font-medium">Loading scores...</span>
                        <span></span>
                    </div>
                </div>
            </div>
            
            <div class="flex flex-col space-y-3">
                <button id="play-again-btn" class="w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-4 rounded-lg text-xl transition duration-300 transform hover:scale-105">
                    Play Again
                </button>
                
                <button id="show-all-words-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-xl transition duration-300 transform hover:scale-105">
                    Show All Possible Words
                </button>
            </div>
            
            <div id="all-possible-words" class="mt-6 hidden">
                <h3 class="text-xl font-semibold mb-2">All Possible Words</h3>
                
                <!-- Sorting options -->
                <div class="flex justify-between items-center mb-2">
                    <span class="text-sm text-gray-600">Sort by:</span>
                    <div class="flex space-x-2">
                        <button id="sort-length-desc" class="px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded hover:bg-blue-200 active-sort">
                            Length ↓
                        </button>
                        <button id="sort-alpha" class="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded hover:bg-gray-200">
                            A-Z
                        </button>
                        <button id="sort-value-desc" class="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded hover:bg-gray-200">
                            Value ↓
                        </button>
                        <button id="sort-value-asc" class="px-2 py-1 text-xs bg-gray-100 text-gray-800 rounded hover:bg-gray-200">
                            Value ↑
                        </button>
                    </div>
                </div>
                
                <div class="max-h-60 overflow-y-auto">
                    <div id="possible-words-list" class="grid grid-cols-2 gap-2 text-left"></div>
                    <p id="possible-words-count" class="mt-2 text-sm text-gray-500"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- Daily Challenge Modal -->
    <div id="daily-challenge-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-lg w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center mb-6">
                <h2 class="text-2xl font-bold text-emerald-600 mb-2">📅 Daily Challenge</h2>
                <p class="text-gray-600" id="daily-challenge-date">Today's Challenge</p>
            </div>

            <div id="daily-challenge-info" class="mb-6">
                <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4 mb-4">
                    <div class="flex items-center justify-between mb-2">
                        <span class="font-semibold text-emerald-700">Challenge #<span id="challenge-number"></span></span>
                        <span class="text-sm text-emerald-600" id="challenge-status">Not Started</span>
                    </div>
                    <div class="text-sm text-gray-600">
                        <div>Grid Size: <span id="challenge-grid-size" class="font-medium">4x4</span></div>
                        <div>Time Limit: <span class="font-medium">80 seconds</span></div>
                        <div>Your Streak: <span id="current-streak" class="font-bold text-emerald-600">0 days</span></div>
                    </div>
                </div>

                <div id="daily-stats" class="grid grid-cols-2 gap-4 mb-4">
                    <div class="bg-gray-50 rounded-lg p-3 text-center">
                        <div class="text-lg font-bold text-gray-800" id="today-score">--</div>
                        <div class="text-xs text-gray-500">Your Score</div>
                    </div>
                    <div class="bg-gray-50 rounded-lg p-3 text-center">
                        <div class="text-lg font-bold text-gray-800" id="today-rank">--</div>
                        <div class="text-xs text-gray-500">Your Rank</div>
                    </div>
                </div>

                <div id="streak-badges" class="mb-4">
                    <h4 class="font-semibold text-gray-700 mb-2">Streak Badges</h4>
                    <div class="flex flex-wrap gap-2">
                        <div class="badge-item flex items-center space-x-1 px-2 py-1 rounded-full text-xs" data-streak="3">
                            <span>🔥</span><span>3-Day</span>
                        </div>
                        <div class="badge-item flex items-center space-x-1 px-2 py-1 rounded-full text-xs" data-streak="7">
                            <span>⭐</span><span>Week</span>
                        </div>
                        <div class="badge-item flex items-center space-x-1 px-2 py-1 rounded-full text-xs" data-streak="30">
                            <span>💎</span><span>Month</span>
                        </div>
                        <div class="badge-item flex items-center space-x-1 px-2 py-1 rounded-full text-xs" data-streak="100">
                            <span>👑</span><span>Legend</span>
                        </div>
                    </div>
                </div>
            </div>

            <div id="upcoming-challenges" class="mb-4">
                <h4 class="font-semibold text-gray-700 mb-2">Upcoming Challenges</h4>
                <div class="space-y-1" id="upcoming-challenges-list">
                    <!-- Upcoming challenges will be populated here -->
                </div>
            </div>

            <div class="space-y-3">
                <button id="start-daily-challenge" class="w-full py-3 bg-emerald-500 text-white rounded-lg hover:bg-emerald-600 transition-colors font-medium">
                    🚀 Start Today's Challenge
                </button>
                <button id="view-daily-leaderboard" class="w-full py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                    🏆 View Leaderboard
                </button>
                <button id="close-daily-challenge" class="w-full py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Daily Challenge Leaderboard Modal -->
    <div id="daily-leaderboard-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center mb-6">
                <h2 class="text-xl font-bold text-blue-600 mb-2">🏆 Daily Leaderboard</h2>
                <p class="text-gray-600" id="leaderboard-date">Today's Rankings</p>
            </div>

            <div id="leaderboard-content" class="mb-6">
                <div class="space-y-2" id="leaderboard-list">
                    <!-- Leaderboard entries will be populated here -->
                </div>
            </div>

            <div class="flex space-x-3">
                <button id="close-leaderboard" class="flex-1 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    Close
                </button>
                <button id="share-score" class="flex-1 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors">
                    📤 Share
                </button>
            </div>
        </div>
    </div>

    <!-- Daily Challenge Results Modal -->
    <div id="daily-results-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center mb-6">
                <h2 class="text-2xl font-bold text-emerald-600 mb-2">🎉 Challenge Complete!</h2>
                <p class="text-gray-600">Daily Challenge Results</p>
            </div>

            <div id="results-content" class="mb-6">
                <div class="bg-emerald-50 border border-emerald-200 rounded-lg p-4 mb-4">
                    <div class="text-center">
                        <div class="text-3xl font-bold text-emerald-600" id="final-challenge-score">0</div>
                        <div class="text-sm text-gray-600">Your Score</div>
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div class="text-center">
                        <div class="text-lg font-bold text-gray-800" id="final-rank">--</div>
                        <div class="text-xs text-gray-500">Global Rank</div>
                    </div>
                    <div class="text-center">
                        <div class="text-lg font-bold text-gray-800" id="final-words">0</div>
                        <div class="text-xs text-gray-500">Words Found</div>
                    </div>
                </div>

                <div id="streak-update" class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-4">
                    <div class="text-center">
                        <div class="text-lg font-bold text-yellow-600" id="new-streak">1</div>
                        <div class="text-sm text-gray-600">Day Streak!</div>
                        <div id="badge-earned" class="mt-2 hidden">
                            <span class="inline-flex items-center px-3 py-1 rounded-full text-sm font-medium bg-yellow-100 text-yellow-800">
                                <span id="earned-badge-icon">🔥</span>
                                <span id="earned-badge-text" class="ml-1">New Badge Earned!</span>
                            </span>
                        </div>
                    </div>
                </div>
            </div>

            <div class="space-y-3">
                <button id="view-leaderboard-from-results" class="w-full py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors">
                    🏆 View Leaderboard
                </button>
                <button id="share-daily-result" class="w-full py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors">
                    📤 Share Result
                </button>
                <button id="close-daily-results" class="w-full py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Power-up Collection Modal -->
    <div id="powerup-collection-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-4 max-w-xs w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center">
                <div class="text-3xl mb-2" id="collected-powerup-icon">⚡</div>
                <h3 class="text-lg font-bold text-gray-800 mb-1" id="collected-powerup-name">Power-up Found!</h3>
                <p class="text-sm text-gray-600 mb-3" id="collected-powerup-description">You found a power-up!</p>
                <div class="bg-blue-50 border border-blue-200 rounded-lg p-2 mb-3">
                    <div class="text-xs text-blue-700">
                        Total: <span id="powerup-inventory-count" class="font-bold">1</span> power-ups
                    </div>
                </div>
                <button id="close-powerup-modal" class="w-full py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors text-sm">
                    Continue Playing
                </button>
            </div>
        </div>
    </div>

    <!-- Power-up Shop Modal -->
    <div id="powerup-shop-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center mb-6">
                <h2 class="text-2xl font-bold text-purple-600 mb-2">⚡ Power-up Shop</h2>
                <p class="text-gray-600">Manage your power-ups</p>
            </div>

            <div id="shop-inventory" class="mb-6">
                <h3 class="font-semibold text-gray-700 mb-3">Your Inventory</h3>
                <div class="grid grid-cols-2 gap-3" id="shop-powerups-list">
                    <!-- Power-ups inventory will be populated here -->
                </div>
            </div>

            <div class="border-t pt-4">
                <div class="text-center text-sm text-gray-500 mb-4">
                    Earn power-ups by finding them during gameplay!
                </div>
                <button id="close-powerup-shop" class="w-full py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    Close
                </button>
            </div>
        </div>
    </div>

    <!-- Data Reset Confirmation Modal -->
    <div id="reset-confirmation-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-xl p-6 max-w-md w-full mx-4 transform scale-95 opacity-0 transition-all duration-300">
            <div class="text-center mb-6">
                <div class="text-6xl mb-4">⚠️</div>
                <h2 class="text-2xl font-bold text-red-600 mb-2">Reset All Data</h2>
                <p class="text-gray-600">This action cannot be undone!</p>
            </div>

            <div class="mb-6">
                <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                    <h3 class="font-semibold text-red-700 mb-2">This will permanently delete:</h3>
                    <ul class="text-sm text-red-600 space-y-1">
                        <li>• All high scores and leaderboards</li>
                        <li>• Daily challenge progress and streaks</li>
                        <li>• All achievements and unlocks</li>
                        <li>• Power-up inventory</li>
                        <li>• Game settings and customizations</li>
                    </ul>
                </div>
            </div>

            <div class="space-y-3">
                <button id="confirm-reset-btn" class="w-full py-3 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors font-medium">
                    🗑️ Yes, Delete Everything
                </button>
                <button id="cancel-reset-btn" class="w-full py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600 transition-colors">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        const gridContainer = document.getElementById('grid-container');
        const scoreEl = document.getElementById('score');
        const timerDisplayEl = document.getElementById('timer-display');
        const currentWordDisplayEl = document.getElementById('current-word-display');
        const currentWordEl = document.getElementById('current-word');
        const wordCountEl = document.getElementById('word-count');
        const gameOverModal = document.getElementById('game-over-modal');
        const finalScoreEl = document.getElementById('final-score');
        const playAgainBtn = document.getElementById('play-again-btn');

        // Constants
        let GRID_SIZE = 4; // Will be set based on board size
        const GAME_TIME = 80; // seconds

        // Multiple dictionary sources for comprehensive word coverage
        const DICTIONARY_URLS = [
            'https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt',
            'https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-usa.txt',
            'https://raw.githubusercontent.com/first20hours/google-10000-english/master/google-10000-english-usa-no-swears.txt'
        ];
        const GAME_MODE = {
            TIMED: 'timed',
            UNLIMITED: 'unlimited',
            DAILY_CHALLENGE: 'daily_challenge'
        };
        const BOARD_SIZE = {
            SMALL: 4,
            LARGE: 5
        };

        // Letter distribution (weighted to favor common letters)
        const LETTER_DISTRIBUTION = "AAAAAAAAABBCCDDDDEEEEEEEEEEEEFFGGGHHIIIIIIIIIJKLLLLMMNNNNNNOOOOOOOOOPPQRRRRRRSSSSSTTTTTTTTUUUUVVWWXYYZ";

        // Comprehensive built-in word list (common words for offline play)
        const BUILT_IN_WORDS = [
            // 3-letter words
            'THE', 'AND', 'FOR', 'ARE', 'BUT', 'NOT', 'YOU', 'ALL', 'CAN', 'HER', 'WAS', 'ONE', 'OUR', 'HAD', 'BY', 'HOT', 'WORD', 'WHAT', 'SOME', 'WE', 'IT', 'DO', 'CAN', 'OUT', 'OTHER', 'WERE', 'WHICH', 'THEIR', 'TIME', 'WILL', 'HOW', 'SAID', 'EACH', 'SHE', 'TWO', 'MORE', 'VERY', 'WHAT', 'KNOW', 'JUST', 'FIRST', 'GET', 'OVER', 'THINK', 'ALSO', 'YOUR', 'WORK', 'LIFE', 'ONLY', 'NEW', 'YEARS', 'WAY', 'MAY', 'SAY', 'COME', 'ITS', 'NOW', 'MOST', 'PEOPLE', 'MY', 'MADE', 'THAN', 'BEEN', 'CALL', 'WHO', 'OIL', 'SIT', 'SET', 'RUN', 'EAT', 'FAR', 'SEA', 'EYE', 'BAD', 'BIG', 'BOX', 'BOY', 'BUS', 'CAR', 'CAT', 'CUP', 'CUT', 'DAD', 'DAY', 'DOG', 'EAR', 'END', 'FAN', 'FUN', 'GOT', 'GUN', 'HAT', 'HIT', 'JOB', 'LAW', 'LEG', 'LET', 'LOT', 'LOW', 'MAN', 'MAP', 'MOM', 'NET', 'OLD', 'PAN', 'PEN', 'PET', 'PUT', 'RED', 'SAD', 'SUN', 'TEN', 'TOP', 'TOY', 'TRY', 'USE', 'VAN', 'WAR', 'WIN', 'YES', 'YET', 'ZOO',

            // 4-letter words
            'THAT', 'WITH', 'HAVE', 'THIS', 'WILL', 'YOUR', 'FROM', 'THEY', 'KNOW', 'WANT', 'BEEN', 'GOOD', 'MUCH', 'SOME', 'TIME', 'VERY', 'WHEN', 'COME', 'HERE', 'JUST', 'LIKE', 'LONG', 'MAKE', 'MANY', 'OVER', 'SUCH', 'TAKE', 'THAN', 'THEM', 'WELL', 'WERE', 'ABLE', 'BACK', 'CALL', 'CAME', 'EACH', 'EVEN', 'FIND', 'GIVE', 'HAND', 'HIGH', 'KEEP', 'LAST', 'LEFT', 'LIFE', 'LIVE', 'LOOK', 'MADE', 'MOST', 'MOVE', 'MUST', 'NAME', 'NEED', 'NEXT', 'OPEN', 'PART', 'PLAY', 'RIGHT', 'SAID', 'SAME', 'SEEM', 'SHOW', 'SIDE', 'TELL', 'TURN', 'USED', 'WANT', 'WAYS', 'WEEK', 'WENT', 'WHAT', 'WORD', 'WORK', 'YEAR', 'ALSO', 'AREA', 'AWAY', 'BEST', 'BOTH', 'CAME', 'CASE', 'CITY', 'COME', 'COULD', 'DAYS', 'DOES', 'DOWN', 'EACH', 'EARLY', 'EVEN', 'EVER', 'FACE', 'FACT', 'FEEL', 'FELT', 'FIRE', 'FORM', 'FOUR', 'FREE', 'FULL', 'GAME', 'GAVE', 'GIRL', 'GOES', 'GONE', 'GREAT', 'GREW', 'HALF', 'HARD', 'HEAD', 'HEAR', 'HELP', 'HELD', 'HOME', 'HOPE', 'HOUR', 'IDEA', 'INTO', 'JOHN', 'KEEP', 'KIND', 'KNEW', 'LAND', 'LARGE', 'LATE', 'LEARN', 'LESS', 'LINE', 'LIST', 'LIVE', 'LONG', 'LOOK', 'LOVE', 'MAIN', 'MAKE', 'MANY', 'MEAN', 'MIND', 'MORE', 'MOVE', 'MUCH', 'MUST', 'NAME', 'NEAR', 'NEED', 'NEVER', 'NEWS', 'NEXT', 'NICE', 'NIGHT', 'NONE', 'ONCE', 'ONLY', 'OPEN', 'ORDER', 'OTHER', 'OVER', 'PART', 'PAST', 'PLAN', 'PLAY', 'POINT', 'REAL', 'ROOM', 'SAID', 'SAME', 'SEEM', 'SEEN', 'SEND', 'SHOW', 'SIDE', 'SINCE', 'SMALL', 'SOME', 'SOON', 'STILL', 'SUCH', 'SURE', 'TAKE', 'TALK', 'TELL', 'THAN', 'THAT', 'THEM', 'THEN', 'THEY', 'THIS', 'TIME', 'TOLD', 'TOOK', 'TURN', 'UNDER', 'UNTIL', 'UPON', 'USED', 'VERY', 'WANT', 'WATER', 'WAYS', 'WEEK', 'WELL', 'WENT', 'WERE', 'WHAT', 'WHEN', 'WHERE', 'WILL', 'WITH', 'WORD', 'WORK', 'YEAR', 'YOUR',

            // 5-letter words
            'ABOUT', 'AFTER', 'AGAIN', 'BEING', 'BELOW', 'COULD', 'EVERY', 'FIRST', 'FOUND', 'GREAT', 'GROUP', 'HOUSE', 'LARGE', 'LIGHT', 'MIGHT', 'NEVER', 'OTHER', 'PLACE', 'RIGHT', 'SHALL', 'SMALL', 'SOUND', 'STILL', 'THEIR', 'THERE', 'THESE', 'THINK', 'THREE', 'UNDER', 'WATER', 'WHERE', 'WHICH', 'WHILE', 'WORLD', 'WOULD', 'WRITE', 'YOUNG', 'ABOVE', 'ADDED', 'ALONE', 'ALONG', 'AMONG', 'ASKED', 'BASED', 'BEGAN', 'BEING', 'BLACK', 'BRING', 'BUILD', 'BUILT', 'CARRY', 'CAUSE', 'CHAIR', 'CHILD', 'CLEAR', 'CLOSE', 'COLOR', 'COMES', 'COURT', 'DOING', 'EARLY', 'EARTH', 'FIELD', 'FINAL', 'FORCE', 'FORMS', 'FRONT', 'GIVEN', 'GOING', 'HANDS', 'HEARD', 'HEART', 'HEAVY', 'HORSE', 'HUMAN', 'KNOWN', 'LATER', 'LEARN', 'LEAST', 'LEAVE', 'LEVEL', 'LIGHT', 'LIVED', 'LOCAL', 'MAKES', 'MEANS', 'MONEY', 'MOVED', 'MUSIC', 'NEEDS', 'NIGHT', 'NORTH', 'OFTEN', 'ORDER', 'PAPER', 'PARTS', 'PARTY', 'PEACE', 'PHONE', 'PIECE', 'PLANT', 'POINT', 'POWER', 'PRESS', 'PRICE', 'QUITE', 'REACH', 'READY', 'RIVER', 'ROUND', 'SENSE', 'SERVE', 'SHALL', 'SHORT', 'SHOWN', 'SINCE', 'SPACE', 'SPEAK', 'SPENT', 'STAGE', 'START', 'STATE', 'STORY', 'STUDY', 'TAKEN', 'TERMS', 'TODAY', 'TOTAL', 'TRADE', 'TRIED', 'TRULY', 'UNION', 'UNTIL', 'USUAL', 'VALUE', 'VOICE', 'WATCH', 'WEEKS', 'WHOLE', 'WHOSE', 'WOMAN', 'WORDS', 'WORKS', 'YEARS',

            // 6+ letter words
            'SHOULD', 'AROUND', 'BEFORE', 'CHANGE', 'DURING', 'FOLLOW', 'FRIEND', 'GROUND', 'HAPPEN', 'HAVING', 'INSIDE', 'ITSELF', 'LETTER', 'LITTLE', 'LIVING', 'MAKING', 'MATTER', 'MOMENT', 'MOTHER', 'MOVING', 'NATURE', 'NEEDED', 'NUMBER', 'OFFICE', 'OPENED', 'PEOPLE', 'PERSON', 'PLAYED', 'PLEASE', 'POLICY', 'PRETTY', 'PUBLIC', 'RATHER', 'REASON', 'RECORD', 'RESULT', 'RETURN', 'SCHOOL', 'SECOND', 'SEEMED', 'SIMPLE', 'SINGLE', 'SOCIAL', 'SOMETHING', 'SPECIAL', 'STREET', 'STRONG', 'SYSTEM', 'TAKING', 'THINGS', 'THOUGH', 'THROUGH', 'TOWARD', 'TRYING', 'TURNED', 'UNITED', 'WANTED', 'WINDOW', 'WITHIN', 'WITHOUT', 'WORKING', 'WRITING', 'WRITTEN', 'ANOTHER', 'BECAUSE', 'BETWEEN', 'COMPANY', 'CONTROL', 'COUNTRY', 'CURRENT', 'DEVELOP', 'EXAMPLE', 'GENERAL', 'GETTING', 'GOVERNMENT', 'HOWEVER', 'INCLUDE', 'INSTEAD', 'INTEREST', 'LOOKING', 'MACHINE', 'MEETING', 'NOTHING', 'PICTURE', 'PROBLEM', 'PROGRAM', 'PROJECT', 'PROVIDE', 'QUALITY', 'QUICKLY', 'READING', 'REALITY', 'RECEIVE', 'REQUIRE', 'RUNNING', 'SCIENCE', 'SERVICE', 'SEVERAL', 'SOCIETY', 'STATION', 'STUDENT', 'SUPPORT', 'SURFACE', 'TEACHER', 'THOUGHT', 'TONIGHT', 'TROUBLE', 'USUALLY', 'VERSION', 'WAITING', 'WALKING', 'WEEKEND', 'WELCOME', 'WESTERN', 'WHETHER', 'WILLING', 'WINNING', 'WORKING', 'WRITING', 'ALREADY', 'AMAZING', 'ANCIENT', 'ANIMALS', 'ANOTHER', 'ANXIETY', 'ANYBODY', 'ANYMORE', 'APPEARS', 'APPLIED', 'ARTICLE', 'ATTEMPT', 'BALANCE', 'BATTERY', 'BEDROOM', 'BENEFIT', 'BICYCLE', 'BIOLOGY', 'BROTHER', 'BROUGHT', 'BUILDER', 'BURNING', 'CABINET', 'CALCIUM', 'CALLING', 'CAMPING', 'CAPTAIN', 'CAREFUL', 'CARRIED', 'CEILING', 'CENTRAL', 'CENTURY', 'CERTAIN', 'CHAMBER', 'CHANNEL', 'CHAPTER', 'CHARITY', 'CHICKEN', 'CIRCUIT', 'CLASSIC', 'CLIMATE', 'CLOTHES', 'COLLEGE', 'COMBINE', 'COMFORT', 'COMMAND', 'COMMENT', 'COMPARE', 'COMPLEX', 'CONCEPT', 'CONCERN', 'CONDUCT', 'CONFIRM', 'CONNECT', 'CONSIST', 'CONTACT', 'CONTAIN', 'CONTENT', 'CONTEST', 'CONTEXT', 'COOKING', 'CORRECT', 'COUNCIL', 'COUNTER', 'COURAGE', 'COVERED', 'CREATED', 'CULTURE', 'CURRENT', 'CUTTING', 'DANCING', 'DEALING', 'DECIDED', 'DELIVER', 'DENSITY', 'DEPENDS', 'DESKTOP', 'DESPITE', 'DESTROY', 'DEVELOP', 'DIAMOND', 'DIGITAL', 'DINNER', 'DISEASE', 'DISPLAY', 'DISTANT', 'DIVIDED', 'DRAWING', 'DRIVING', 'DROPPED', 'EARLIER', 'EASTERN', 'ECONOMY', 'EDITION', 'ELEMENT', 'EMOTION', 'ENABLED', 'ENDLESS', 'ENGAGED', 'ENGLISH', 'ENHANCE', 'EVENING', 'EXACTLY', 'EXAMINE', 'EXCITED', 'EXECUTE', 'EXHIBIT', 'EXPLAIN', 'EXPLORE', 'EXPRESS', 'EXTREME', 'FACTORY', 'FAILURE', 'FANTASY', 'FASHION', 'FEATURE', 'FEDERAL', 'FEELING', 'FICTION', 'FIFTEEN', 'FINANCE', 'FINDING', 'FISHING', 'FITNESS', 'FOREIGN', 'FOREVER', 'FORMULA', 'FORTUNE', 'FORWARD', 'FREEDOM', 'FURTHER', 'GALLERY', 'GARBAGE', 'GARDEN', 'GENERAL', 'GENETIC', 'GENUINE', 'GETTING', 'GLASSES', 'GREATER', 'GROWING', 'HABITAT', 'HANGING', 'HAPPENS', 'HEADING', 'HEALTHY', 'HEARING', 'HEATING', 'HELPING', 'HERSELF', 'HIGHWAY', 'HIMSELF', 'HISTORY', 'HOLDING', 'HOLIDAY', 'HOUSING', 'HOWEVER', 'HUNDRED', 'HUNTING', 'HUSBAND', 'IMAGINE', 'IMPROVE', 'INCLUDE', 'INITIAL', 'INQUIRY', 'INSIGHT', 'INSTALL', 'INSTANT', 'INSTEAD', 'INTENSE', 'INTERIM', 'INVOLVE', 'JOURNAL', 'JOURNEY', 'JUSTICE', 'KEEPING', 'KITCHEN', 'KNOWING', 'LANDING', 'LARGELY', 'LASTING', 'LAUNDRY', 'LEADING', 'LEARNED', 'LEATHER', 'LEAVING', 'LIBRARY', 'LIMITED', 'LINKING', 'LISTING', 'LOADING', 'LOCATED', 'LOOKING', 'MACHINE', 'MANAGER', 'MAPPING', 'MARRIED', 'MASSIVE', 'MAXIMUM', 'MEANING', 'MEASURE', 'MEDICAL', 'MEETING', 'MENTION', 'MESSAGE', 'MILLION', 'MINERAL', 'MINIMUM', 'MISSING', 'MISSION', 'MISTAKE', 'MIXTURE', 'MONITOR', 'MORNING', 'MUSICAL', 'NATURAL', 'NEITHER', 'NETWORK', 'NEUTRAL', 'NOTHING', 'NUCLEAR', 'NURSING', 'OBVIOUS', 'OFFICER', 'ONGOING', 'OPENING', 'OPERATE', 'OPINION', 'OPTICAL', 'ORGANIC', 'OUTDOOR', 'OUTLINE', 'OUTSIDE', 'OVERALL', 'PACKAGE', 'PAINTED', 'PARKING', 'PARTIAL', 'PARTNER', 'PASSAGE', 'PASSING', 'PASSION', 'PATIENT', 'PATTERN', 'PAYMENT', 'PENALTY', 'PERFECT', 'PERFORM', 'PERHAPS', 'PICTURE', 'PLASTIC', 'POPULAR', 'PORTION', 'POVERTY', 'PRECISE', 'PREDICT', 'PREPARE', 'PRESENT', 'PREVENT', 'PRIMARY', 'PRINTER', 'PRIVACY', 'PRIVATE', 'PROBLEM', 'PROCESS', 'PRODUCE', 'PRODUCT', 'PROFILE', 'PROJECT', 'PROMISE', 'PROTECT', 'PROVIDE', 'PURPOSE', 'PUSHING', 'PUTTING', 'QUALITY', 'QUARTER', 'QUICKLY', 'RADICAL', 'RAILWAY', 'RAPIDLY', 'READILY', 'READING', 'REALITY', 'RECEIVE', 'RECOVER', 'REFLECT', 'REGULAR', 'RELATED', 'RELEASE', 'REMAINS', 'REMOVAL', 'REPLACE', 'REQUIRE', 'RESERVE', 'RESOLVE', 'RESPECT', 'RESPOND', 'RESTORE', 'RETIRED', 'REVENUE', 'REVERSE', 'ROUTINE', 'RUNNING', 'SATISFY', 'SCIENCE', 'SCRATCH', 'SECTION', 'SEEKING', 'SELLING', 'SENDING', 'SERIOUS', 'SERVICE', 'SESSION', 'SETTING', 'SEVERAL', 'SHARING', 'SHELTER', 'SHOWING', 'SIMILAR', 'SITTING', 'SIXTEEN', 'SMOKING', 'SOCIETY', 'SOMEHOW', 'SOMEONE', 'SPEAKER', 'SPECIAL', 'STATION', 'STORAGE', 'STRANGE', 'STRETCH', 'STUDENT', 'SUBJECT', 'SUCCESS', 'SUGGEST', 'SUMMARY', 'SUPPORT', 'SUPPOSE', 'SURFACE', 'SURGERY', 'SURPLUS', 'SURVIVE', 'SUSPECT', 'SUSTAIN', 'TEACHER', 'TELLING', 'TENSION', 'TESTING', 'THERAPY', 'THEREBY', 'THOUGHT', 'THROUGH', 'TONIGHT', 'TOTALLY', 'TOUCHED', 'TOWARDS', 'TRAFFIC', 'TRAINED', 'TREATED', 'TROUBLE', 'TURNING', 'TYPICAL', 'UNIFORM', 'UNKNOWN', 'UNUSUAL', 'UPGRADE', 'UTILITY', 'VARIETY', 'VEHICLE', 'VERSION', 'VILLAGE', 'VISIBLE', 'WAITING', 'WALKING', 'WARNING', 'WEARING', 'WEATHER', 'WEBSITE', 'WEDDING', 'WEEKEND', 'WELCOME', 'WELFARE', 'WESTERN', 'WHETHER', 'WILLING', 'WINNING', 'WITHOUT', 'WORKING', 'WRITING', 'WRITTEN'
        ];

        // Game variables
        let grid = [];
        let score = 0;
        let timer = GAME_TIME;
        let timerInterval;
        let foundWords = new Set();
        let isMouseDown = false;
        let currentPath = []; // Stores {row, col} of the current path
        let englishWords = new Set(); // Will store our dictionary

        // Secret command tracking
        let secretCommandsUsed = false; // Track if any secret commands were used in current game
        let currentGameMode = GAME_MODE.TIMED; // Default game mode
        let currentBoardSize = BOARD_SIZE.SMALL; // Default board size

        // Daily Challenge System
        const DAILY_CHALLENGE_KEY = 'wordHuntDailyChallenges';
        const DAILY_STREAK_KEY = 'wordHuntDailyStreak';
        const DAILY_LEADERBOARD_KEY = 'wordHuntDailyLeaderboard';

        let dailyChallengeData = {
            currentStreak: 0,
            lastPlayedDate: null,
            completedChallenges: new Map(), // challengeId -> {score, words, completed, rank}
            streakBadges: new Set() // earned streak badges
        };

        // Daily challenge configuration for automatic generation
        const DAILY_CHALLENGE_CONFIG = {
            // Starting date for daily challenges (today)
            startDate: new Date('2024-12-18'),

            // Pre-generated seeds for 100 days of challenges
            seeds: [
                12345, 67890, 23456, 78901, 34567, 89012, 45678, 90123, 56789, 1234,
                11111, 22222, 33333, 44444, 55555, 66666, 77777, 88888, 99999, 10101,
                13579, 24680, 97531, 86420, 75319, 64208, 53197, 42086, 31975, 20864,
                98765, 87654, 76543, 65432, 54321, 43210, 32109, 21098, 10987, 9876,
                19283, 47561, 83729, 56104, 92847, 38520, 74163, 61958, 25374, 80691,
                15926, 53589, 79323, 84626, 43383, 27950, 28841, 97169, 39937, 51058,
                20974, 94459, 23078, 16406, 28620, 89986, 28034, 82534, 21170, 67982,
                14808, 65132, 82306, 64709, 38446, 9550, 58223, 17253, 59408, 12847,
                56482, 13956, 62977, 47093, 69995, 95749, 66967, 62772, 40766, 30353,
                54759, 45729, 64462, 29489, 54930, 38196, 44288, 10975, 66593, 34461
            ],

            // Challenge themes for variety (optional)
            themes: [
                { name: 'Classic', gridSize: 4, timeLimit: 80 },
                { name: 'Speed Run', gridSize: 4, timeLimit: 60 },
                { name: 'Extended', gridSize: 4, timeLimit: 100 },
                { name: 'Big Grid', gridSize: 5, timeLimit: 90 },
                { name: 'Marathon', gridSize: 5, timeLimit: 120 }
            ]
        };

        let isDailyChallenge = false;
        let currentChallengeId = null;

        // Cache for findAllPossibleWords optimization
        let wordSearchCache = {
            gridHash: null,
            words: null,
            trie: null
        };

        // Power-ups System
        const POWERUPS_KEY = 'wordHuntPowerups';
        const POWERUP_TYPES = {
            TIME_FREEZE: {
                id: 'time_freeze',
                name: 'Time Freeze',
                icon: '❄️',
                description: 'Freezes the timer for 10 seconds',
                rarity: 'common',
                duration: 10000,
                color: 'bg-blue-500'
            },
            WORD_HINT: {
                id: 'word_hint',
                name: 'Word Hint',
                icon: '💡',
                description: 'Reveals a random word on the grid',
                rarity: 'common',
                color: 'bg-yellow-500'
            },
            LETTER_SHUFFLE: {
                id: 'letter_shuffle',
                name: 'Letter Shuffle',
                icon: '🔀',
                description: 'Shuffles all letters on the grid',
                rarity: 'uncommon',
                color: 'bg-purple-500'
            },
            POINT_MULTIPLIER: {
                id: 'point_multiplier',
                name: '2x Points',
                icon: '✨',
                description: 'Double points for 30 seconds',
                rarity: 'rare',
                duration: 30000,
                multiplier: 2,
                color: 'bg-green-500'
            },
            MEGA_MULTIPLIER: {
                id: 'mega_multiplier',
                name: '3x Points',
                icon: '🌟',
                description: 'Triple points for 20 seconds',
                rarity: 'epic',
                duration: 20000,
                multiplier: 3,
                color: 'bg-orange-500'
            },
            EXTRA_TIME: {
                id: 'extra_time',
                name: 'Extra Time',
                icon: '⏰',
                description: 'Adds 15 seconds to the timer',
                rarity: 'uncommon',
                timeBonus: 15,
                color: 'bg-indigo-500'
            },
            WORD_MAGNET: {
                id: 'word_magnet',
                name: 'Word Magnet',
                icon: '🧲',
                description: 'Highlights all 6+ letter words for 15 seconds',
                rarity: 'rare',
                duration: 15000,
                color: 'bg-pink-500'
            },
            LUCKY_GRID: {
                id: 'lucky_grid',
                name: 'Lucky Grid',
                icon: '🍀',
                description: 'Replaces grid with high-scoring letters',
                rarity: 'epic',
                color: 'bg-emerald-500'
            }
        };

        // Power-up spawn rates (percentage chance per word found)
        const POWERUP_SPAWN_RATES = {
            common: 8,    // 8% chance
            uncommon: 4,  // 4% chance
            rare: 2,      // 2% chance
            epic: 0.5     // 0.5% chance
        };

        let powerupInventory = new Map(); // powerupId -> count
        let activePowerups = new Map(); // powerupId -> {endTime, data}
        let powerupSpawns = new Map(); // position -> powerupType
        let powerupEffects = {
            timeFreeze: false,
            pointMultiplier: 1,
            wordMagnet: false
        };

        // High scores management
        const HIGH_SCORES_KEY_TIMED_4X4 = 'wordHuntHighScoresTimed4x4';
        const HIGH_SCORES_KEY_UNLIMITED_4X4 = 'wordHuntHighScoresUnlimited4x4';
        const HIGH_SCORES_KEY_TIMED_5X5 = 'wordHuntHighScoresTimed5x5';
        const HIGH_SCORES_KEY_UNLIMITED_5X5 = 'wordHuntHighScoresUnlimited5x5';
        const MAX_HIGH_SCORES = 5;
        let highScores = [];

        // Game statistics
        let gamesPlayed = 0;
        let totalScore = 0;
        let bestScore = 0;
        let totalWordsFound = 0;

        // Analytics data structure
        const ANALYTICS_KEY = 'wordHuntAnalytics';
        let analyticsData = {
            sessions: [], // Array of game sessions
            wordPatterns: new Map(), // Word frequency and patterns
            performanceMetrics: {
                averageScore: 0,
                averageWordsPerGame: 0,
                averageGameDuration: 0,
                bestStreak: 0,
                totalPlayTime: 0,
                favoriteWordLength: 0,
                mostProductiveTimeOfDay: null,
                improvementTrend: 0
            },
            dailyStats: new Map(), // Daily aggregated statistics
            weeklyStats: new Map(), // Weekly aggregated statistics
            monthlyStats: new Map(), // Monthly aggregated statistics
            insights: [], // Generated insights and recommendations
            lastUpdated: null
        };

        // Tutorial System
        const TUTORIAL_KEY = 'wordHuntTutorial';
        let tutorialData = {
            completed: false,
            currentStep: 0,
            stepsCompleted: [],
            tooltipsShown: [],
            strategiesViewed: [],
            firstTimeUser: true,
            lastTutorialDate: null
        };

        const TUTORIAL_STEPS = [
            {
                id: 'welcome',
                title: 'Welcome to Word Hunt!',
                description: 'Let\'s learn how to play with a practice board.',
                target: null,
                position: 'center',
                action: 'highlight',
                content: 'Word Hunt is a game where you find words by connecting adjacent letters in a grid. We\'ve set up a practice board so you can learn by doing!'
            },
            {
                id: 'grid_explanation',
                title: 'The Letter Grid',
                description: 'This is your practice board with carefully chosen letters.',
                target: '#grid-container',
                position: 'auto', // Let the system choose the best position
                action: 'highlight',
                content: 'Each tile contains a letter. You can connect adjacent tiles (including diagonally) to form words. This practice grid has lots of easy words to find!'
            },
            {
                id: 'word_formation_demo',
                title: 'How to Form Words',
                description: 'Let me show you how to connect letters.',
                target: '#grid-container',
                position: 'auto',
                action: 'demo',
                content: 'Watch as I highlight the word "CAT" in the top row. You click and drag from C to A to T to form the word.',
                demoWord: 'CAT',
                demoPath: [{row: 0, col: 0}, {row: 0, col: 1}, {row: 0, col: 2}]
            },
            {
                id: 'first_word_practice',
                title: 'Your Turn: Find "CAT"',
                description: 'Now you try! Find the word "CAT".',
                target: '#grid-container',
                position: 'bottom',
                action: 'guided_practice',
                content: 'Click on the letter "C" in the top-left, then drag to "A", then to "T". The letters will highlight as you connect them.',
                targetWord: 'CAT',
                targetPath: [{row: 0, col: 0}, {row: 0, col: 1}, {row: 0, col: 2}]
            },
            {
                id: 'score_explanation',
                title: 'Great! You Scored Points!',
                description: 'See how your score increased.',
                target: '#score',
                position: 'bottom',
                action: 'highlight',
                content: 'You just earned 100 points for finding "CAT"! 3-letter words = 100pts, 4-letter words = 400pts, 5+ letters = even more!'
            },
            {
                id: 'longer_word_practice',
                title: 'Try a Longer Word: "CATS"',
                description: 'Longer words give more points!',
                target: '#grid-container',
                position: 'bottom',
                action: 'guided_practice',
                content: 'Now find "CATS" by connecting C-A-T-S. Start from C, go to A, then T, then S. This will give you 400 points!',
                targetWord: 'CATS',
                targetPath: [{row: 0, col: 0}, {row: 0, col: 1}, {row: 0, col: 2}, {row: 0, col: 3}]
            },
            {
                id: 'free_practice',
                title: 'Free Practice Time!',
                description: 'Find more words on your own.',
                target: '#grid-container',
                position: 'bottom',
                action: 'free_practice',
                content: 'Great job! Now try finding other words like "DOG", "MAN", "ORE", or "CODE". Take your time and explore the grid. Find at least 2 more words to continue.',
                wordsNeeded: 2
            },
            {
                id: 'tutorial_complete',
                title: 'Tutorial Complete!',
                description: 'You\'re ready to play!',
                target: null,
                position: 'center',
                action: 'completion',
                content: 'Excellent work! You\'ve learned the basics of Word Hunt. You can now choose between Timed Mode (race against the clock) or Unlimited Mode (take your time). Ready to start your first real game?'
            }
        ];

        const TOOLTIPS = {
            powerups: {
                title: 'Power-ups',
                content: 'Collect power-ups during gameplay to gain special abilities like freezing time or getting hints.',
                trigger: 'hover',
                position: 'top'
            },
            achievements: {
                title: 'Achievements',
                content: 'Unlock achievements by reaching milestones and completing challenges. Track your progress here!',
                trigger: 'hover',
                position: 'top'
            },
            analytics: {
                title: 'Analytics Dashboard',
                content: 'View detailed statistics about your gameplay, including score trends and word patterns.',
                trigger: 'hover',
                position: 'top'
            },
            daily_challenge: {
                title: 'Daily Challenge',
                content: 'Complete daily challenges to earn special rewards and compete on the leaderboard.',
                trigger: 'hover',
                position: 'top'
            },
            board_size: {
                title: 'Board Size',
                content: '4×4 Classic: Perfect for beginners. 5×5 Challenge: More letters, more possibilities, higher scores!',
                trigger: 'hover',
                position: 'bottom'
            },
            secret_commands: {
                title: 'Secret Commands',
                content: 'Advanced players can discover secret commands for special effects. Explore to find them!',
                trigger: 'hover',
                position: 'top'
            }
        };

        const STRATEGY_GUIDES = [
            {
                id: 'basic_strategy',
                title: 'Basic Word Finding',
                category: 'Beginner',
                icon: '🎯',
                description: 'Learn the fundamentals of finding words efficiently.',
                content: [
                    {
                        section: 'Start with Common Patterns',
                        tips: [
                            'Look for common letter combinations like "TH", "ER", "ING"',
                            'Search for vowels first - they\'re often the center of words',
                            'Try common 3-letter words: THE, AND, FOR, ARE, BUT'
                        ]
                    },
                    {
                        section: 'Scanning Techniques',
                        tips: [
                            'Scan horizontally, vertically, and diagonally',
                            'Start from corners and edges - they have fewer connections',
                            'Look for double letters that might form longer words'
                        ]
                    }
                ]
            },
            {
                id: 'scoring_optimization',
                title: 'Maximizing Your Score',
                category: 'Intermediate',
                icon: '💎',
                description: 'Advanced techniques to boost your point total.',
                content: [
                    {
                        section: 'Point Values',
                        tips: [
                            '3 letters = 100 points',
                            '4 letters = 400 points (4x more efficient!)',
                            '5 letters = 800 points',
                            '6+ letters = 1400+ points'
                        ]
                    },
                    {
                        section: 'Efficiency Tips',
                        tips: [
                            'Prioritize 4-letter words for best point-to-time ratio',
                            'Look for word extensions: CAT → CATS → CATCH',
                            'Use uncommon letters (Q, X, Z) when possible'
                        ]
                    }
                ]
            },
            {
                id: 'time_management',
                title: 'Time Management',
                category: 'Advanced',
                icon: '⏱️',
                description: 'Master the clock to maximize your performance.',
                content: [
                    {
                        section: 'Speed Strategies',
                        tips: [
                            'Spend first 20 seconds finding obvious words',
                            'Use middle 40 seconds for systematic searching',
                            'Final 20 seconds: quick scan for missed opportunities'
                        ]
                    },
                    {
                        section: 'Pressure Management',
                        tips: [
                            'Don\'t panic when time is low - stay focused',
                            'Practice in unlimited mode to improve pattern recognition',
                            'Learn to quickly abandon difficult words'
                        ]
                    }
                ]
            }
        ];

        // Achievements system with categories
        let achievements = {
            // Long-term achievements (progression over time)
            'first_game': { unlocked: false, name: 'First Steps', description: 'Play your first game', icon: '🎮', requirement: 1, type: 'games', category: 'long-term' },
            'games_5': { unlocked: false, name: 'Getting Started', description: 'Play 5 games', icon: '🎯', requirement: 5, type: 'games', category: 'long-term' },
            'games_10': { unlocked: false, name: 'Regular Player', description: 'Play 10 games', icon: '🏆', requirement: 10, type: 'games', category: 'long-term' },
            'games_25': { unlocked: false, name: 'Dedicated Gamer', description: 'Play 25 games', icon: '🎖️', requirement: 25, type: 'games', category: 'long-term' },
            'games_50': { unlocked: false, name: 'Word Hunter', description: 'Play 50 games', icon: '🏅', requirement: 50, type: 'games', category: 'long-term' },
            'games_100': { unlocked: false, name: 'Century Club', description: 'Play 100 games', icon: '👑', requirement: 100, type: 'games', category: 'long-term' },
            'words_total_100': { unlocked: false, name: 'Wordsmith', description: 'Find 100 words total', icon: '✍️', requirement: 100, type: 'words_total', category: 'long-term' },
            'words_total_500': { unlocked: false, name: 'Dictionary', description: 'Find 500 words total', icon: '📖', requirement: 500, type: 'words_total', category: 'long-term' },
            'words_total_1000': { unlocked: false, name: 'Encyclopedia', description: 'Find 1000 words total', icon: '📚', requirement: 1000, type: 'words_total', category: 'long-term' },
            'customizer': { unlocked: false, name: 'Style Master', description: 'Use 5 different customize effects', icon: '🎨', requirement: 5, type: 'customize', category: 'long-term' },

            // Skill-based achievements (require skill/performance)
            'score_100': { unlocked: false, name: 'First Century', description: 'Score 100 points in a game', icon: '💯', requirement: 100, type: 'score', category: 'skill' },
            'score_500': { unlocked: false, name: 'High Scorer', description: 'Score 500 points in a game', icon: '⭐', requirement: 500, type: 'score', category: 'skill' },
            'score_1000': { unlocked: false, name: 'Four Digits', description: 'Score 1000 points in a game', icon: '🌟', requirement: 1000, type: 'score', category: 'skill' },
            'score_2000': { unlocked: false, name: 'Elite Player', description: 'Score 2000 points in a game', icon: '💎', requirement: 2000, type: 'score', category: 'skill' },
            'score_3000': { unlocked: false, name: 'Master Player', description: 'Score 3000 points in a game', icon: '👑', requirement: 3000, type: 'score', category: 'skill' },
            'words_10': { unlocked: false, name: 'Word Finder', description: 'Find 10 words in a single game', icon: '📝', requirement: 10, type: 'words_single', category: 'skill' },
            'words_20': { unlocked: false, name: 'Vocabulary Master', description: 'Find 20 words in a single game', icon: '📚', requirement: 20, type: 'words_single', category: 'skill' },
            'words_30': { unlocked: false, name: 'Word Wizard', description: 'Find 30 words in a single game', icon: '🧙', requirement: 30, type: 'words_single', category: 'skill' },
            'perfect_game': { unlocked: false, name: 'Perfect Game', description: 'Find all possible words in a game', icon: '🎯', requirement: 1, type: 'perfect', category: 'skill' },
            'speed_demon': { unlocked: false, name: 'Speed Demon', description: 'Find 5 words in under 30 seconds', icon: '⚡', requirement: 5, type: 'speed', category: 'skill' },
            'lightning_fast': { unlocked: false, name: 'Lightning Fast', description: 'Find 10 words in under 60 seconds', icon: '🌩️', requirement: 10, type: 'speed', category: 'skill' },
            'long_word': { unlocked: false, name: 'Wordsmith Pro', description: 'Find a word with 8+ letters', icon: '📏', requirement: 8, type: 'word_length', category: 'skill' },
            'epic_word': { unlocked: false, name: 'Epic Wordsmith', description: 'Find a word with 10+ letters', icon: '📜', requirement: 10, type: 'word_length', category: 'skill' },

            // Hidden achievements (secret/discovery-based)
            'secret_finder': { unlocked: false, name: 'Secret Finder', description: 'Discover the secret menu', icon: '🔮', requirement: 1, type: 'secret', category: 'hidden' },
            'effect_collector': { unlocked: false, name: 'Effect Collector', description: 'Try 10 different visual effects', icon: '🎭', requirement: 10, type: 'customize', category: 'hidden' },
            'night_owl': { unlocked: false, name: 'Night Owl', description: 'Play a game after midnight', icon: '🦉', requirement: 1, type: 'time', category: 'hidden' },
            'early_bird': { unlocked: false, name: 'Early Bird', description: 'Play a game before 6 AM', icon: '🐦', requirement: 1, type: 'time', category: 'hidden' },
            'palindrome_hunter': { unlocked: false, name: 'Palindrome Hunter', description: 'Find a palindrome word', icon: '🔄', requirement: 1, type: 'palindrome', category: 'hidden' },
            'vowel_master': { unlocked: false, name: 'Vowel Master', description: 'Find a word with all 5 vowels', icon: '🅰️', requirement: 1, type: 'vowel_word', category: 'hidden' },
            'no_vowels': { unlocked: false, name: 'Consonant King', description: 'Find a word with no vowels', icon: '🚫', requirement: 1, type: 'no_vowel_word', category: 'hidden' },
            'matrix_mode': { unlocked: false, name: 'Neo', description: 'Use Matrix effect during gameplay', icon: '🕶️', requirement: 1, type: 'matrix_play', category: 'hidden' },

            // Additional Long-term Achievements
            'games_200': { unlocked: false, name: 'Bicentennial', description: 'Play 200 games', icon: '🎊', requirement: 200, type: 'games', category: 'long-term' },
            'games_500': { unlocked: false, name: 'Half Millennium', description: 'Play 500 games', icon: '🏰', requirement: 500, type: 'games', category: 'long-term' },
            'games_1000': { unlocked: false, name: 'Millennium Master', description: 'Play 1000 games', icon: '👑', requirement: 1000, type: 'games', category: 'long-term' },
            'words_total_2000': { unlocked: false, name: 'Word Collector', description: 'Find 2000 words total', icon: '📚', requirement: 2000, type: 'words_total', category: 'long-term' },
            'words_total_5000': { unlocked: false, name: 'Lexicon Master', description: 'Find 5000 words total', icon: '📖', requirement: 5000, type: 'words_total', category: 'long-term' },
            'words_total_10000': { unlocked: false, name: 'Dictionary God', description: 'Find 10000 words total', icon: '📜', requirement: 10000, type: 'words_total', category: 'long-term' },
            'daily_player': { unlocked: false, name: 'Daily Player', description: 'Play for 7 consecutive days', icon: '📅', requirement: 7, type: 'daily_streak', category: 'long-term' },
            'weekly_warrior': { unlocked: false, name: 'Weekly Warrior', description: 'Play for 30 consecutive days', icon: '🗓️', requirement: 30, type: 'daily_streak', category: 'long-term' },
            'monthly_master': { unlocked: false, name: 'Monthly Master', description: 'Play for 100 consecutive days', icon: '📆', requirement: 100, type: 'daily_streak', category: 'long-term' },
            'effect_master': { unlocked: false, name: 'Effect Master', description: 'Use 20 different customize effects', icon: '🎨', requirement: 20, type: 'customize', category: 'long-term' },
            'background_artist': { unlocked: false, name: 'Background Artist', description: 'Try all background themes', icon: '🖼️', requirement: 11, type: 'backgrounds', category: 'long-term' },
            'score_accumulator': { unlocked: false, name: 'Score Accumulator', description: 'Reach 50000 total score', icon: '💰', requirement: 50000, type: 'total_score', category: 'long-term' },
            'score_millionaire': { unlocked: false, name: 'Score Millionaire', description: 'Reach 100000 total score', icon: '💎', requirement: 100000, type: 'total_score', category: 'long-term' },

            // Additional Skill-based Achievements
            'score_5000': { unlocked: false, name: 'Legendary Player', description: 'Score 5000 points in a game', icon: '🌟', requirement: 5000, type: 'score', category: 'skill' },
            'score_10000': { unlocked: false, name: 'Godlike Player', description: 'Score 10000 points in a game', icon: '⚡', requirement: 10000, type: 'score', category: 'skill' },
            'words_40': { unlocked: false, name: 'Word Sage', description: 'Find 40 words in a single game', icon: '🧠', requirement: 40, type: 'words_single', category: 'skill' },
            'words_50': { unlocked: false, name: 'Word Genius', description: 'Find 50 words in a single game', icon: '🎓', requirement: 50, type: 'words_single', category: 'skill' },
            'speed_master': { unlocked: false, name: 'Speed Master', description: 'Find 15 words in under 90 seconds', icon: '🏃', requirement: 15, type: 'speed', category: 'skill' },
            'flash_finder': { unlocked: false, name: 'Flash Finder', description: 'Find 3 words in under 10 seconds', icon: '⚡', requirement: 3, type: 'speed_burst', category: 'skill' },
            'combo_master': { unlocked: false, name: 'Combo Master', description: 'Find 5 words in a row without mistakes', icon: '🔥', requirement: 5, type: 'combo', category: 'skill' },
            'streak_legend': { unlocked: false, name: 'Streak Legend', description: 'Find 10 words in a row without mistakes', icon: '🌟', requirement: 10, type: 'combo', category: 'skill' },
            'efficiency_expert': { unlocked: false, name: 'Efficiency Expert', description: 'Score 2000+ points with under 15 words', icon: '🎯', requirement: 1, type: 'efficiency', category: 'skill' },
            'word_length_master': { unlocked: false, name: 'Length Master', description: 'Find words of every length (3-10+)', icon: '📏', requirement: 8, type: 'word_variety', category: 'skill' },
            'no_mistakes': { unlocked: false, name: 'Perfectionist', description: 'Complete a game without any invalid words', icon: '✨', requirement: 1, type: 'perfect_accuracy', category: 'skill' },
            'quick_start': { unlocked: false, name: 'Quick Start', description: 'Find first word within 5 seconds', icon: '🚀', requirement: 1, type: 'quick_start', category: 'skill' },
            'endurance_runner': { unlocked: false, name: 'Endurance Runner', description: 'Play for full 80 seconds in timed mode', icon: '⏱️', requirement: 1, type: 'endurance', category: 'skill' },

            // Additional Hidden Achievements
            'weekend_warrior': { unlocked: false, name: 'Weekend Warrior', description: 'Play on both Saturday and Sunday', icon: '🏖️', requirement: 1, type: 'weekend', category: 'hidden' },
            'holiday_player': { unlocked: false, name: 'Holiday Player', description: 'Play on a major holiday', icon: '🎄', requirement: 1, type: 'holiday', category: 'hidden' },
            'midnight_gamer': { unlocked: false, name: 'Midnight Gamer', description: 'Play exactly at midnight', icon: '🕛', requirement: 1, type: 'exact_time', category: 'hidden' },
            'lucky_seven': { unlocked: false, name: 'Lucky Seven', description: 'Score exactly 777 points', icon: '🍀', requirement: 777, type: 'exact_score', category: 'hidden' },
            'double_trouble': { unlocked: false, name: 'Double Trouble', description: 'Find two identical words in one game', icon: '👥', requirement: 1, type: 'duplicate_words', category: 'hidden' },
            'alphabet_soup': { unlocked: false, name: 'Alphabet Soup', description: 'Find words starting with 10 different letters', icon: '🔤', requirement: 10, type: 'alphabet_variety', category: 'hidden' },
            'reverse_psychology': { unlocked: false, name: 'Reverse Psychology', description: 'Find a word backwards', icon: '🔄', requirement: 1, type: 'reverse_word', category: 'hidden' },
            'theme_master': { unlocked: false, name: 'Theme Master', description: 'Use every background theme in one session', icon: '🎨', requirement: 1, type: 'theme_session', category: 'hidden' },
            'secret_sequence': { unlocked: false, name: 'Secret Sequence', description: 'Find words in alphabetical order', icon: '🔢', requirement: 1, type: 'alphabetical', category: 'hidden' },
            'color_blind': { unlocked: false, name: 'Color Blind', description: 'Play with 5 different visual effects active', icon: '🌈', requirement: 5, type: 'multi_effects', category: 'hidden' },
            'minimalist': { unlocked: false, name: 'Minimalist', description: 'Score 1000+ with only 3-letter words', icon: '🎯', requirement: 1, type: 'minimalist', category: 'hidden' },
            'maximalist': { unlocked: false, name: 'Maximalist', description: 'Find only 6+ letter words in a game', icon: '📏', requirement: 1, type: 'maximalist', category: 'hidden' },
            'grid_explorer': { unlocked: false, name: 'Grid Explorer', description: 'Use every tile on the grid in one game', icon: '🗺️', requirement: 1, type: 'full_grid', category: 'hidden' },
            'corner_master': { unlocked: false, name: 'Corner Master', description: 'Find words using all 4 corner tiles', icon: '📐', requirement: 1, type: 'corners', category: 'hidden' },
            'center_stage': { unlocked: false, name: 'Center Stage', description: 'Find 5 words all using the center tile', icon: '🎯', requirement: 5, type: 'center_tile', category: 'hidden' },
            'border_patrol': { unlocked: false, name: 'Border Patrol', description: 'Find words using only edge tiles', icon: '🔲', requirement: 1, type: 'edge_only', category: 'hidden' },
            'snake_charmer': { unlocked: false, name: 'Snake Charmer', description: 'Find a word that zigzags across the grid', icon: '🐍', requirement: 1, type: 'zigzag', category: 'hidden' },
            'time_traveler': { unlocked: false, name: 'Time Traveler', description: 'Play in both timed and unlimited modes', icon: '⏰', requirement: 1, type: 'mode_variety', category: 'hidden' },
            'size_matters': { unlocked: false, name: 'Size Matters', description: 'Play on both 4x4 and 5x5 grids', icon: '📏', requirement: 1, type: 'grid_variety', category: 'hidden' },
            'easter_egg': { unlocked: false, name: 'Easter Egg', description: 'Find the hidden word "EASTER"', icon: '🥚', requirement: 1, type: 'easter_word', category: 'hidden' },

            // Daily Challenge Achievements
            'daily_debut': { unlocked: false, name: 'Daily Debut', description: 'Complete your first daily challenge', icon: '📅', requirement: 1, type: 'daily_challenge', category: 'long-term' },
            'streak_starter': { unlocked: false, name: 'Streak Starter', description: 'Complete 3 daily challenges in a row', icon: '🔥', requirement: 3, type: 'daily_streak', category: 'long-term' },
            'weekly_champion': { unlocked: false, name: 'Weekly Champion', description: 'Complete 7 daily challenges in a row', icon: '⭐', requirement: 7, type: 'daily_streak', category: 'long-term' },
            'monthly_legend': { unlocked: false, name: 'Monthly Legend', description: 'Complete 30 daily challenges in a row', icon: '💎', requirement: 30, type: 'daily_streak', category: 'long-term' },
            'century_streak': { unlocked: false, name: 'Century Streak', description: 'Complete 100 daily challenges in a row', icon: '👑', requirement: 100, type: 'daily_streak', category: 'long-term' },
            'daily_perfectionist': { unlocked: false, name: 'Daily Perfectionist', description: 'Score 2000+ points in a daily challenge', icon: '🎯', requirement: 2000, type: 'daily_score', category: 'skill' },
            'daily_champion': { unlocked: false, name: 'Daily Champion', description: 'Rank #1 in a daily challenge', icon: '🥇', requirement: 1, type: 'daily_rank', category: 'skill' },
            'daily_podium': { unlocked: false, name: 'Daily Podium', description: 'Rank in top 3 of a daily challenge', icon: '🏆', requirement: 3, type: 'daily_rank', category: 'skill' },

            // Power-up Achievements
            'power_collector': { unlocked: false, name: 'Power Collector', description: 'Collect your first power-up', icon: '⚡', requirement: 1, type: 'powerup_collected', category: 'hidden' },
            'power_hoarder': { unlocked: false, name: 'Power Hoarder', description: 'Collect 10 power-ups', icon: '🔋', requirement: 10, type: 'powerup_collected', category: 'long-term' },
            'time_master': { unlocked: false, name: 'Time Master', description: 'Use a Time Freeze power-up', icon: '❄️', requirement: 1, type: 'powerup_used', category: 'hidden' },
            'multiplier_madness': { unlocked: false, name: 'Multiplier Madness', description: 'Use a point multiplier power-up', icon: '✨', requirement: 1, type: 'powerup_used', category: 'hidden' },
            'power_combo': { unlocked: false, name: 'Power Combo', description: 'Have 3 power-ups active at once', icon: '🌟', requirement: 3, type: 'powerup_combo', category: 'skill' },
            'lucky_finder': { unlocked: false, name: 'Lucky Finder', description: 'Find an epic rarity power-up', icon: '🍀', requirement: 1, type: 'powerup_rarity', category: 'hidden' }
        };

        // Achievement tracking variables
        let customizeEffectsUsed = new Set();
        let backgroundsUsed = new Set();
        let gameStartTime = 0;
        let wordsFoundInTime = 0;
        let matrixModeActive = false;
        let currentStreak = 0;
        let invalidWordCount = 0;
        let firstWordTime = 0;
        let tilesUsed = new Set();
        let lastPlayDate = null;
        let consecutiveDays = 0;
        let sessionBackgrounds = new Set();
        let activeEffectsCount = 0;

        function getHighScoreKey(mode, boardSize) {
            if (mode === GAME_MODE.TIMED) {
                return boardSize === BOARD_SIZE.SMALL ? HIGH_SCORES_KEY_TIMED_4X4 : HIGH_SCORES_KEY_TIMED_5X5;
            } else {
                return boardSize === BOARD_SIZE.SMALL ? HIGH_SCORES_KEY_UNLIMITED_4X4 : HIGH_SCORES_KEY_UNLIMITED_5X5;
            }
        }

        // Secret menu variables
        let secretCode = '';
        let secretCodeTimeout;
        let secretDotClicks = 0;
        let secretDotClickTimeout;
        let secretTouchSequence = [];
        let secretTouchTimeout;
        const REQUIRED_DOT_CLICKS = 5; // Reduced from 7 to 5
        const SECRET_TOUCH_PATTERN = ['top-left', 'top-right', 'bottom-right']; // Simplified touch pattern
        const SECRET_COMMANDS = {
            'GODMODE': enableGodMode,
            'ALLWORDS': showAllWordsCheat,
            'EXTRATIME': addExtraTime,
            'BIGPOINTS': enableBigPointsMode,
            'SLOWTIME': enableSlowTimeMode,
            'SHUFFLE': shuffleGrid,
            'ENDGAME': endGameCommand,
            'FREEZE': freezeTimer,
            'BOOST': scoreBoost,
            'HINT': showHint,
            'LUCKY': luckyGrid,
            'RESET': resetScore,
            'DOUBLE': doublePoints,
            'REVEAL': revealWord,
            'SPEED': speedMode,
            'INFINITE': infiniteTime,
            'VOWELS': vowelGrid,
            'MEGA': megaPoints,
            'GHOST': ghostMode,
            'MATRIX': matrixRain,
            'TELEPORT': teleportTiles,
            'QUANTUM': quantumGrid,
            'LASER': laserMode,
            'PORTAL': portalEffect,
            'CHAOS': chaosMode,
            'REMOVE_ALL_SECRET': removeAllSecretEffects
        };

        // Customize menu effects
        const CUSTOMIZE_EFFECTS = {
            'RAINBOW': enableRainbowMode,
            'DARKMODE': toggleDarkMode,
            'CONFETTI': triggerConfetti,
            'FLASH': flashMode,
            'ZOOM': zoomMode,
            'SPIN': spinGrid,
            'SHAKE': shakeGrid,
            'GLOW': glowMode,
            'MAGIC': magicGrid,
            'MATRIX': enableMatrixMode,
            'NEON': neonMode,
            'RETRO': retroMode,
            'SNOW': snowEffect,
            'FIRE': fireEffect,
            'BUBBLE': bubbleMode,
            'PULSE': pulseMode,
            'GRADIENT': gradientMode,
            'MIRROR': mirrorMode,
            'WAVE': waveEffect,
            'BG_BLUE': setBlueBackground,
            'BG_PURPLE': setPurpleBackground,
            'BG_GREEN': setGreenBackground,
            'BG_SUNSET': setSunsetBackground,
            'BG_OCEAN': setOceanBackground,
            'BG_FOREST': setForestBackground,
            'BG_SPACE': setSpaceBackground,
            'BG_RAINBOW': setRainbowBackground,
            'BG_DOTS': setDotsPattern,
            'BG_STRIPES': setStripesPattern,
            'BG_WAVES': setWavesPattern,
            'BG_RESET': resetBackground,
            'DISCO': discoMode,
            'HOLOGRAM': hologramEffect,
            'CYBERPUNK': cyberpunkTheme,
            'VINTAGE': vintageFilter,
            'GLITCH': glitchEffect,
            'AURORA': auroraEffect,
            'CRYSTAL': crystalTheme,
            'LAVA': lavaEffect,
            'ELECTRIC': electricEffect,
            'COSMIC': cosmicTheme,
            'REMOVE_ALL_CUSTOMIZE': removeAllCustomizeEffects,
            'ACHIEVEMENTS': openAchievementsMenu,
            'ANALYTICS': openAnalyticsMenu
        };
        let godModeEnabled = false;
        let rainbowModeEnabled = false;
        let bigPointsModeEnabled = false;
        let slowTimeEnabled = false;
        let darkModeEnabled = false;
        let matrixModeEnabled = false;

        // Load high scores from localStorage
        function loadHighScores() {
            try {
                const key = getHighScoreKey(currentGameMode, currentBoardSize);
                const savedScores = localStorage.getItem(key);
                if (savedScores) {
                    highScores = JSON.parse(savedScores);
                    console.log(`Loaded ${currentGameMode} ${currentBoardSize}x${currentBoardSize} high scores:`, highScores);
                } else {
                    highScores = [];
                    console.log(`No saved ${currentGameMode} ${currentBoardSize}x${currentBoardSize} high scores found`);
                }
            } catch (error) {
                console.error("Error loading high scores:", error);
                highScores = [];
            }
        }

        // Save high scores to localStorage
        function saveHighScores() {
            try {
                const key = getHighScoreKey(currentGameMode, currentBoardSize);
                localStorage.setItem(key, JSON.stringify(highScores));
                console.log(`Saved ${currentGameMode} ${currentBoardSize}x${currentBoardSize} high scores:`, highScores);
            } catch (error) {
                console.error("Error saving high scores:", error);
            }
        }

        // Update high scores with current score
        function updateHighScores() {
            // Don't save scores to leaderboard if secret commands were used
            if (secretCommandsUsed) {
                console.log("Score not saved to leaderboard: secret commands were used during this game");

                // Show a notification to inform the player
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 bg-orange-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-500';
                notification.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="text-xl">🚫</span>
                        <div>
                            <div class="font-bold">Score Not Saved</div>
                            <div class="text-sm opacity-90">Secret commands were used</div>
                        </div>
                    </div>
                `;

                document.body.appendChild(notification);

                // Animate in
                setTimeout(() => {
                    notification.classList.remove('translate-x-full');
                }, 100);

                // Auto-hide after 4 seconds
                setTimeout(() => {
                    notification.classList.add('translate-x-full');
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 500);
                }, 4000);

                // Still update the display to show current leaderboard
                displayHighScores();
                return;
            }

            // Create a new score entry
            const newScore = {
                score: score,
                date: new Date().toISOString(),
                words: foundWords.size
            };

            // Add the new score to the array
            highScores.push(newScore);

            // Sort by score (descending)
            highScores.sort((a, b) => b.score - a.score);

            // Keep only the top scores
            highScores = highScores.slice(0, MAX_HIGH_SCORES);

            // Save to localStorage
            saveHighScores();

            // Update the display
            displayHighScores();
        }

        // Display high scores in the modal
        function displayHighScores() {
            const highScoresList = document.getElementById('high-scores-list');
            if (!highScoresList) return;
            
            highScoresList.innerHTML = '';
            
            // Add game mode indicator
            const modeIndicator = document.createElement('div');
            modeIndicator.className = 'mb-2 text-center';
            modeIndicator.innerHTML = `
                <span class="inline-block px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-xs font-medium">
                    ${currentGameMode === GAME_MODE.TIMED ? 'Timed Mode' : 'Unlimited Mode'} High Scores
                </span>
            `;
            highScoresList.appendChild(modeIndicator);
            
            if (highScores.length === 0) {
                highScoresList.innerHTML += '<div class="text-center py-2 text-gray-500">No high scores yet</div>';
                return;
            }
            
            // Add each high score
            highScores.forEach((scoreData, index) => {
                const scoreRow = document.createElement('div');
                scoreRow.className = 'flex justify-between items-center py-1 border-b border-gray-200';
                
                // Add medal emoji for top 3
                let rankDisplay = `${index + 1}.`;
                if (index === 0) rankDisplay = '🥇 ' + rankDisplay;
                else if (index === 1) rankDisplay = '🥈 ' + rankDisplay;
                else if (index === 2) rankDisplay = '🥉 ' + rankDisplay;
                
                // Format date
                const scoreDate = new Date(scoreData.date);
                const dateStr = scoreDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
                
                // Highlight if this is the current score
                const isCurrentScore = scoreData.score === score && 
                                      scoreData.words === foundWords.size && 
                                      new Date().getTime() - scoreDate.getTime() < 60000; // Within the last minute
                
                if (isCurrentScore) {
                    scoreRow.className += ' bg-blue-50';
                }
                
                scoreRow.innerHTML = `
                    <span class="font-medium">${rankDisplay} <span class="text-gray-600">${dateStr}</span></span>
                    <span class="font-bold ${isCurrentScore ? 'text-blue-600' : ''}">${scoreData.score} <span class="text-sm font-normal">(${scoreData.words} words)</span></span>
                `;
                
                highScoresList.appendChild(scoreRow);
            });
        }

        function showOpeningUI() {
            document.getElementById('opening-ui').classList.remove('hidden');
            document.getElementById('game-container').classList.add('hidden');

            // Load and display leaderboard
            displayOpeningLeaderboard();
        }

        function hideOpeningUI() {
            document.getElementById('opening-ui').classList.add('hidden');
            document.getElementById('game-container').classList.remove('hidden');
        }

        function startGame(mode) {
            // Ensure we don't accidentally set DAILY_CHALLENGE mode in regular games
            if (mode === GAME_MODE.DAILY_CHALLENGE) {
                mode = GAME_MODE.TIMED;
            }

            currentGameMode = mode;
            GRID_SIZE = currentBoardSize; // Use selected board size

            // Reset daily challenge state for regular games
            isDailyChallenge = false;
            currentChallengeId = null;

            hideOpeningUI();
            updateGridLayout();
            init();
        }

        function updateGridLayout() {
            const gridContainer = document.getElementById('grid-container');
            const gridSizeIndicator = document.getElementById('current-grid-size');
            const gridSizeBadge = document.getElementById('grid-size-badge');

            if (gridContainer) {
                // Remove existing grid classes
                gridContainer.classList.remove('grid-cols-4', 'grid-cols-5', 'gap-3', 'gap-4', 'md:gap-4', 'md:gap-5', 'max-w-xs', 'max-w-sm', 'max-w-md');

                // Add appropriate grid class and spacing
                gridContainer.classList.add(`grid-cols-${GRID_SIZE}`);

                if (GRID_SIZE === 5) {
                    // 5x5 grid: larger container, slightly smaller gaps to fit
                    gridContainer.classList.add('gap-3', 'md:gap-4', 'max-w-sm');
                } else {
                    // 4x4 grid: original spacing with generous gaps
                    gridContainer.classList.add('gap-4', 'md:gap-5', 'max-w-xs');
                }
            }

            // Update grid size indicators
            const sizeText = `${GRID_SIZE}×${GRID_SIZE}`;
            const modeText = GRID_SIZE === 4 ? 'CLASSIC' : 'CHALLENGE';

            if (gridSizeIndicator) {
                gridSizeIndicator.textContent = `${sizeText} GRID • ${modeText}`;
            }

            if (gridSizeBadge) {
                gridSizeBadge.textContent = sizeText;
                // Change badge color based on grid size
                if (GRID_SIZE === 5) {
                    gridSizeBadge.classList.remove('bg-purple-600');
                    gridSizeBadge.classList.add('bg-orange-600');
                } else {
                    gridSizeBadge.classList.remove('bg-orange-600');
                    gridSizeBadge.classList.add('bg-purple-600');
                }
            }
        }

        function displayOpeningLeaderboard() {
            const leaderboardEl = document.getElementById('opening-leaderboard');

            // Determine current mode from active tab
            let currentMode = GAME_MODE.TIMED; // Default
            if (document.getElementById('leaderboard-timed-tab').classList.contains('text-blue-600')) {
                currentMode = GAME_MODE.TIMED;
            } else if (document.getElementById('leaderboard-unlimited-tab').classList.contains('text-blue-600')) {
                currentMode = GAME_MODE.UNLIMITED;
            }

            leaderboardEl.innerHTML = '';

            // For Timed and Unlimited modes, show both board sizes
            const boardSizes = [BOARD_SIZE.SMALL, BOARD_SIZE.LARGE];

            boardSizes.forEach(boardSize => {
                const key = getHighScoreKey(currentMode, boardSize);
                let scores = [];
                try {
                    const savedScores = localStorage.getItem(key);
                    if (savedScores) {
                        scores = JSON.parse(savedScores);
                    }
                } catch (error) {
                    console.error("Error loading scores:", error);
                }

                // Create section for this board size
                const sectionTitle = document.createElement('div');
                sectionTitle.className = 'flex items-center justify-between mb-2 mt-4 first:mt-0';

                const titleText = document.createElement('span');
                titleText.className = 'text-sm font-semibold text-gray-700';
                titleText.textContent = `${boardSize}×${boardSize} Grid`;

                const badge = document.createElement('span');
                badge.className = `text-xs font-bold px-2 py-1 rounded-full text-white ${boardSize === 4 ? 'bg-purple-500' : 'bg-orange-500'}`;
                badge.textContent = boardSize === 4 ? 'CLASSIC' : 'CHALLENGE';

                sectionTitle.appendChild(titleText);
                sectionTitle.appendChild(badge);
                leaderboardEl.appendChild(sectionTitle);

                if (scores.length === 0) {
                    const noScores = document.createElement('div');
                    noScores.className = 'text-center py-2 text-gray-500 text-sm';
                    noScores.textContent = 'No scores yet';
                    leaderboardEl.appendChild(noScores);
                    return;
                }

                scores.slice(0, 3).forEach((scoreData, index) => {
                    const scoreRow = document.createElement('div');
                    scoreRow.className = 'flex justify-between items-center py-2 px-3 bg-gray-50 rounded-lg mb-1';

                    let rankDisplay = `${index + 1}.`;
                    if (index === 0) rankDisplay = '🥇';
                    else if (index === 1) rankDisplay = '🥈';
                    else if (index === 2) rankDisplay = '🥉';

                    const scoreDate = new Date(scoreData.date);
                    const dateStr = scoreDate.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });

                    scoreRow.innerHTML = `
                        <span class="font-medium text-sm">${rankDisplay} <span class="text-gray-600 text-xs">${dateStr}</span></span>
                        <span class="font-bold text-blue-600 text-sm">${scoreData.score} <span class="text-xs font-normal text-gray-500">(${scoreData.words}w)</span></span>
                    `;

                    leaderboardEl.appendChild(scoreRow);
                });
            });
        }

        function init() {
            // Reset game state
            score = 0;
            timer = GAME_TIME;
            foundWords = new Set();
            currentPath = [];

            // Reset achievement tracking variables
            gameStartTime = Date.now();
            wordsFoundInTime = 0;
            currentStreak = 0;
            invalidWordCount = 0;
            firstWordTime = 0;
            tilesUsed.clear();
            sessionBackgrounds.clear();
            activeEffectsCount = 0;

            // Reset power-up state
            powerupSpawns.clear();
            activePowerups.clear();
            powerupEffects = {
                timeFreeze: false,
                pointMultiplier: 1,
                wordMagnet: false
            };

            // Update power-up inventory display
            updatePowerupInventoryDisplay();

            // Clear word search cache for new grid
            wordSearchCache.gridHash = null;
            wordSearchCache.words = null;

            // Check time-based achievements
            checkAchievements(['time']);

            // Update UI elements
            const scoreEl = document.getElementById('score');
            if (scoreEl) scoreEl.textContent = '0';

            // Update timer display based on game mode
            const timerDisplayEl = document.getElementById('timer-display');
            if (timerDisplayEl) {
                if (currentGameMode === GAME_MODE.TIMED) {
                    updateTimerDisplay();
                } else {
                    timerDisplayEl.textContent = "End Game";
                    timerDisplayEl.classList.add('bg-red-500', 'hover:bg-red-600', 'cursor-pointer');
                    timerDisplayEl.title = "Click to end the game";
                }
            }

            const wordCountEl = document.getElementById('word-count');
            if (wordCountEl) wordCountEl.textContent = '0';

            const currentWordDisplayEl = document.getElementById('current-word-display');
            if (currentWordDisplayEl) {
                currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
            }

            // Hide game over modal
            const gameOverModal = document.getElementById('game-over-modal');
            if (gameOverModal) {
                gameOverModal.classList.add('hidden');
                const modalContent = gameOverModal.querySelector('div');
                if (modalContent) {
                    modalContent.classList.add('scale-95', 'opacity-0');
                }
            }

            // Generate and render the grid
            generateGrid();
            renderGrid();

            // Start the timer and add event listeners
            if (currentGameMode === GAME_MODE.TIMED) {
                startTimer();
            } else {
                // For unlimited mode, just show "--:--" in the timer
                const timerDisplayEl = document.getElementById('timer-display');
                if (timerDisplayEl) {
                    timerDisplayEl.textContent = "END GAME";
                }
            }

            addEventListeners();

            console.log(`Game initialized in ${currentGameMode} mode with grid:`, grid);
        }

        function generateGrid() {
            grid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                const row = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    const randomIndex = Math.floor(Math.random() * LETTER_DISTRIBUTION.length);
                    const randomLetter = LETTER_DISTRIBUTION[randomIndex];
                    row.push(randomLetter);
                }
                grid.push(row);
            }
            console.log("Generated grid:", grid);
        }

        function renderGrid() {
            const gridContainer = document.getElementById('grid-container');
            if (!gridContainer) {
                console.error("Grid container not found!");
                return;
            }

            gridContainer.innerHTML = '';

            grid.forEach((row, rowIndex) => {
                row.forEach((letter, colIndex) => {
                    const tile = document.createElement('div');
                    tile.textContent = letter;
                    tile.dataset.row = rowIndex;
                    tile.dataset.col = colIndex;

                    // Use original tile styling with appropriate text size for grid size
                    if (GRID_SIZE === 5) {
                        tile.classList.add('tile', 'flex', 'items-center', 'justify-center', 'text-xl', 'md:text-2xl', 'font-bold', 'rounded-md', 'cursor-pointer');
                    } else {
                        tile.classList.add('tile', 'flex', 'items-center', 'justify-center', 'text-2xl', 'md:text-3xl', 'font-bold', 'rounded-md', 'cursor-pointer');
                    }

                    gridContainer.appendChild(tile);
                });
            });

            console.log("Grid rendered with", gridContainer.children.length, "tiles");
        }
        
        function addEventListeners() {
            const events = [
                ['mousedown', handleInteractionStart],
                ['mouseup', handleInteractionEnd],
                ['mouseover', handleInteractionMove],
                ['touchstart', handleInteractionStart, { passive: false }],
                ['touchend', handleInteractionEnd],
                ['touchmove', handleInteractionMove, { passive: false }]
            ];
            
            // Cleanup previous listeners
            events.forEach(([event, handler, options]) => {
                const target = ['mouseup', 'touchend'].includes(event) ? document : gridContainer;
                target.removeEventListener(event, handler, options);
            });
            
            // Add new listeners
            events.forEach(([event, handler, options]) => {
                const target = ['mouseup', 'touchend'].includes(event) ? document : gridContainer;
                target.addEventListener(event, handler, options);
            });
        }
        
        function updateTimerDisplay() {
            const timerDisplayEl = document.getElementById('timer-display');
            if (!timerDisplayEl) {
                console.error("Timer display element not found!");
                return;
            }
            
            const minutes = Math.floor(timer / 60).toString().padStart(2, '0');
            const seconds = (timer % 60).toString().padStart(2, '0');
            timerDisplayEl.textContent = `${minutes}:${seconds}`;
            console.log("Timer updated:", timerDisplayEl.textContent);
        }

        function startTimer() {
            clearInterval(timerInterval);
            updateTimerDisplay(); // Update immediately

            timerInterval = setInterval(() => {
                // Check if time freeze is active
                if (!powerupEffects.timeFreeze) {
                    timer--;
                    updateTimerDisplay();

                    if (timer <= 0) {
                        clearInterval(timerInterval);
                        endGame();
                    } else if (timer === 20 && foundWords.size < 3) {
                        // Show time pressure hint if user hasn't found many words
                        showContextualHint('time_pressure');
                    }
                } else {
                    // Time is frozen, just update display to show freeze effect
                    updateTimerDisplay();
                }
            }, 1000);

            console.log("Timer started with", timer, "seconds");
        }

        // End the game
        function endGame() {
            // Clear the timer interval
            clearInterval(timerInterval);

            // Calculate game duration
            const gameEndTime = Date.now();
            const gameDuration = (gameEndTime - gameStartTime) / 1000; // in seconds

            // Prepare analytics data
            const wordsArray = Array.from(foundWords);
            const sessionData = {
                score: score,
                wordsFound: foundWords.size,
                gameTime: gameDuration,
                words: wordsArray,
                averageWordLength: wordsArray.length > 0 ? wordsArray.reduce((sum, word) => sum + word.length, 0) / wordsArray.length : 0,
                longestWord: wordsArray.length > 0 ? Math.max(...wordsArray.map(w => w.length)) : 0,
                shortestWord: wordsArray.length > 0 ? Math.min(...wordsArray.map(w => w.length)) : 0,
                wordsPerMinute: wordsArray.length > 0 ? (wordsArray.length / (gameDuration / 60)) : 0,
                scorePerWord: wordsArray.length > 0 ? score / wordsArray.length : 0,
                uniqueLettersUsed: tilesUsed.size,
                gridCoverage: (tilesUsed.size / (GRID_SIZE * GRID_SIZE)) * 100,
                powerupsUsed: Array.from(powerupInventory.values()).reduce((sum, count) => sum + count, 0),
                achievementsUnlocked: 0 // Will be updated if achievements are unlocked
            };

            // Track analytics data (but not for daily challenges to keep them competitive)
            if (!isDailyChallenge) {
                trackGameSession(sessionData);
            }

            // Update statistics for achievements
            gamesPlayed++;
            totalScore += score;
            totalWordsFound += foundWords.size;
            if (score > bestScore) {
                bestScore = score;
            }

            // Handle daily challenge completion
            // Safety check: if currentGameMode is DAILY_CHALLENGE but isDailyChallenge is false, reset it
            if (currentGameMode === GAME_MODE.DAILY_CHALLENGE && !isDailyChallenge) {
                currentGameMode = GAME_MODE.TIMED;
            }

            if (isDailyChallenge) {
                completeDailyChallenge();
                return;
            }

            // Check achievements (comprehensive check at game end)
            checkAchievements(['games', 'perfect', 'words_single', 'words_total']);

            // Show contextual hints based on game performance
            if (score < 500 && foundWords.size < 5) {
                setTimeout(() => showContextualHint('low_score'), 2000);
            } else if (foundWords.size < 3) {
                setTimeout(() => showContextualHint('few_words'), 2000);
            }

            // Update the final score
            const finalScoreEl = document.getElementById('final-score');
            if (finalScoreEl) {
                finalScoreEl.textContent = score;
            }
            
            // Update the game over title based on game mode
            const gameOverTitle = document.getElementById('game-over-title');
            if (gameOverTitle) {
                gameOverTitle.textContent = currentGameMode === GAME_MODE.TIMED ? "Time's Up!" : "Game Over!";
            }
            
            // Update high scores
            updateHighScores();
            
            // Reset the all possible words section
            const allPossibleWordsSection = document.getElementById('all-possible-words');
            if (allPossibleWordsSection) {
                allPossibleWordsSection.classList.add('hidden');
            }
            
            // Show the game over modal
            const gameOverModal = document.getElementById('game-over-modal');
            if (gameOverModal) {
                // Update the high scores section title to include mode
                const highScoresTitle = gameOverModal.querySelector('h3');
                if (highScoresTitle) {
                    highScoresTitle.textContent = `High Scores (${currentGameMode === GAME_MODE.TIMED ? 'Timed Mode' : 'Unlimited Mode'})`;
                }
                
                // Add mode switching tabs if they don't exist
                if (!gameOverModal.querySelector('.mode-tabs')) {
                    const highScoresSection = gameOverModal.querySelector('.mb-6.bg-gray-50.p-4.rounded-lg');
                    if (highScoresSection) {
                        const modeTabs = document.createElement('div');
                        modeTabs.className = 'mode-tabs flex mb-3 border-b border-gray-200';
                        modeTabs.innerHTML = `
                            <button class="flex-1 py-2 px-3 text-sm font-medium ${currentGameMode === GAME_MODE.TIMED ? 'text-blue-600 border-b-2 border-blue-500' : 'text-gray-500 hover:text-gray-700'}" data-mode="timed">
                                Timed Mode
                            </button>
                            <button class="flex-1 py-2 px-3 text-sm font-medium ${currentGameMode === GAME_MODE.UNLIMITED ? 'text-blue-600 border-b-2 border-blue-500' : 'text-gray-500 hover:text-gray-700'}" data-mode="unlimited">
                                Unlimited Mode
                            </button>
                        `;
                        
                        // Insert tabs before the high scores list
                        highScoresSection.insertBefore(modeTabs, highScoresSection.querySelector('h3'));
                        
                        // Add event listeners to the tabs
                        modeTabs.querySelectorAll('button').forEach(tab => {
                            tab.addEventListener('click', () => {
                                const mode = tab.getAttribute('data-mode');
                                
                                // Update active tab styling
                                modeTabs.querySelectorAll('button').forEach(t => {
                                    t.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                                    t.classList.add('text-gray-500', 'hover:text-gray-700');
                                });
                                tab.classList.remove('text-gray-500', 'hover:text-gray-700');
                                tab.classList.add('text-blue-600', 'border-b-2', 'border-blue-500');
                                
                                // Load and display high scores for the selected mode
                                const tempCurrentMode = currentGameMode;
                                currentGameMode = mode === 'timed' ? GAME_MODE.TIMED : GAME_MODE.UNLIMITED;
                                loadHighScores();
                                displayHighScores();
                                
                                // Update the high scores section title
                                const highScoresTitle = highScoresSection.querySelector('h3');
                                if (highScoresTitle) {
                                    highScoresTitle.textContent = `High Scores (${currentGameMode === GAME_MODE.TIMED ? 'Timed Mode' : 'Unlimited Mode'})`;
                                }
                                
                                // Restore the actual current mode (for when the game restarts)
                                currentGameMode = tempCurrentMode;
                            });
                        });
                    }
                } else {
                    // Update active tab styling
                    const modeTabs = gameOverModal.querySelector('.mode-tabs');
                    if (modeTabs) {
                        modeTabs.querySelectorAll('button').forEach(tab => {
                            const mode = tab.getAttribute('data-mode');
                            if ((mode === 'timed' && currentGameMode === GAME_MODE.TIMED) || 
                                (mode === 'unlimited' && currentGameMode === GAME_MODE.UNLIMITED)) {
                                tab.classList.remove('text-gray-500', 'hover:text-gray-700');
                                tab.classList.add('text-blue-600', 'border-b-2', 'border-blue-500');
                            } else {
                                tab.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                                tab.classList.add('text-gray-500', 'hover:text-gray-700');
                            }
                        });
                    }
                }

                gameOverModal.classList.remove('hidden');

                // Animate the modal
                setTimeout(() => {
                    const modalContent = gameOverModal.querySelector('div');
                    if (modalContent) {
                        modalContent.classList.remove('scale-95', 'opacity-0');
                    }
                }, 50);
            }
            
            console.log(`Game ended in ${currentGameMode} mode with score:`, score);
        }

        // Make endGame available globally for console access
        window.endGame = endGame;
        
        function handleInteractionStart(e) {
            e.preventDefault();
            isMouseDown = true;
            const tile = getTileFromEvent(e);
            if (tile) {
                startPath(tile);
            }
        }

        function handleInteractionMove(e) {
            if (!isMouseDown) return;
            e.preventDefault();
            const tile = getTileFromEvent(e);
            if (tile) {
                continuePath(tile);
            }
        }
        
        async function handleInteractionEnd(e) {
            if (!isMouseDown) return;
            isMouseDown = false;
            
            const word = getWordFromPath();
            if (word.length >= 3) {
                // Check word immediately without delay
                await checkWord(word);
            } else {
                // For words shorter than 3 letters, just reset the path
                currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                resetPath();
            }
        }
        
        function getTileFromEvent(e) {
            let target;
            if (e.touches && e.touches.length > 0) {
                const touch = e.touches[0];
                target = document.elementFromPoint(touch.clientX, touch.clientY);
            } else {
                target = e.target;
            }
            return target && target.classList.contains('tile') ? target : null;
        }

        function startPath(tile) {
            currentPath.push({ row: parseInt(tile.dataset.row), col: parseInt(tile.dataset.col) });
            tile.classList.add('selected');
            updateCurrentWord();
        }

        function continuePath(tile) {
            if (currentPath.length === 0) {
                startPath(tile);
                return;
            }
            
            const row = parseInt(tile.dataset.row);
            const col = parseInt(tile.dataset.col);
            
            if (currentPath.some(p => p.row === row && p.col === col)) return;

            const lastTile = currentPath[currentPath.length - 1];
            const isAdjacent = Math.abs(lastTile.row - row) <= 1 && Math.abs(lastTile.col - col) <= 1;

            if (isAdjacent) {
                currentPath.push({ row, col });
                tile.classList.add('selected');
                updateCurrentWord();
            }
        }
        
        function getWordFromPath() {
             return currentPath.map(p => grid[p.row][p.col]).join('');
        }
        
        function calculatePoints(wordLength) {
            if (wordLength === 3) return 100;
            if (wordLength === 4) return 400;
            if (wordLength === 5) return 800;
            if (wordLength === 6) return 1400;
            if (wordLength === 7) return 1800;
            if (wordLength >= 8) return 2200;
            return 0;
        }

        function updateCurrentWord() {
            const word = getWordFromPath();
            if (word) {
                // Don't show points yet, just show the word
                currentWordEl.textContent = word;
                currentWordDisplayEl.classList.remove('opacity-0', 'transform', '-translate-y-2');
            }
        }
        
        function animatePath(animationClass) {
            currentPath.forEach(p => {
                const tile = gridContainer.querySelector(`[data-row='${p.row}'][data-col='${p.col}']`);
                if (tile) {
                    tile.classList.add(animationClass);
                    setTimeout(() => tile.classList.remove(animationClass), 500);
                }
            });
        }

        function resetPath() {
            // Remove the 'selected' class from all tiles
            document.querySelectorAll('.tile.selected').forEach(tile => {
                tile.classList.remove('selected');
            });
            
            // Clear the current path
            currentPath = [];
        }

        async function checkWord(word) {
            // First check if the word has already been found
            if (foundWords.has(word)) {
                // Show the word with 0 points
                currentWordEl.textContent = `${word} (+0)`;
                // Immediately animate and reset
                animatePath('incorrect');
                setTimeout(() => {
                    currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                    resetPath();
                }, 500);
                return;
            }

            // Check if the word is in our dictionary first (faster than API call)
            if (englishWords.has(word)) {
                // Valid word - show points and update score immediately
                const points = calculatePoints(word.length);
                currentWordEl.textContent = `${word} (+${points})`;
                foundWords.add(word);
                updateScore(word);
                animatePath('correct');

                // Check tutorial progress after successful word
                setTimeout(() => {
                    checkTutorialProgress(word);
                    resetPath();
                }, 300);
                return;
            }

            // If not in our dictionary, try the API as a backup
            try {
                const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${word}`);
                if (response.ok) {
                    // Valid word - show points and update score immediately
                    const points = calculatePoints(word.length);
                    currentWordEl.textContent = `${word} (+${points})`;
                    foundWords.add(word);
                    updateScore(word);
                    animatePath('correct');

                    // Check tutorial progress after successful word
                    setTimeout(() => {
                        checkTutorialProgress(word);
                        resetPath();
                    }, 300);
                } else {
                    // Invalid word - show 0 points
                    currentWordEl.textContent = `${word} (+0)`;
                    animatePath('incorrect');

                    // Track invalid words for achievements
                    invalidWordCount++;
                    currentStreak = 0; // Reset streak on invalid word

                    setTimeout(() => {
                        currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                        resetPath();
                    }, 500);
                }
            } catch (error) {
                console.error("Dictionary API error:", error);
                // In case of API error, treat as invalid
                currentWordEl.textContent = `${word} (+0)`;
                animatePath('incorrect');
                setTimeout(() => {
                    currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
                    resetPath();
                }, 500);
            }
        }

        function updateScore(word) {
            // Apply power-up multipliers
            const basePoints = calculatePoints(word.length);
            const multipliedPoints = Math.floor(basePoints * powerupEffects.pointMultiplier);

            score += multipliedPoints;
            scoreEl.textContent = score;
            wordCountEl.textContent = foundWords.size;

            // Check for power-up collection on current path
            currentPath.forEach(pos => {
                if (collectPowerup(pos.row, pos.col)) {
                    // Power-up was collected, no need to continue checking this path
                }
            });

            // Chance to spawn new power-up after finding a word
            if (Math.random() < 0.15) { // 15% chance per word
                spawnPowerup();
            }

            // Track first word time
            if (foundWords.size === 1) {
                firstWordTime = Date.now() - gameStartTime;
            }

            // Track speed achievements
            const currentTime = Date.now();
            if (currentTime - gameStartTime < 30000) { // Within 30 seconds
                wordsFoundInTime++;
            }

            // Track streak (consecutive valid words)
            currentStreak++;

            // Track tiles used for grid exploration
            currentPath.forEach(pos => {
                tilesUsed.add(`${pos.row}-${pos.col}`);
            });

            // Check for immediate achievements
            checkAchievements(['score', 'word_length', 'speed', 'palindrome', 'vowel_word', 'no_vowel_word', 'matrix_play', 'combo', 'exact_score', 'speed_burst', 'efficiency', 'word_variety', 'perfect_accuracy', 'quick_start']);

            // Legacy tutorial integration - trigger tutorial progression if waiting for first word
            if (window.tutorialWordListener && typeof window.tutorialWordListener === 'function') {
                window.tutorialWordListener();
            }
        }
        
        playAgainBtn.addEventListener('click', init);
        window.onload = init;

        // Optimized function to find all possible words on the board with caching
        function findAllPossibleWords() {
            const startTime = performance.now();

            // Create a hash of the current grid for caching
            const gridHash = createGridHash();

            // Check if we have cached results for this grid
            if (wordSearchCache.gridHash === gridHash && wordSearchCache.words) {
                console.log(`Using cached results (${wordSearchCache.words.length} words)`);
                return wordSearchCache.words;
            }

            console.log("Finding all possible words (optimized)...");

            // Pre-compute adjacency list for faster neighbor lookup
            const adjacencyList = precomputeAdjacencyList();

            // Create or reuse trie for faster word validation
            let trie = wordSearchCache.trie;
            if (!trie) {
                trie = buildTrieFromDictionary();
                wordSearchCache.trie = trie; // Cache the trie
            }

            // Use a Set for O(1) duplicate checking
            const possibleWords = new Set();

            // Pre-allocate visited array once
            const visited = new Array(GRID_SIZE * GRID_SIZE).fill(false);

            // Try starting from each cell
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const startIndex = i * GRID_SIZE + j;
                    optimizedDFS(startIndex, grid[i][j], trie, visited, possibleWords, adjacencyList);
                }
            }

            // Convert to array and filter by length
            const validWords = Array.from(possibleWords).filter(word => word.length >= 3);

            // Cache the results
            wordSearchCache.gridHash = gridHash;
            wordSearchCache.words = validWords;

            const endTime = performance.now();
            console.log(`Found ${validWords.length} possible words in ${(endTime - startTime).toFixed(2)}ms`);
            return validWords;
        }

        // Create a hash of the current grid for caching
        function createGridHash() {
            let hash = '';
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    hash += grid[i][j];
                }
            }
            return hash + '_' + GRID_SIZE; // Include grid size in hash
        }

        // Pre-compute adjacency list for O(1) neighbor lookup
        function precomputeAdjacencyList() {
            const adjacencyList = new Array(GRID_SIZE * GRID_SIZE);

            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const index = i * GRID_SIZE + j;
                    const neighbors = [];

                    // Check all 8 directions
                    for (let di = -1; di <= 1; di++) {
                        for (let dj = -1; dj <= 1; dj++) {
                            if (di === 0 && dj === 0) continue;

                            const ni = i + di;
                            const nj = j + dj;

                            if (ni >= 0 && ni < GRID_SIZE && nj >= 0 && nj < GRID_SIZE) {
                                neighbors.push(ni * GRID_SIZE + nj);
                            }
                        }
                    }

                    adjacencyList[index] = neighbors;
                }
            }

            return adjacencyList;
        }

        // Build a trie from the dictionary for faster prefix checking
        function buildTrieFromDictionary() {
            const trie = { children: {}, isWord: false };

            // Only build trie for words that could possibly be found (reasonable length)
            for (const word of englishWords) {
                if (word.length >= 3 && word.length <= 15) {
                    let node = trie;
                    for (const char of word) {
                        if (!node.children[char]) {
                            node.children[char] = { children: {}, isWord: false };
                        }
                        node = node.children[char];
                    }
                    node.isWord = true;
                }
            }

            return trie;
        }

        // Optimized DFS using flat array indexing and trie pruning
        function optimizedDFS(currentIndex, currentWord, trieNode, visited, possibleWords, adjacencyList) {
            const lastChar = currentWord[currentWord.length - 1];

            // Check if current word prefix exists in trie (early pruning)
            if (!trieNode.children[lastChar]) {
                return; // Prune: no words start with this prefix
            }

            const nextTrieNode = trieNode.children[lastChar];

            // Mark current cell as visited
            visited[currentIndex] = true;

            // If this forms a valid word, add it
            if (currentWord.length >= 3 && nextTrieNode.isWord) {
                possibleWords.add(currentWord);
            }

            // Early termination: don't explore paths longer than reasonable word length
            // Also check if there are any possible continuations in the trie
            if (currentWord.length < 15 && Object.keys(nextTrieNode.children).length > 0) {
                // Explore neighbors
                const neighbors = adjacencyList[currentIndex];
                for (let i = 0; i < neighbors.length; i++) {
                    const neighborIndex = neighbors[i];

                    if (!visited[neighborIndex]) {
                        const row = Math.floor(neighborIndex / GRID_SIZE);
                        const col = neighborIndex % GRID_SIZE;
                        const nextChar = grid[row][col];

                        // Quick check: does this character exist as a child in the trie?
                        if (nextTrieNode.children[nextChar]) {
                            const nextWord = currentWord + nextChar;
                            optimizedDFS(neighborIndex, nextWord, nextTrieNode, visited, possibleWords, adjacencyList);
                        }
                    }
                }
            }

            // Backtrack
            visited[currentIndex] = false;
        }

        // Show all possible words in the modal
        function showAllPossibleWords() {
            console.log("Showing all possible words...");
            
            const allPossibleWordsSection = document.getElementById('all-possible-words');
            const possibleWordsList = document.getElementById('possible-words-list');
            const possibleWordsCount = document.getElementById('possible-words-count');
            
            // Show loading indicator
            possibleWordsList.innerHTML = '<div class="col-span-2 text-center py-4">Finding all possible words...</div>';
            allPossibleWordsSection.classList.remove('hidden');
            
            // Use setTimeout to allow the UI to update before starting the intensive calculation
            setTimeout(() => {
                try {
                    // Find all possible words
                    const possibleWords = findAllPossibleWords();
                    
                    // Store the words in a global variable for sorting
                    window.allPossibleWords = possibleWords.map(word => ({
                        word: word,
                        length: word.length,
                        value: calculatePoints(word.length),
                        found: foundWords.has(word.toLowerCase())
                    }));
                    
                    // Display the words (default sort by length)
                    displayPossibleWords('length-desc');
                    
                    // Set up sorting buttons
                    setupSortingButtons();
                    
                } catch (error) {
                    console.error("Error finding possible words:", error);
                    possibleWordsList.innerHTML = '<div class="col-span-2 text-center py-4 text-red-500">Error finding words</div>';
                }
            }, 100);
        }

        // Display possible words with the specified sorting
        function displayPossibleWords(sortType) {
            const possibleWordsList = document.getElementById('possible-words-list');
            const possibleWordsCount = document.getElementById('possible-words-count');
            
            if (!possibleWordsList || !window.allPossibleWords) return;
            
            // Clear the list
            possibleWordsList.innerHTML = '';
            
            if (window.allPossibleWords.length === 0) {
                possibleWordsList.innerHTML = '<div class="col-span-2 text-center py-4">No words found</div>';
                return;
            }
            
            // Sort the words based on the selected sort type
            let sortedWords = [...window.allPossibleWords];
            
            switch (sortType) {
                case 'alpha':
                    sortedWords.sort((a, b) => a.word.localeCompare(b.word));
                    break;
                case 'length-desc':
                    sortedWords.sort((a, b) => b.length - a.length || a.word.localeCompare(b.word));
                    break;
                case 'value-desc':
                    sortedWords.sort((a, b) => b.value - a.value || a.word.localeCompare(b.word));
                    break;
                case 'value-asc':
                    sortedWords.sort((a, b) => a.value - b.value || a.word.localeCompare(b.word));
                    break;
            }
            
            // Group words by length or value depending on sort type
            const groupBy = sortType.startsWith('length') ? 'length' : 
                           (sortType === 'alpha' ? null : 'value');
            
            if (groupBy) {
                // Group by length or value
                const wordsByGroup = {};
                sortedWords.forEach(wordObj => {
                    const groupValue = wordObj[groupBy];
                    if (!wordsByGroup[groupValue]) {
                        wordsByGroup[groupValue] = [];
                    }
                    wordsByGroup[groupValue].push(wordObj);
                });
                
                // Get group keys and sort them
                let groupKeys = Object.keys(wordsByGroup).map(Number);
                if (sortType === 'length-desc' || sortType === 'value-desc') {
                    groupKeys.sort((a, b) => b - a);
                } else {
                    groupKeys.sort((a, b) => a - b);
                }
                
                // Display words grouped by length or value
                groupKeys.forEach(groupValue => {
                    // Create a section for this group
                    const groupSection = document.createElement('div');
                    groupSection.className = 'col-span-2 mt-2 first:mt-0';
                    
                    const groupLabel = groupBy === 'length' ? 
                        `${groupValue}-letter words (${wordsByGroup[groupValue].length})` : 
                        `${groupValue} points (${wordsByGroup[groupValue].length})`;
                        
                    groupSection.innerHTML = `<h4 class="font-semibold text-sm text-gray-700">${groupLabel}</h4>`;
                    possibleWordsList.appendChild(groupSection);
                    
                    // Add each word
                    wordsByGroup[groupValue].forEach(wordObj => {
                        const wordEl = document.createElement('div');
                        wordEl.className = 'px-2 py-1 text-sm';
                        
                        // Highlight words that were found by the player
                        if (wordObj.found) {
                            wordEl.className += ' bg-green-100 text-green-800 rounded';
                            wordEl.innerHTML = `${wordObj.word} <span class="text-xs">✓</span>`;
                        } else {
                            wordEl.textContent = wordObj.word;
                        }
                        
                        possibleWordsList.appendChild(wordEl);
                    });
                });
            } else {
                // Alphabetical sort - no grouping
                sortedWords.forEach(wordObj => {
                    const wordEl = document.createElement('div');
                    wordEl.className = 'px-2 py-1 text-sm';
                    
                    // Highlight words that were found by the player
                    if (wordObj.found) {
                        wordEl.className += ' bg-green-100 text-green-800 rounded';
                        wordEl.innerHTML = `${wordObj.word} <span class="text-xs">✓</span>`;
                    } else {
                        wordEl.textContent = wordObj.word;
                    }
                    
                    possibleWordsList.appendChild(wordEl);
                });
            }
            
            // Update the count
            const foundCount = window.allPossibleWords.filter(wordObj => wordObj.found).length;
            possibleWordsCount.textContent = `You found ${foundCount} out of ${window.allPossibleWords.length} possible words (${Math.round((foundCount / window.allPossibleWords.length) * 100) || 0}%)`;
        }

        // Set up sorting buttons
        function setupSortingButtons() {
            const sortButtons = [
                { id: 'sort-length-desc', type: 'length-desc' },
                { id: 'sort-alpha', type: 'alpha' },
                { id: 'sort-value-desc', type: 'value-desc' },
                { id: 'sort-value-asc', type: 'value-asc' }
            ];
            
            sortButtons.forEach(button => {
                const buttonEl = document.getElementById(button.id);
                if (buttonEl) {
                    buttonEl.addEventListener('click', () => {
                        // Update active button styling
                        sortButtons.forEach(b => {
                            const el = document.getElementById(b.id);
                            if (el) {
                                el.classList.remove('bg-blue-100', 'text-blue-800', 'active-sort');
                                el.classList.add('bg-gray-100', 'text-gray-800');
                            }
                        });
                        
                        buttonEl.classList.remove('bg-gray-100', 'text-gray-800');
                        buttonEl.classList.add('bg-blue-100', 'text-blue-800', 'active-sort');
                        
                        // Display words with the selected sorting
                        displayPossibleWords(button.type);
                    });
                }
            });
        }

        // Set up event listeners
        function setupEventListeners() {
            // Play again button
            const playAgainBtn = document.getElementById('play-again-btn');
            if (playAgainBtn) {
                playAgainBtn.addEventListener('click', () => {
                    // Hide the game over modal
                    const gameOverModal = document.getElementById('game-over-modal');
                    if (gameOverModal) {
                        const modalContent = gameOverModal.querySelector('div');
                        if (modalContent) {
                            modalContent.classList.add('scale-95', 'opacity-0');
                        }

                        setTimeout(() => {
                            gameOverModal.classList.add('hidden');
                            // Return to opening UI
                            showOpeningUI();
                        }, 300);
                    }
                });
            }
            
            // Show all words button
            const showAllWordsBtn = document.getElementById('show-all-words-btn');
            if (showAllWordsBtn) {
                showAllWordsBtn.addEventListener('click', () => {
                    console.log("Show all words button clicked");
                    showAllPossibleWords();
                });
            }
            
            // Game mode toggle buttons
            const timedModeBtn = document.getElementById('timed-mode-btn');
            const unlimitedModeBtn = document.getElementById('unlimited-mode-btn');

            if (timedModeBtn && unlimitedModeBtn) {
                timedModeBtn.addEventListener('click', () => {
                    if (currentGameMode !== GAME_MODE.TIMED) {
                        setGameMode(GAME_MODE.TIMED);
                    }
                });

                unlimitedModeBtn.addEventListener('click', () => {
                    if (currentGameMode !== GAME_MODE.UNLIMITED) {
                        setGameMode(GAME_MODE.UNLIMITED);
                    }
                });
            }
            
            // Add end game button for unlimited mode
            const timerDisplayEl = document.getElementById('timer-display');
            if (timerDisplayEl) {
                timerDisplayEl.addEventListener('click', () => {
                    if (currentGameMode === GAME_MODE.UNLIMITED) {
                        endGame();
                    }
                });
            }

            // Customize button
            const customizeBtn = document.getElementById('customize-btn');
            if (customizeBtn) {
                customizeBtn.addEventListener('click', () => {
                    openCustomizeMenu();
                });
            }

            // Back to menu button
            const backToMenuBtn = document.getElementById('back-to-menu-btn');
            if (backToMenuBtn) {
                backToMenuBtn.addEventListener('click', () => {
                    showOpeningUI();
                });
            }

            // Reset confirmation modal buttons
            const confirmResetBtn = document.getElementById('confirm-reset-btn');
            const cancelResetBtn = document.getElementById('cancel-reset-btn');

            if (confirmResetBtn) {
                confirmResetBtn.addEventListener('click', () => {
                    hideResetConfirmationModal();
                    resetAllData();
                });
            }

            if (cancelResetBtn) {
                cancelResetBtn.addEventListener('click', () => {
                    hideResetConfirmationModal();
                });
            }
        }

        // Add mobile touch pattern detection for secret menu
        function setupMobileTouchPattern() {
            const gridContainer = document.getElementById('grid-container');
            if (!gridContainer) return;

            let touchStartTime = 0;
            let touchPattern = [];

            gridContainer.addEventListener('touchstart', (e) => {
                // Disable mobile secret access for Daily Challenge mode
                if (isDailyChallenge) {
                    return; // No secret access in competitive modes
                }

                if (e.touches.length === 1) {
                    touchStartTime = Date.now();
                    const touch = e.touches[0];
                    const rect = gridContainer.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;

                    // Determine which area was touched
                    const area = getTouchArea(x, y, rect.width, rect.height);

                    // Only add to pattern if it's a quick tap (less than 300ms)
                    setTimeout(() => {
                        if (Date.now() - touchStartTime < 300) {
                            touchPattern.push(area);

                            // Reset pattern after 4 seconds of inactivity
                            clearTimeout(secretTouchTimeout);
                            secretTouchTimeout = setTimeout(() => {
                                touchPattern = [];
                            }, 4000);

                            // Check if pattern matches
                            if (touchPattern.length === SECRET_TOUCH_PATTERN.length) {
                                const isCorrect = touchPattern.every((area, index) =>
                                    area === SECRET_TOUCH_PATTERN[index]
                                );

                                if (isCorrect) {
                                    touchPattern = [];
                                    showMobileSecretAccess();
                                } else {
                                    touchPattern = [];
                                }
                            }
                        }
                    }, 300);
                }
            });
        }

        function getTouchArea(x, y, width, height) {
            const thirdW = width / 3;
            const thirdH = height / 3;

            if (x < thirdW && y < thirdH) return 'top-left';
            if (x > 2 * thirdW && y < thirdH) return 'top-right';
            if (x < thirdW && y > 2 * thirdH) return 'bottom-left';
            if (x > 2 * thirdW && y > 2 * thirdH) return 'bottom-right';
            if (x > thirdW && x < 2 * thirdW && y > thirdH && y < 2 * thirdH) return 'center';
            return 'other';
        }

        function showMobileSecretAccess() {
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 left-4 bg-purple-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 text-sm';
            notification.innerHTML = '📱 Mobile secret access granted!';
            document.body.appendChild(notification);

            setTimeout(() => {
                document.body.removeChild(notification);
                openSecretMenu();
            }, 1500);
        }

        // Setup opening UI event listeners
        function setupOpeningUI() {
            // Board size selection buttons
            const board4x4Btn = document.getElementById('board-4x4-btn');
            const board5x5Btn = document.getElementById('board-5x5-btn');

            if (board4x4Btn && board5x5Btn) {
                board4x4Btn.addEventListener('click', () => {
                    currentBoardSize = BOARD_SIZE.SMALL;
                    updateBoardSizeSelection();
                });

                board5x5Btn.addEventListener('click', () => {
                    currentBoardSize = BOARD_SIZE.LARGE;
                    updateBoardSizeSelection();
                });
            }
        }

        function updateBoardSizeSelection() {
            const board4x4Btn = document.getElementById('board-4x4-btn');
            const board5x5Btn = document.getElementById('board-5x5-btn');
            const selectedText = document.getElementById('selected-board-size');
            const selected4x4 = document.getElementById('selected-4x4');
            const selected5x5 = document.getElementById('selected-5x5');

            if (currentBoardSize === BOARD_SIZE.SMALL) {
                // Update 4x4 button styling
                board4x4Btn.classList.remove('border-transparent');
                board4x4Btn.classList.add('border-purple-300', 'shadow-lg');
                board5x5Btn.classList.remove('border-orange-300', 'shadow-lg');
                board5x5Btn.classList.add('border-transparent');

                // Update selection indicators
                selected4x4.classList.remove('opacity-0');
                selected5x5.classList.add('opacity-0');
                selectedText.textContent = '4×4 Classic';
                selectedText.className = 'font-bold text-purple-600';
            } else {
                // Update 5x5 button styling
                board5x5Btn.classList.remove('border-transparent');
                board5x5Btn.classList.add('border-orange-300', 'shadow-lg');
                board4x4Btn.classList.remove('border-purple-300', 'shadow-lg');
                board4x4Btn.classList.add('border-transparent');

                // Update selection indicators
                selected5x5.classList.remove('opacity-0');
                selected4x4.classList.add('opacity-0');
                selectedText.textContent = '5×5 Challenge';
                selectedText.className = 'font-bold text-orange-600';
            }

            // Start game buttons
            const startTimedBtn = document.getElementById('start-timed-btn');
            const startUnlimitedBtn = document.getElementById('start-unlimited-btn');

            if (startTimedBtn) {
                startTimedBtn.addEventListener('click', () => {
                    startGame(GAME_MODE.TIMED);
                });
            }

            if (startUnlimitedBtn) {
                startUnlimitedBtn.addEventListener('click', () => {
                    startGame(GAME_MODE.UNLIMITED);
                });
            }

            // Opening customize button
            const openingCustomizeBtn = document.getElementById('opening-customize-btn');
            if (openingCustomizeBtn) {
                openingCustomizeBtn.addEventListener('click', () => {
                    openCustomizeMenu();
                });
            }

            // Opening achievements button
            const openingAchievementsBtn = document.getElementById('opening-achievements-btn');
            if (openingAchievementsBtn) {
                openingAchievementsBtn.addEventListener('click', () => {
                    openAchievementsMenu();
                });
            }

            // Opening analytics button
            const openingAnalyticsBtn = document.getElementById('opening-analytics-btn');
            if (openingAnalyticsBtn) {
                openingAnalyticsBtn.addEventListener('click', () => {
                    openAnalyticsMenu();
                });
            }

            // Opening tutorial button
            const openingTutorialBtn = document.getElementById('opening-tutorial-btn');
            if (openingTutorialBtn) {
                openingTutorialBtn.addEventListener('click', () => {
                    openTutorialMenu();
                });
            }

            // Opening daily challenge button
            const openingDailyChallengeBtn = document.getElementById('opening-daily-challenge-btn');
            if (openingDailyChallengeBtn) {
                openingDailyChallengeBtn.addEventListener('click', () => {
                    openDailyChallengeModal();
                });
            }

            // Data reset button
            const resetDataBtn = document.getElementById('reset-data-btn');
            if (resetDataBtn) {
                resetDataBtn.addEventListener('click', () => {
                    showResetConfirmationModal();
                });
            }

            // Leaderboard tabs
            const timedTab = document.getElementById('leaderboard-timed-tab');
            const unlimitedTab = document.getElementById('leaderboard-unlimited-tab');

            if (timedTab && unlimitedTab) {
                timedTab.addEventListener('click', () => {
                    // Update tab styling
                    timedTab.classList.remove('text-gray-500', 'hover:text-gray-700');
                    timedTab.classList.add('text-blue-600', 'border-b-2', 'border-blue-500');
                    unlimitedTab.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                    unlimitedTab.classList.add('text-gray-500', 'hover:text-gray-700');

                    // Update leaderboard
                    displayOpeningLeaderboard();
                });

                unlimitedTab.addEventListener('click', () => {
                    // Update tab styling
                    unlimitedTab.classList.remove('text-gray-500', 'hover:text-gray-700');
                    unlimitedTab.classList.add('text-blue-600', 'border-b-2', 'border-blue-500');
                    timedTab.classList.remove('text-blue-600', 'border-b-2', 'border-blue-500');
                    timedTab.classList.add('text-gray-500', 'hover:text-gray-700');

                    // Update leaderboard
                    displayOpeningLeaderboard();
                });
            }
        }

        // Set the game mode
        function setGameMode(mode) {
            if (mode === currentGameMode) return;

            currentGameMode = mode;

            // Update UI to reflect the current mode
            const timedModeBtn = document.getElementById('timed-mode-btn');
            const unlimitedModeBtn = document.getElementById('unlimited-mode-btn');
            const timerDisplayEl = document.getElementById('timer-display');

            if (timedModeBtn && unlimitedModeBtn) {
                // Reset all buttons
                timedModeBtn.classList.remove('bg-blue-500', 'text-white');
                timedModeBtn.classList.add('text-gray-700');
                unlimitedModeBtn.classList.remove('bg-blue-500', 'text-white');
                unlimitedModeBtn.classList.add('text-gray-700');

                if (mode === GAME_MODE.TIMED) {
                    timedModeBtn.classList.add('bg-blue-500', 'text-white');
                    timedModeBtn.classList.remove('text-gray-700');

                    // Show timer display
                    if (timerDisplayEl) {
                        timerDisplayEl.textContent = `${Math.floor(timer / 60).toString().padStart(2, '0')}:${(timer % 60).toString().padStart(2, '0')}`;
                        timerDisplayEl.classList.remove('bg-red-500', 'hover:bg-red-600', 'cursor-pointer');
                        timerDisplayEl.title = "";
                    }
                } else {
                    unlimitedModeBtn.classList.add('bg-blue-500', 'text-white');
                    unlimitedModeBtn.classList.remove('text-gray-700');

                    // Replace timer with end game button
                    if (timerDisplayEl) {
                        clearInterval(timerInterval);
                        timerDisplayEl.textContent = "End Game";
                        timerDisplayEl.classList.add('bg-red-500', 'hover:bg-red-600', 'cursor-pointer');
                        timerDisplayEl.title = "Click to end the game";
                    }
                }
            }

            // Load high scores for the selected mode
            loadHighScores();

            // Start a new game with the new mode
            init();

            console.log(`Game mode changed to: ${mode}`);
        }

        // Data reset functions
        function showResetConfirmationModal() {
            const modal = document.getElementById('reset-confirmation-modal');
            modal.classList.remove('hidden');
            setTimeout(() => {
                const content = modal.querySelector('div');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function hideResetConfirmationModal() {
            const modal = document.getElementById('reset-confirmation-modal');
            const content = modal.querySelector('div');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        function resetAllData() {
            try {
                console.log('Starting data reset...');

                // Debug: Show all localStorage keys
                const allKeys = Object.keys(localStorage);
                console.log('All localStorage keys:', allKeys);

                // Get all localStorage keys that belong to this game
                const gameKeys = allKeys.filter(key =>
                    key.includes('wordHunt') ||
                    key.includes('WordHunt') ||
                    key.includes('wordhunt')
                );

                console.log('Found game keys:', gameKeys);
                console.log('Total game keys to remove:', gameKeys.length);

                // Remove all game-related keys
                gameKeys.forEach(key => {
                    console.log('Removing key:', key);
                    localStorage.removeItem(key);
                });

                // Also remove any keys that might have different naming
                const additionalKeys = [
                    'wordHuntHighScoresTimed4x4',
                    'wordHuntHighScoresUnlimited4x4',
                    'wordHuntHighScoresTimed5x5',
                    'wordHuntHighScoresUnlimited5x5',
                    'wordHuntDailyChallenges',
                    'wordHuntDailyStreak',
                    'wordHuntAchievements',
                    'wordHuntPowerups',
                    'wordHuntSettings',
                    'wordHuntCustomizations',
                    'wordHuntBackgrounds',
                    'wordHuntEffects'
                ];

                additionalKeys.forEach(key => {
                    if (localStorage.getItem(key)) {
                        console.log('Removing additional key:', key);
                        localStorage.removeItem(key);
                    }
                });

                // Remove all daily challenge leaderboards (they start with specific prefix)
                allKeys.forEach(key => {
                    if (key.includes('wordHuntDailyLeaderboard')) {
                        console.log('Removing daily leaderboard key:', key);
                        localStorage.removeItem(key);
                    }
                });

                console.log('All game data has been reset');

                // Show success notification
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 bg-green-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-500';
                notification.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="text-xl">✅</span>
                        <div>
                            <div class="font-bold">Data Reset Complete</div>
                            <div class="text-sm opacity-90">All game data has been cleared</div>
                        </div>
                    </div>
                `;

                document.body.appendChild(notification);

                // Animate in
                setTimeout(() => {
                    notification.classList.remove('translate-x-full');
                }, 100);

                // Auto-hide after 3 seconds
                setTimeout(() => {
                    notification.classList.add('translate-x-full');
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 500);
                }, 3000);

                // Verify the reset worked
                const remainingKeys = Object.keys(localStorage).filter(key =>
                    key.includes('wordHunt') || key.includes('WordHunt') || key.includes('wordhunt')
                );

                if (remainingKeys.length > 0) {
                    console.warn('Some keys were not removed:', remainingKeys);
                    // Try to remove them one more time
                    remainingKeys.forEach(key => {
                        try {
                            localStorage.removeItem(key);
                        } catch (e) {
                            console.warn('Could not remove key:', key, e);
                        }
                    });
                } else {
                    console.log('All game keys successfully removed');
                }

                // Reload the page to reset everything
                setTimeout(() => {
                    window.location.reload();
                }, 2000);

            } catch (error) {
                console.error('Error resetting data:', error);

                // Show error notification with more details
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 bg-red-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 max-w-sm';
                notification.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="text-xl">❌</span>
                        <div>
                            <div class="font-bold">Reset Failed</div>
                            <div class="text-sm opacity-90">Error: ${error.message}</div>
                            <div class="text-xs opacity-75 mt-1">Check console for details</div>
                        </div>
                    </div>
                `;

                document.body.appendChild(notification);

                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 5000);
            }
        }

        // Debug function to check localStorage
        function debugLocalStorage() {
            console.log('=== localStorage Debug ===');
            const allKeys = Object.keys(localStorage);
            console.log('Total keys:', allKeys.length);

            const gameKeys = allKeys.filter(key =>
                key.includes('wordHunt') ||
                key.includes('WordHunt') ||
                key.includes('wordhunt')
            );

            console.log('Game-related keys:', gameKeys);
            gameKeys.forEach(key => {
                const value = localStorage.getItem(key);
                console.log(`${key}:`, value ? value.substring(0, 100) + '...' : 'null');
            });

            return {
                totalKeys: allKeys.length,
                gameKeys: gameKeys,
                allKeys: allKeys
            };
        }

        // Load the English words dictionary from multiple sources
        async function loadDictionary() {
            console.log('Loading comprehensive dictionary...');

            // Start with built-in words for immediate functionality
            englishWords = new Set(BUILT_IN_WORDS.map(word => word.toUpperCase()));
            console.log(`Loaded ${englishWords.size} built-in words`);

            // Load additional words from online sources
            let totalLoaded = englishWords.size;

            for (const url of DICTIONARY_URLS) {
                try {
                    console.log(`Loading additional words from: ${url}`);
                    const response = await fetch(url);

                    if (response.ok) {
                        const text = await response.text();
                        const words = text.split('\n')
                            .map(word => word.trim().toUpperCase())
                            .filter(word => word.length >= 3 && word.length <= 15) // Reasonable word length
                            .filter(word => /^[A-Z]+$/.test(word)); // Only letters

                        // Add new words to the set
                        const beforeSize = englishWords.size;
                        words.forEach(word => englishWords.add(word));
                        const newWords = englishWords.size - beforeSize;

                        console.log(`Added ${newWords} new words from ${url}`);
                        totalLoaded += newWords;
                    } else {
                        console.warn(`Failed to load from ${url}: ${response.status}`);
                    }
                } catch (error) {
                    console.warn(`Error loading from ${url}:`, error.message);
                }
            }

            // Add common word variations and plurals
            addWordVariations();

            console.log(`Dictionary loading complete! Total words: ${englishWords.size}`);
        }

        // Add common word variations to expand the dictionary
        function addWordVariations() {
            const originalWords = Array.from(englishWords);
            let addedVariations = 0;

            originalWords.forEach(word => {
                // Add common plurals
                if (word.length >= 3 && word.length <= 12) {
                    // Add 'S' plural
                    if (!word.endsWith('S')) {
                        englishWords.add(word + 'S');
                        addedVariations++;
                    }

                    // Add 'ES' plural for words ending in certain letters
                    if (word.endsWith('CH') || word.endsWith('SH') || word.endsWith('X') || word.endsWith('Z')) {
                        englishWords.add(word + 'ES');
                        addedVariations++;
                    }

                    // Add 'IES' plural for words ending in 'Y'
                    if (word.endsWith('Y') && word.length > 3) {
                        const stem = word.slice(0, -1);
                        englishWords.add(stem + 'IES');
                        addedVariations++;
                    }
                }

                // Add common verb forms
                if (word.length >= 3 && word.length <= 10) {
                    // Add 'ED' past tense
                    if (!word.endsWith('ED')) {
                        englishWords.add(word + 'ED');
                        addedVariations++;

                        // Double consonant + ED (e.g., RUN -> RUNNED, though not always correct)
                        if (word.length >= 3 && /[BCDFGHJKLMNPQRSTVWXYZ]$/.test(word)) {
                            const lastChar = word.slice(-1);
                            englishWords.add(word + lastChar + 'ED');
                            addedVariations++;
                        }
                    }

                    // Add 'ING' present participle
                    if (!word.endsWith('ING')) {
                        englishWords.add(word + 'ING');
                        addedVariations++;

                        // Double consonant + ING
                        if (word.length >= 3 && /[BCDFGHJKLMNPQRSTVWXYZ]$/.test(word)) {
                            const lastChar = word.slice(-1);
                            englishWords.add(word + lastChar + 'ING');
                            addedVariations++;
                        }
                    }

                    // Add 'ER' comparative/agent
                    if (!word.endsWith('ER') && word.length <= 8) {
                        englishWords.add(word + 'ER');
                        addedVariations++;
                    }

                    // Add 'EST' superlative
                    if (!word.endsWith('EST') && word.length <= 7) {
                        englishWords.add(word + 'EST');
                        addedVariations++;
                    }
                }
            });

            console.log(`Added ${addedVariations} word variations`);
        }

        // Add secret menu functionality
        function setupSecretMenu() {
            // Listen for key presses to detect secret code
            document.addEventListener('keydown', (e) => {
                // Disable secret commands for Daily Challenge mode
                if (isDailyChallenge) {
                    return; // No secret commands in competitive modes
                }

                // Only capture letter keys
                if (/^[a-zA-Z]$/.test(e.key)) {
                    secretCode += e.key.toUpperCase();

                    // Reset the timeout
                    clearTimeout(secretCodeTimeout);

                    // Check if the current code matches any commands
                    Object.keys(SECRET_COMMANDS).forEach(command => {
                        if (secretCode.endsWith(command)) {
                            // Mark that secret commands were used in this game
                            secretCommandsUsed = true;

                            // Execute the command
                            SECRET_COMMANDS[command]();

                            // Show a notification
                            showSecretCommandNotification(command);

                            // Update UI to show secret commands indicator
                            updatePowerupInventoryDisplay();

                            // Reset the code
                            secretCode = '';
                            return;
                        }
                    });

                    // Set a timeout to reset the code after 2 seconds of inactivity
                    secretCodeTimeout = setTimeout(() => {
                        secretCode = '';
                    }, 2000);
                }
            });

            console.log("Secret menu initialized. Try typing secret commands!");
        }

        // Secret command functions
        function enableGodMode() {
            godModeEnabled = !godModeEnabled;
            console.log(`God Mode ${godModeEnabled ? 'enabled' : 'disabled'}`);
            
            if (godModeEnabled) {
                // In God Mode, all words are valid
                window.originalCheckWord = checkWord;
                checkWord = function(word) {
                    if (word.length < 3) return;
                    
                    // Always treat as valid word
                    const points = calculatePoints(word.length) * 2; // Double points in God Mode
                    currentWordEl.textContent = `${word} (+${points}) GOD MODE!`;
                    foundWords.add(word);
                    
                    // Update score
                    score += points;
                    scoreEl.textContent = score;
                    wordCountEl.textContent = foundWords.size;
                    
                    // Animate
                    animatePath('correct');
                    setTimeout(() => {
                        resetPath();
                    }, 300);
                };
            } else {
                // Restore original function
                if (window.originalCheckWord) {
                    checkWord = window.originalCheckWord;
                }
            }
        }

        function showAllWordsCheat() {
            // Find all possible words and highlight them on the grid
            const possibleWords = findAllPossibleWords();
            console.log(`Cheat activated: Found ${possibleWords.length} possible words`);
            
            // Show a temporary overlay with some of the words
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-50';
            overlay.innerHTML = `
                <div class="bg-white p-6 rounded-xl max-w-md max-h-96 overflow-auto">
                    <h3 class="text-xl font-bold mb-3">Secret Cheat: Word List</h3>
                    <p class="mb-3 text-sm text-gray-600">Here are some of the highest-scoring words:</p>
                    <div class="grid grid-cols-2 gap-2">
                        ${possibleWords
                            .sort((a, b) => calculatePoints(b.length) - calculatePoints(a.length))
                            .slice(0, 20)
                            .map(word => `<div class="bg-blue-100 px-2 py-1 rounded text-blue-800">${word} (${calculatePoints(word.length)})</div>`)
                            .join('')
                        }
                    </div>
                    <p class="mt-4 text-xs text-gray-500">Click anywhere to close</p>
                </div>
            `;
            
            document.body.appendChild(overlay);
            overlay.addEventListener('click', () => {
                document.body.removeChild(overlay);
            });
        }

        function addExtraTime() {
            if (currentGameMode === GAME_MODE.TIMED) {
                timer += 30; // Add 30 seconds
                updateTimerDisplay();
                console.log("Extra time added: +30 seconds");
            } else {
                console.log("Extra time can only be added in timed modes");
            }
        }

        function enableRainbowMode() {
            rainbowModeEnabled = !rainbowModeEnabled;
            console.log(`Rainbow Mode ${rainbowModeEnabled ? 'enabled' : 'disabled'}`);
            
            const tiles = document.querySelectorAll('.tile');
            
            if (rainbowModeEnabled) {
                // Add rainbow animation to all tiles
                tiles.forEach(tile => {
                    tile.classList.add('rainbow-animation');
                });
                
                // Add CSS for rainbow animation if it doesn't exist
                if (!document.getElementById('rainbow-style')) {
                    const style = document.createElement('style');
                    style.id = 'rainbow-style';
                    style.textContent = `
                        @keyframes rainbow {
                            0% { background-color: #ff0000; }
                            14% { background-color: #ff7f00; }
                            28% { background-color: #ffff00; }
                            42% { background-color: #00ff00; }
                            57% { background-color: #0000ff; }
                            71% { background-color: #4b0082; }
                            85% { background-color: #9400d3; }
                            100% { background-color: #ff0000; }
                        }
                        .rainbow-animation {
                            animation: rainbow 5s linear infinite;
                            color: white !important;
                            text-shadow: 0 0 3px black;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                // Remove rainbow animation
                tiles.forEach(tile => {
                    tile.classList.remove('rainbow-animation');
                });
            }
        }

        function enableBigPointsMode() {
            bigPointsModeEnabled = !bigPointsModeEnabled;
            console.log(`Big Points Mode ${bigPointsModeEnabled ? 'enabled' : 'disabled'}`);
            
            // Store original function if not already stored
            if (!window.originalCalculatePoints) {
                window.originalCalculatePoints = calculatePoints;
            }
            
            if (bigPointsModeEnabled) {
                // Override the points calculation
                calculatePoints = function(wordLength) {
                    // 5x normal points
                    if (wordLength === 3) return 500;
                    if (wordLength === 4) return 2000;
                    if (wordLength === 5) return 4000;
                    if (wordLength === 6) return 7000;
                    if (wordLength === 7) return 9000;
                    if (wordLength >= 8) return 11000;
                    return 0;
                };
            } else {
                // Restore original function
                if (window.originalCalculatePoints) {
                    calculatePoints = window.originalCalculatePoints;
                }
            }
        }

        function showSecretCommandNotification(command) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-purple-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-300';
            notification.innerHTML = `
                <div class="flex items-center">
                    <span class="text-lg mr-2">🔮</span>
                    <div>
                        <div class="font-bold">Secret Command Activated!</div>
                        <div class="text-sm">${command}</div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Add a secret dot only to the game score header during gameplay (requires 5 clicks)
        function addSecretDot() {
            // Disable secret menu for Daily Challenge mode
            if (isDailyChallenge) {
                return; // No secret access in competitive modes
            }

            // Only add to the game score header when game is active
            const gameContainer = document.getElementById('game-container');
            if (!gameContainer || gameContainer.classList.contains('hidden')) {
                return; // Don't add if game is not active
            }

            const scoreHeader = document.querySelector('#game-container .bg-white.rounded-xl.shadow-lg');
            if (!scoreHeader || scoreHeader.querySelector('.secret-dot')) {
                return; // Don't add if already exists
            }

            // Create the secret dot (small but visible)
            const secretDot = document.createElement('div');
            secretDot.className = 'secret-dot absolute top-2 right-2 w-2 h-2 rounded-full bg-gray-400 cursor-pointer';
            secretDot.style.opacity = '0.3';
            secretDot.style.transition = 'all 0.2s ease';
            secretDot.title = 'Secret access';

            // Make sure the score header has position relative
            scoreHeader.style.position = 'relative';

            // Add the dot to the score header
            scoreHeader.appendChild(secretDot);

            secretDot.addEventListener('click', () => {
                secretDotClicks++;

                // Visual feedback
                secretDot.style.transform = 'scale(1.5)';
                secretDot.style.opacity = '0.8';
                setTimeout(() => {
                    secretDot.style.transform = 'scale(1)';
                    secretDot.style.opacity = '0.3';
                }, 150);

                // Reset click count after 3 seconds of inactivity
                clearTimeout(secretDotClickTimeout);
                secretDotClickTimeout = setTimeout(() => {
                    secretDotClicks = 0;
                    resetSecretDotAppearance();
                }, 3000);

                // Progressive visual changes
                if (secretDotClicks >= 2) {
                    secretDot.style.opacity = '0.5';
                    secretDot.className = secretDot.className.replace('bg-gray-400', 'bg-yellow-500');
                }
                if (secretDotClicks >= 4) {
                    secretDot.style.opacity = '0.7';
                    secretDot.className = secretDot.className.replace('bg-yellow-500', 'bg-green-500');
                }

                // After 5 clicks, open secret menu
                if (secretDotClicks >= REQUIRED_DOT_CLICKS) {
                    clearTimeout(secretDotClickTimeout);
                    secretDotClicks = 0;
                    resetSecretDotAppearance();
                    openSecretMenu();
                }
            });

            function resetSecretDotAppearance() {
                secretDot.style.opacity = '0.3';
                secretDot.className = secretDot.className.replace('bg-yellow-500', 'bg-gray-400').replace('bg-green-500', 'bg-gray-400');
            }
        }

        // Helper function to create mobile-responsive menu
        function createMobileMenu(id, title, position = 'right') {
            const menuPanel = document.createElement('div');
            menuPanel.id = id;
            menuPanel.className = `mobile-menu-panel ${position}`;

            const menuContent = document.createElement('div');
            menuContent.className = 'mobile-menu-content';

            menuContent.innerHTML = `
                <div class="mobile-menu-header">
                    <h3 class="text-lg font-bold text-purple-800">${title}</h3>
                    <button class="close-menu-btn text-gray-500 hover:text-gray-800 p-1 rounded-lg hover:bg-gray-100 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div class="mobile-menu-body">
                    <!-- Content will be added here -->
                </div>
                <div class="mobile-menu-footer">
                    <div class="text-xs text-gray-500 text-center">
                        <!-- Footer content will be added here -->
                    </div>
                </div>
            `;

            menuPanel.appendChild(menuContent);
            return { menuPanel, menuContent };
        }

        // Helper function to show mobile menu with animation
        function showMobileMenu(menuPanel) {
            document.body.appendChild(menuPanel);

            // Force reflow
            menuPanel.offsetHeight;

            // Show with animation
            const content = menuPanel.querySelector('.mobile-menu-content');
            content.classList.add('show');

            // Set up close handlers
            const closeBtn = menuPanel.querySelector('.close-menu-btn');
            closeBtn.addEventListener('click', () => closeMobileMenu(menuPanel));

            // Close on backdrop click (mobile only)
            if (window.innerWidth < 768) {
                menuPanel.addEventListener('click', (e) => {
                    if (e.target === menuPanel) {
                        closeMobileMenu(menuPanel);
                    }
                });
            } else {
                // Desktop: close on outside click
                setTimeout(() => {
                    document.addEventListener('click', function handleOutsideClick(e) {
                        if (!menuPanel.contains(e.target)) {
                            closeMobileMenu(menuPanel);
                            document.removeEventListener('click', handleOutsideClick);
                        }
                    });
                }, 100);
            }
        }

        // Helper function to close mobile menu with animation
        function closeMobileMenu(menuPanel) {
            const content = menuPanel.querySelector('.mobile-menu-content');
            content.classList.remove('show');

            setTimeout(() => {
                if (menuPanel.parentNode) {
                    document.body.removeChild(menuPanel);
                }
            }, 200);
        }

        // Open the secret menu
        function openSecretMenu() {
            console.log("Secret menu opened");

            // Mark that secret commands were used in this game
            secretCommandsUsed = true;

            // Update UI to show secret commands indicator
            updatePowerupInventoryDisplay();

            // Unlock secret finder achievement
            if (!achievements.secret_finder.unlocked) {
                achievements.secret_finder.unlocked = true;
                showAchievementNotification([achievements.secret_finder]);
                saveAchievements();
            }

            // Create the mobile-responsive secret menu
            const { menuPanel, menuContent } = createMobileMenu('secret-menu-panel', '🔮 Secret Menu', 'right');

            // Get the menu body to add content
            const menuBody = menuContent.querySelector('.mobile-menu-body');
            const menuFooter = menuContent.querySelector('.mobile-menu-footer div');

            // Create the menu content with new commands
            menuBody.innerHTML = `
                <div class="space-y-1">
                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-purple-500 to-indigo-600 text-white" data-command="GODMODE">
                        <div>
                            <div class="font-medium">🔮 God Mode</div>
                            <div class="text-xs opacity-75">All words valid</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-blue-500 to-teal-400 text-white" data-command="ALLWORDS">
                        <div>
                            <div class="font-medium">📖 Show All Words</div>
                            <div class="text-xs opacity-75">Cheat sheet</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-yellow-500 to-orange-500 text-white" data-command="EXTRATIME">
                        <div>
                            <div class="font-medium">⏰ Extra Time</div>
                            <div class="text-xs opacity-75">+30 seconds</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-green-500 to-emerald-500 text-white" data-command="BIGPOINTS">
                        <div>
                            <div class="font-medium">💎 Big Points</div>
                            <div class="text-xs opacity-75">5x scoring</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-blue-400 to-cyan-500 text-white" data-command="SLOWTIME">
                        <div>
                            <div class="font-medium">🐌 Slow Time</div>
                            <div class="text-xs opacity-75">Half speed timer</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-amber-400 to-yellow-500 text-white" data-command="SHUFFLE">
                        <div>
                            <div class="font-medium">🔀 Shuffle</div>
                            <div class="text-xs opacity-75">New letters</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-cyan-400 to-blue-500 text-white" data-command="FREEZE">
                        <div>
                            <div class="font-medium">❄️ Freeze Timer</div>
                            <div class="text-xs opacity-75">Stop the clock</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-emerald-400 to-teal-500 text-white" data-command="BOOST">
                        <div>
                            <div class="font-medium">🚀 Score Boost</div>
                            <div class="text-xs opacity-75">+1000 points</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-violet-400 to-purple-500 text-white" data-command="HINT">
                        <div>
                            <div class="font-medium">💡 Show Hint</div>
                            <div class="text-xs opacity-75">Word suggestion</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-yellow-400 to-amber-500 text-white" data-command="LUCKY">
                        <div>
                            <div class="font-medium">🍀 Lucky Grid</div>
                            <div class="text-xs opacity-75">Easy letters</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-rose-400 to-red-500 text-white" data-command="RESET">
                        <div>
                            <div class="font-medium">🔄 Reset Score</div>
                            <div class="text-xs opacity-75">Back to zero</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-lime-400 to-green-500 text-white" data-command="DOUBLE">
                        <div>
                            <div class="font-medium">✨ Double Points</div>
                            <div class="text-xs opacity-75">2x scoring</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-amber-400 to-orange-400 text-white" data-command="REVEAL">
                        <div>
                            <div class="font-medium">👁️ Reveal Grid</div>
                            <div class="text-xs opacity-75">Highlight tiles</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-sky-400 to-blue-400 text-white" data-command="SPEED">
                        <div>
                            <div class="font-medium">⚡ Speed Mode</div>
                            <div class="text-xs opacity-75">Fast animations</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-indigo-500 to-purple-600 text-white" data-command="INFINITE">
                        <div>
                            <div class="font-medium">♾️ Infinite Time</div>
                            <div class="text-xs opacity-75">No timer limit</div>
                        </div>
                    </button>

                    <div class="border-t border-gray-300 my-3 pt-3">
                        <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-gray-600 to-gray-800 text-white font-bold" data-command="REMOVE_ALL_SECRET">
                            <div>
                                <div class="font-medium">🧹 Remove All Effects</div>
                                <div class="text-xs opacity-75">Clear all secret effects</div>
                            </div>
                        </button>
                    </div>

                    <div class="border-t border-red-300 my-3 pt-3">
                        <button class="mobile-touch-btn secret-command-btn bg-gradient-to-r from-red-600 to-red-800 text-white" data-command="ENDGAME">
                            <div>
                                <div class="font-medium">🏁 End Game</div>
                                <div class="text-xs opacity-75">Finish current game</div>
                            </div>
                        </button>
                    </div>
                </div>

                <div class="mt-4 text-xs text-gray-500 text-center border-t border-gray-200 pt-3">
                    💡 Type command names during gameplay
                </div>
            `;

            // Set footer content
            menuFooter.textContent = '🎮 Secret commands activated!';

            // Show the menu using the mobile-responsive system
            showMobileMenu(menuPanel);

            // Set up command buttons
            const commandButtons = menuPanel.querySelectorAll('.secret-command-btn');
            commandButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const command = button.getAttribute('data-command');
                    if (command && SECRET_COMMANDS[command]) {
                        SECRET_COMMANDS[command]();
                        showSecretCommandNotification(command);
                        closeMobileMenu(menuPanel);
                    }
                });
            });
        }

        // Close the secret menu (legacy function for compatibility)
        function closeSecretMenu() {
            const menuPanel = document.getElementById('secret-menu-panel');
            if (menuPanel) {
                closeMobileMenu(menuPanel);
            }
        }

        // Open the customize menu
        function openCustomizeMenu() {
            console.log("Customize menu opened");

            // Create the mobile-responsive customize menu
            const { menuPanel, menuContent } = createMobileMenu('customize-menu-panel', '🎨 Customize', 'left');

            // Get the menu body to add content
            const menuBody = menuContent.querySelector('.mobile-menu-body');
            const menuFooter = menuContent.querySelector('.mobile-menu-footer div');

            // Create the menu content
            menuBody.innerHTML = `
                <div class="space-y-1">
                    <h4 class="text-sm font-bold text-gray-700 mb-2">✨ Visual Effects</h4>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-red-500 to-pink-500 text-white" data-effect="RAINBOW">
                        <div>
                            <div class="font-medium">🌈 Rainbow Mode</div>
                            <div class="text-xs opacity-75">Colorful tiles</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-gray-700 to-gray-900 text-white" data-effect="DARKMODE">
                        <div>
                            <div class="font-medium">🌙 Dark Mode</div>
                            <div class="text-xs opacity-75">Night theme</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-pink-400 to-purple-400 text-white" data-effect="CONFETTI">
                        <div>
                            <div class="font-medium">🎉 Confetti</div>
                            <div class="text-xs opacity-75">Celebration!</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-orange-400 to-red-400 text-white" data-effect="FLASH">
                        <div>
                            <div class="font-medium">⚡ Flash Mode</div>
                            <div class="text-xs opacity-75">Disco lights!</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-indigo-400 to-purple-400 text-white" data-effect="ZOOM">
                        <div>
                            <div class="font-medium">🔍 Zoom Grid</div>
                            <div class="text-xs opacity-75">Bigger tiles</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-teal-400 to-cyan-400 text-white" data-effect="SPIN">
                        <div>
                            <div class="font-medium">🌀 Spin Grid</div>
                            <div class="text-xs opacity-75">360° rotation</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-emerald-400 to-green-400 text-white" data-effect="GLOW">
                        <div>
                            <div class="font-medium">✨ Glow Mode</div>
                            <div class="text-xs opacity-75">Glowing border</div>
                        </div>
                    </button>

                    <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-green-400 to-green-600 text-white" data-effect="MATRIX">
                        <div>
                            <div class="font-medium">🕶️ Matrix Mode</div>
                            <div class="text-xs opacity-75">Enter the Matrix</div>
                        </div>
                    </button>

                    <div class="border-t border-gray-300 my-3 pt-3">
                        <h4 class="text-sm font-bold text-gray-700 mb-2">🎨 Popular Effects</h4>

                        <div class="grid grid-cols-2 gap-2 mb-3">
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-pink-500 to-violet-500 text-white text-sm" data-effect="NEON">
                                <div class="text-center">
                                    <div class="font-medium">💡 Neon</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-blue-300 to-white text-gray-800 text-sm" data-effect="SNOW">
                                <div class="text-center">
                                    <div class="font-medium">❄️ Snow</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-red-500 to-orange-500 text-white text-sm" data-effect="FIRE">
                                <div class="text-center">
                                    <div class="font-medium">🔥 Fire</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-purple-400 to-blue-400 text-white text-sm" data-effect="PULSE">
                                <div class="text-center">
                                    <div class="font-medium">💓 Pulse</div>
                                </div>
                            </button>
                        </div>
                    </div>

                    <div class="border-t border-gray-300 my-3 pt-3">
                        <h4 class="text-sm font-bold text-gray-700 mb-2">🌈 Background Themes</h4>

                        <div class="grid grid-cols-2 gap-2 mb-3">
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-blue-400 to-blue-600 text-white text-sm" data-effect="BG_BLUE">
                                <div class="text-center">
                                    <div class="font-medium">🔵 Blue</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-purple-400 to-purple-600 text-white text-sm" data-effect="BG_PURPLE">
                                <div class="text-center">
                                    <div class="font-medium">🟣 Purple</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-green-400 to-green-600 text-white text-sm" data-effect="BG_GREEN">
                                <div class="text-center">
                                    <div class="font-medium">🟢 Green</div>
                                </div>
                            </button>
                            <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-orange-400 to-pink-500 text-white text-sm" data-effect="BG_SUNSET">
                                <div class="text-center">
                                    <div class="font-medium">🌅 Sunset</div>
                                </div>
                            </button>
                        </div>
                    </div>

                    <div class="border-t border-yellow-300 my-3 pt-3">
                        <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-yellow-500 to-orange-500 text-white font-bold" data-effect="ACHIEVEMENTS">
                            <div>
                                <div class="font-medium">🏆 Achievements</div>
                                <div class="text-xs opacity-75">View your progress</div>
                            </div>
                        </button>

                        <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-indigo-500 to-purple-500 text-white font-bold mt-2" data-effect="ANALYTICS">
                            <div>
                                <div class="font-medium">📊 Analytics</div>
                                <div class="text-xs opacity-75">View detailed statistics</div>
                            </div>
                        </button>
                    </div>

                    <div class="border-t border-red-300 my-3 pt-3">
                        <button class="mobile-touch-btn customize-effect-btn bg-gradient-to-r from-red-600 to-red-800 text-white font-bold" data-effect="REMOVE_ALL_CUSTOMIZE">
                            <div>
                                <div class="font-medium">🧹 Remove All Effects</div>
                                <div class="text-xs opacity-75">Clear all customizations</div>
                            </div>
                        </button>
                    </div>
                </div>

                <div class="mt-4 text-xs text-gray-500 text-center border-t border-gray-200 pt-3">
                    🎨 Click effects to toggle • Mix and match!
                </div>
            `;

            // Set footer content
            menuFooter.textContent = '✨ Customize your experience!';

            // Show the menu using the mobile-responsive system
            showMobileMenu(menuPanel);

            // Set up effect buttons
            const effectButtons = menuPanel.querySelectorAll('.customize-effect-btn');
            effectButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const effect = button.getAttribute('data-effect');
                    if (effect && CUSTOMIZE_EFFECTS[effect]) {
                        CUSTOMIZE_EFFECTS[effect]();
                        showCustomizeNotification(effect);

                        // Track customize effects for achievements
                        if (!effect.startsWith('BG_') && effect !== 'REMOVE_ALL_CUSTOMIZE' && effect !== 'ACHIEVEMENTS' && effect !== 'ANALYTICS') {
                            customizeEffectsUsed.add(effect);
                            checkAchievements(['customize']);
                        }
                    }
                });
            });
        }

        // Close the customize menu (legacy function for compatibility)
        function closeCustomizeMenu() {
            const menuPanel = document.getElementById('customize-menu-panel');
            if (menuPanel) {
                closeMobileMenu(menuPanel);
            }
        }

        // Show customize notification
        function showCustomizeNotification(effect) {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = 'fixed top-4 left-4 bg-purple-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transform -translate-x-full transition-transform duration-300';
            notification.innerHTML = `
                <div class="flex items-center">
                    <span class="text-lg mr-2">🎨</span>
                    <div>
                        <div class="font-bold">Effect Applied!</div>
                        <div class="text-sm">${effect}</div>
                    </div>
                </div>
            `;

            document.body.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.classList.remove('-translate-x-full');
            }, 100);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.classList.add('-translate-x-full');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // New secret commands
        function enableSlowTimeMode() {
            slowTimeEnabled = !slowTimeEnabled;
            console.log(`Slow Time Mode ${slowTimeEnabled ? 'enabled' : 'disabled'}`);
            
            if (slowTimeEnabled) {
                // Slow down the timer in timed mode
                if (currentGameMode === GAME_MODE.TIMED) {
                    clearInterval(timerInterval);
                    timerInterval = setInterval(() => {
                        // Only decrease timer every other second
                        if (Math.floor(Date.now() / 1000) % 2 === 0) {
                            timer--;
                            updateTimerDisplay();
                            
                            if (timer <= 0) {
                                endGame();
                            }
                        }
                    }, 1000);
                    
                    // Add visual indicator
                    const timerEl = document.getElementById('timer-display');
                    if (timerEl) {
                        timerEl.classList.add('text-blue-400', 'animate-pulse');
                    }
                }
            } else {
                // Restore normal timer
                if (currentGameMode === GAME_MODE.TIMED) {
                    clearInterval(timerInterval);
                    startTimer();
                    
                    // Remove visual indicator
                    const timerEl = document.getElementById('timer-display');
                    if (timerEl) {
                        timerEl.classList.remove('text-blue-400', 'animate-pulse');
                    }
                }
            }
        }

        function toggleDarkMode() {
            darkModeEnabled = !darkModeEnabled;
            console.log(`Dark Mode ${darkModeEnabled ? 'enabled' : 'disabled'}`);
            
            const gameContainer = document.getElementById('game-container');
            const body = document.body;
            
            if (darkModeEnabled) {
                // Enable dark mode
                body.classList.add('bg-gray-900');
                
                // Update UI elements
                document.querySelectorAll('.bg-white').forEach(el => {
                    el.classList.remove('bg-white');
                    el.classList.add('bg-gray-800', 'text-white');
                });
                
                document.querySelectorAll('.text-gray-800').forEach(el => {
                    el.classList.remove('text-gray-800');
                    el.classList.add('text-gray-200');
                });
                
                document.querySelectorAll('.text-gray-600').forEach(el => {
                    el.classList.remove('text-gray-600');
                    el.classList.add('text-gray-400');
                });
                
                // Update grid
                const gridContainer = document.getElementById('grid-container');
                if (gridContainer) {
                    gridContainer.classList.remove('bg-green-800/50');
                    gridContainer.classList.add('bg-blue-900/50');
                }
                
                // Add dark mode style
                if (!document.getElementById('dark-mode-style')) {
                    const style = document.createElement('style');
                    style.id = 'dark-mode-style';
                    style.textContent = `
                        .tile {
                            background-color: #2d3748 !important;
                            color: #e2e8f0 !important;
                            border-color: #4a5568 !important;
                        }
                        .tile.selected {
                            background-color: #4299e1 !important;
                        }
                        .tile.correct {
                            background-color: #38a169 !important;
                        }
                        .tile.incorrect {
                            background-color: #e53e3e !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                // Disable dark mode
                body.classList.remove('bg-gray-900');
                
                // Update UI elements
                document.querySelectorAll('.bg-gray-800').forEach(el => {
                    el.classList.remove('bg-gray-800', 'text-white');
                    el.classList.add('bg-white');
                });
                
                document.querySelectorAll('.text-gray-200').forEach(el => {
                    el.classList.remove('text-gray-200');
                    el.classList.add('text-gray-800');
                });
                
                document.querySelectorAll('.text-gray-400').forEach(el => {
                    el.classList.remove('text-gray-400');
                    el.classList.add('text-gray-600');
                });
                
                // Update grid
                const gridContainer = document.getElementById('grid-container');
                if (gridContainer) {
                    gridContainer.classList.remove('bg-blue-900/50');
                    gridContainer.classList.add('bg-green-800/50');
                }
                
                // Remove dark mode style
                const darkModeStyle = document.getElementById('dark-mode-style');
                if (darkModeStyle) {
                    darkModeStyle.remove();
                }
            }
        }

        function triggerConfetti() {
            console.log("Confetti triggered!");
            
            // Create confetti effect
            for (let i = 0; i < 100; i++) {
                createConfettiPiece();
            }
        }

        function createConfettiPiece() {
            const colors = ['#f94144', '#f3722c', '#f8961e', '#f9c74f', '#90be6d', '#43aa8b', '#577590'];
            const confetti = document.createElement('div');
            
            // Random position, color, and rotation
            const left = Math.random() * 100;
            const color = colors[Math.floor(Math.random() * colors.length)];
            const rotation = Math.random() * 360;
            const size = Math.random() * 10 + 5;
            
            confetti.style.cssText = `
                position: fixed;
                top: -20px;
                left: ${left}vw;
                width: ${size}px;
                height: ${size}px;
                background-color: ${color};
                transform: rotate(${rotation}deg);
                z-index: 1000;
                pointer-events: none;
            `;
            
            document.body.appendChild(confetti);
            
            // Animate falling
            const duration = Math.random() * 3000 + 2000;
            const keyframes = [
                { transform: `translateY(0) rotate(${rotation}deg)`, opacity: 1 },
                { transform: `translateY(${window.innerHeight + 100}px) rotate(${rotation + 360}deg)`, opacity: 0 }
            ];
            
            const animation = confetti.animate(keyframes, {
                duration: duration,
                easing: 'cubic-bezier(0.1, 0.8, 0.3, 1)',
                fill: 'forwards'
            });
            
            animation.onfinish = () => {
                confetti.remove();
            };
        }

        function shuffleGrid() {
            console.log("Grid shuffled!");
            
            // Animate the shuffle
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                // Add shake animation
                tile.classList.add('animate-shake');
                
                // Remove animation after it completes
                setTimeout(() => {
                    tile.classList.remove('animate-shake');
                }, 500);
            });
            
            // Regenerate the grid after animation
            setTimeout(() => {
                generateGrid();
                renderGrid();
            }, 500);
            
            // Add shake animation CSS if it doesn't exist
            if (!document.getElementById('shake-animation')) {
                const style = document.createElement('style');
                style.id = 'shake-animation';
                style.textContent = `
                    @keyframes shake {
                        0% { transform: translate(0, 0) rotate(0deg); }
                        20% { transform: translate(-5px, 0) rotate(-5deg); }
                        40% { transform: translate(5px, 0) rotate(5deg); }
                        60% { transform: translate(-3px, 0) rotate(-3deg); }
                        80% { transform: translate(3px, 0) rotate(3deg); }
                        100% { transform: translate(0, 0) rotate(0deg); }
                    }
                    .animate-shake {
                        animation: shake 0.5s ease-in-out;
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function enableMatrixMode() {
            matrixModeEnabled = !matrixModeEnabled;
            console.log(`Matrix Mode ${matrixModeEnabled ? 'enabled' : 'disabled'}`);
            
            if (matrixModeEnabled) {
                // Create matrix background
                const canvas = document.createElement('canvas');
                canvas.id = 'matrix-canvas';
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    z-index: -1;
                `;
                document.body.appendChild(canvas);
                
                // Initialize matrix effect
                initMatrix(canvas);
                
                // Make game elements more visible
                document.querySelectorAll('.bg-white, .tile').forEach(el => {
                    el.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.5)';
                });
            } else {
                // Remove matrix background
                const canvas = document.getElementById('matrix-canvas');
                if (canvas) {
                    canvas.remove();
                }
                
                // Remove box shadows
                document.querySelectorAll('.bg-white, .tile').forEach(el => {
                    el.style.boxShadow = '';
                });
            }
        }

        function initMatrix(canvas) {
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Matrix characters
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            const fontSize = 14;
            const columns = canvas.width / fontSize;
            
            // Array to track the y position of each column
            const drops = [];
            for (let i = 0; i < columns; i++) {
                drops[i] = 1;
            }
            
            // Drawing the characters
            function draw() {
                // Black BG with opacity for the trail effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#0f0'; // Green text
                ctx.font = fontSize + 'px monospace';
                
                // Loop through drops
                for (let i = 0; i < drops.length; i++) {
                    // Random character
                    const text = chars.charAt(Math.floor(Math.random() * chars.length));
                    
                    // x = i * fontSize, y = drops[i] * fontSize
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    // Randomly reset some drops to the top
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    
                    // Increment y coordinate
                    drops[i]++;
                }
            }
            
            // Animation loop
            const matrixInterval = setInterval(draw, 33);
            
            // Store interval ID for cleanup
            canvas.matrixInterval = matrixInterval;
            
            // Resize handler
            window.addEventListener('resize', () => {
                if (matrixModeEnabled) {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
            });
        }

        function endGameCommand() {
            console.log("End Game command activated");
            
            // Create a confirmation dialog
            const overlay = document.createElement('div');
            overlay.className = 'fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50';
            overlay.innerHTML = `
                <div class="bg-white p-6 rounded-xl max-w-md w-11/12 text-center">
                    <h3 class="text-xl font-bold text-red-600 mb-3">⚠️ End Game?</h3>
                    <p class="mb-4">Are you sure you want to end the current game?</p>
                    <div class="flex space-x-3">
                        <button id="cancel-end-game" class="flex-1 py-2 px-4 bg-gray-200 hover:bg-gray-300 rounded-lg transition-colors">
                            Cancel
                        </button>
                        <button id="confirm-end-game" class="flex-1 py-2 px-4 bg-red-500 hover:bg-red-600 text-white rounded-lg transition-colors">
                            End Game
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Set up event listeners
            document.getElementById('cancel-end-game').addEventListener('click', () => {
                document.body.removeChild(overlay);
            });
            
            document.getElementById('confirm-end-game').addEventListener('click', () => {
                document.body.removeChild(overlay);
                // End the game with a slight delay for better UX
                setTimeout(() => {
                    endGame();
                }, 300);
            });
        }

        // New secret commands
        function freezeTimer() {
            if (currentGameMode === GAME_MODE.TIMED) {
                clearInterval(timerInterval);
                console.log("Timer frozen!");
            }
        }

        function scoreBoost() {
            score += 1000;
            scoreEl.textContent = score;
            console.log("Score boosted by 1000!");
        }

        function showHint() {
            const possibleWords = findAllPossibleWords();
            const unFoundWords = possibleWords.filter(word => !foundWords.has(word));

            if (unFoundWords.length === 0) {
                showHintPopup("🎉 Amazing!", "You've found all possible words!", "success");
                return;
            }

            const hint = unFoundWords[Math.floor(Math.random() * unFoundWords.length)];
            const points = calculatePoints(hint.length);
            showHintPopup("💡 Hint", `Try finding "${hint}" (${hint.length} letters, ${points} points)`, "hint");
        }

        function showHintPopup(title, message, type = "hint") {
            // Remove any existing hint popup
            const existingPopup = document.getElementById('hint-popup');
            if (existingPopup) {
                existingPopup.remove();
            }

            // Create the hint popup
            const popup = document.createElement('div');
            popup.id = 'hint-popup';
            popup.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 transition-all duration-300 scale-95 opacity-0';

            const bgColor = type === "success" ? "bg-green-500" : "bg-blue-500";
            const borderColor = type === "success" ? "border-green-300" : "border-blue-300";

            popup.innerHTML = `
                <div class="bg-white rounded-xl shadow-2xl border-2 ${borderColor} p-6 max-w-sm mx-4">
                    <div class="text-center">
                        <div class="w-16 h-16 ${bgColor} rounded-full flex items-center justify-center mx-auto mb-4">
                            <span class="text-2xl text-white">${type === "success" ? "🎉" : "💡"}</span>
                        </div>
                        <h3 class="text-xl font-bold text-gray-800 mb-2">${title}</h3>
                        <p class="text-gray-600 mb-4">${message}</p>
                        <button id="close-hint-popup" class="px-6 py-2 ${bgColor} text-white rounded-lg hover:opacity-90 transition-all font-medium">
                            Got it!
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(popup);

            // Animate in
            setTimeout(() => {
                popup.classList.remove('scale-95', 'opacity-0');
                popup.classList.add('scale-100', 'opacity-100');
            }, 10);

            // Set up close button
            popup.querySelector('#close-hint-popup').addEventListener('click', () => {
                closeHintPopup();
            });

            // Auto-close after 5 seconds
            setTimeout(() => {
                closeHintPopup();
            }, 5000);

            // Close when clicking outside
            popup.addEventListener('click', (e) => {
                if (e.target === popup) {
                    closeHintPopup();
                }
            });
        }

        function closeHintPopup() {
            const popup = document.getElementById('hint-popup');
            if (!popup) return;

            popup.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.remove();
                }
            }, 300);
        }

        function luckyGrid() {
            // Replace grid with vowel-heavy letters for easier words
            const luckyLetters = "AEIOURSTLNAEIOURSTN";
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    grid[i][j] = luckyLetters[Math.floor(Math.random() * luckyLetters.length)];
                }
            }
            renderGrid();
            console.log("Lucky grid generated!");
        }

        function resetScore() {
            score = 0;
            foundWords.clear();
            scoreEl.textContent = score;
            wordCountEl.textContent = foundWords.size;
            console.log("Score reset!");
        }

        function flashMode() {
            document.body.style.animation = 'flash 0.5s ease-in-out 3';
            setTimeout(() => document.body.style.animation = '', 1500);
        }

        function zoomMode() {
            const grid = document.getElementById('grid-container');
            grid.style.transform = grid.style.transform === 'scale(1.2)' ? 'scale(1)' : 'scale(1.2)';
            grid.style.transition = 'transform 0.3s ease';
        }

        function spinGrid() {
            const grid = document.getElementById('grid-container');
            grid.style.transform = 'rotate(360deg)';
            grid.style.transition = 'transform 1s ease';
            setTimeout(() => {
                grid.style.transform = 'rotate(0deg)';
            }, 1000);
        }

        function doublePoints() {
            if (!window.originalCalculatePoints) {
                window.originalCalculatePoints = calculatePoints;
                calculatePoints = (length) => window.originalCalculatePoints(length) * 2;
                console.log("Double points activated!");
            } else {
                calculatePoints = window.originalCalculatePoints;
                window.originalCalculatePoints = null;
                console.log("Double points deactivated!");
            }
        }

        function revealWord() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.style.backgroundColor = '#fbbf24';
                tile.style.color = '#000';
            });
            setTimeout(() => {
                tiles.forEach(tile => {
                    tile.style.backgroundColor = '';
                    tile.style.color = '';
                });
            }, 2000);
        }

        function shakeGrid() {
            const grid = document.getElementById('grid-container');
            grid.style.animation = 'shake 0.5s ease-in-out';
            setTimeout(() => grid.style.animation = '', 500);
        }

        function glowMode() {
            const grid = document.getElementById('grid-container');
            grid.style.boxShadow = grid.style.boxShadow ? '' : '0 0 20px #4ade80, 0 0 40px #4ade80';
            grid.style.transition = 'box-shadow 0.3s ease';
        }

        function speedMode() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.style.transition = 'all 0.05s ease';
            });
            setTimeout(() => {
                tiles.forEach(tile => {
                    tile.style.transition = '';
                });
            }, 10000);
        }

        function magicGrid() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    tile.style.transform = 'scale(1.2) rotate(180deg)';
                    setTimeout(() => {
                        tile.style.transform = '';
                    }, 300);
                }, i * 50);
            });
        }

        // New customize effects
        function neonMode() {
            const grid = document.getElementById('grid-container');
            const isNeon = grid.classList.contains('neon-mode');

            if (!isNeon) {
                grid.classList.add('neon-mode');
                if (!document.getElementById('neon-style')) {
                    const style = document.createElement('style');
                    style.id = 'neon-style';
                    style.textContent = `
                        .neon-mode .tile {
                            background: linear-gradient(45deg, #ff006e, #8338ec, #3a86ff) !important;
                            box-shadow: 0 0 10px #ff006e, 0 0 20px #8338ec, 0 0 30px #3a86ff !important;
                            color: white !important;
                            text-shadow: 0 0 5px white !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                grid.classList.remove('neon-mode');
            }
        }

        function retroMode() {
            const body = document.body;
            const isRetro = body.classList.contains('retro-mode');

            if (!isRetro) {
                body.classList.add('retro-mode');
                if (!document.getElementById('retro-style')) {
                    const style = document.createElement('style');
                    style.id = 'retro-style';
                    style.textContent = `
                        .retro-mode {
                            background: linear-gradient(45deg, #ff9a9e, #fecfef, #fecfef, #ff9a9e) !important;
                            font-family: 'Courier New', monospace !important;
                        }
                        .retro-mode .tile {
                            background: #ff6b6b !important;
                            border: 2px solid #4ecdc4 !important;
                            color: white !important;
                            font-weight: bold !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                body.classList.remove('retro-mode');
            }
        }

        function snowEffect() {
            if (document.getElementById('snow-container')) {
                document.getElementById('snow-container').remove();
                return;
            }

            const snowContainer = document.createElement('div');
            snowContainer.id = 'snow-container';
            snowContainer.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                pointer-events: none; z-index: 1000;
            `;
            document.body.appendChild(snowContainer);

            for (let i = 0; i < 50; i++) {
                createSnowflake(snowContainer);
            }
        }

        function createSnowflake(container) {
            const snowflake = document.createElement('div');
            snowflake.innerHTML = '❄️';
            snowflake.style.cssText = `
                position: absolute; top: -20px; font-size: ${Math.random() * 20 + 10}px;
                left: ${Math.random() * 100}%; animation: fall ${Math.random() * 3 + 2}s linear infinite;
            `;

            if (!document.getElementById('snow-animation')) {
                const style = document.createElement('style');
                style.id = 'snow-animation';
                style.textContent = `
                    @keyframes fall {
                        to { transform: translateY(100vh) rotate(360deg); }
                    }
                `;
                document.head.appendChild(style);
            }

            container.appendChild(snowflake);
            setTimeout(() => snowflake.remove(), 5000);
        }

        function fireEffect() {
            const grid = document.getElementById('grid-container');
            const isFire = grid.classList.contains('fire-mode');

            if (!isFire) {
                grid.classList.add('fire-mode');
                if (!document.getElementById('fire-style')) {
                    const style = document.createElement('style');
                    style.id = 'fire-style';
                    style.textContent = `
                        .fire-mode {
                            background: radial-gradient(circle, #ff4500, #ff6347, #ff0000) !important;
                        }
                        .fire-mode .tile {
                            background: linear-gradient(45deg, #ff4500, #ff6347) !important;
                            animation: flicker 0.5s ease-in-out infinite alternate !important;
                        }
                        @keyframes flicker {
                            0% { box-shadow: 0 0 5px #ff4500; }
                            100% { box-shadow: 0 0 20px #ff0000, 0 0 30px #ff4500; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                grid.classList.remove('fire-mode');
            }
        }

        function bubbleMode() {
            if (document.getElementById('bubble-container')) {
                document.getElementById('bubble-container').remove();
                return;
            }

            const bubbleContainer = document.createElement('div');
            bubbleContainer.id = 'bubble-container';
            bubbleContainer.style.cssText = `
                position: fixed; bottom: 0; left: 0; width: 100%; height: 100%;
                pointer-events: none; z-index: 999;
            `;
            document.body.appendChild(bubbleContainer);

            setInterval(() => createBubble(bubbleContainer), 300);
        }

        function createBubble(container) {
            const bubble = document.createElement('div');
            const size = Math.random() * 30 + 10;
            bubble.style.cssText = `
                position: absolute; bottom: -50px; left: ${Math.random() * 100}%;
                width: ${size}px; height: ${size}px; border-radius: 50%;
                background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8), rgba(0,150,255,0.3));
                animation: float ${Math.random() * 4 + 3}s ease-in-out;
            `;

            if (!document.getElementById('bubble-animation')) {
                const style = document.createElement('style');
                style.id = 'bubble-animation';
                style.textContent = `
                    @keyframes float {
                        to { transform: translateY(-100vh) translateX(${Math.random() * 100 - 50}px); opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
            }

            container.appendChild(bubble);
            setTimeout(() => bubble.remove(), 7000);
        }

        function pulseMode() {
            const tiles = document.querySelectorAll('.tile');
            const isPulsing = tiles[0]?.classList.contains('pulse-mode');

            if (!isPulsing) {
                tiles.forEach(tile => tile.classList.add('pulse-mode'));
                if (!document.getElementById('pulse-style')) {
                    const style = document.createElement('style');
                    style.id = 'pulse-style';
                    style.textContent = `
                        .pulse-mode {
                            animation: pulse 2s ease-in-out infinite !important;
                        }
                        @keyframes pulse {
                            0%, 100% { transform: scale(1); }
                            50% { transform: scale(1.05); }
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                tiles.forEach(tile => tile.classList.remove('pulse-mode'));
            }
        }

        function gradientMode() {
            const grid = document.getElementById('grid-container');
            const isGradient = grid.classList.contains('gradient-mode');

            if (!isGradient) {
                grid.classList.add('gradient-mode');
                if (!document.getElementById('gradient-style')) {
                    const style = document.createElement('style');
                    style.id = 'gradient-style';
                    style.textContent = `
                        .gradient-mode .tile {
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
                            color: white !important;
                        }
                        .gradient-mode .tile:nth-child(even) {
                            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%) !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                grid.classList.remove('gradient-mode');
            }
        }

        function mirrorMode() {
            const grid = document.getElementById('grid-container');
            const isMirrored = grid.style.transform.includes('scaleX(-1)');

            if (!isMirrored) {
                grid.style.transform = (grid.style.transform || '') + ' scaleX(-1)';
            } else {
                grid.style.transform = grid.style.transform.replace('scaleX(-1)', '').trim();
            }
        }

        function waveEffect() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    tile.style.transform = 'translateY(-10px)';
                    setTimeout(() => {
                        tile.style.transform = '';
                    }, 200);
                }, i * 100);
            });
        }

        // Background customization functions
        function setBlueBackground() {
            document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('blue');
            backgroundsUsed.add('blue');
            sessionBackgrounds.add('blue');
        }

        function setPurpleBackground() {
            document.body.style.background = 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('purple');
            backgroundsUsed.add('purple');
            sessionBackgrounds.add('purple');
        }

        function setGreenBackground() {
            document.body.style.background = 'linear-gradient(135deg, #d299c2 0%, #fef9d7 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('green');
            backgroundsUsed.add('green');
            sessionBackgrounds.add('green');
        }

        function setSunsetBackground() {
            document.body.style.background = 'linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('sunset');
        }

        function setOceanBackground() {
            document.body.style.background = 'linear-gradient(135deg, #667db6 0%, #0082c8 25%, #0082c8 50%, #667db6 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('ocean');
        }

        function setForestBackground() {
            document.body.style.background = 'linear-gradient(135deg, #134e5e 0%, #71b280 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('forest');
        }

        function setSpaceBackground() {
            document.body.style.background = 'linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%)';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('space');

            // Add stars effect
            if (!document.getElementById('stars-container')) {
                const starsContainer = document.createElement('div');
                starsContainer.id = 'stars-container';
                starsContainer.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    pointer-events: none; z-index: -1;
                `;

                // Create stars
                for (let i = 0; i < 100; i++) {
                    const star = document.createElement('div');
                    star.style.cssText = `
                        position: absolute; width: 2px; height: 2px; background: white;
                        border-radius: 50%; top: ${Math.random() * 100}%; left: ${Math.random() * 100}%;
                        animation: twinkle ${Math.random() * 3 + 1}s ease-in-out infinite alternate;
                    `;
                    starsContainer.appendChild(star);
                }

                // Add twinkle animation
                if (!document.getElementById('twinkle-animation')) {
                    const style = document.createElement('style');
                    style.id = 'twinkle-animation';
                    style.textContent = `
                        @keyframes twinkle {
                            0% { opacity: 0.3; }
                            100% { opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(starsContainer);
            }
        }

        function setRainbowBackground() {
            document.body.style.background = 'linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3)';
            document.body.style.backgroundSize = '400% 400%';
            document.body.style.backgroundAttachment = 'fixed';
            document.body.style.animation = 'rainbow-shift 8s ease infinite';
            updateTileTheme('rainbow');

            if (!document.getElementById('rainbow-animation')) {
                const style = document.createElement('style');
                style.id = 'rainbow-animation';
                style.textContent = `
                    @keyframes rainbow-shift {
                        0% { background-position: 0% 50%; }
                        50% { background-position: 100% 50%; }
                        100% { background-position: 0% 50%; }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function setDotsPattern() {
            document.body.style.background = `
                radial-gradient(circle at 25% 25%, #ffffff 2px, transparent 2px),
                radial-gradient(circle at 75% 75%, #ffffff 2px, transparent 2px),
                linear-gradient(135deg, #667eea 0%, #764ba2 100%)
            `;
            document.body.style.backgroundSize = '50px 50px, 50px 50px, 100% 100%';
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('dots');
        }

        function setStripesPattern() {
            document.body.style.background = `
                repeating-linear-gradient(
                    45deg,
                    transparent,
                    transparent 10px,
                    rgba(255,255,255,0.1) 10px,
                    rgba(255,255,255,0.1) 20px
                ),
                linear-gradient(135deg, #667eea 0%, #764ba2 100%)
            `;
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('stripes');
        }

        function setWavesPattern() {
            document.body.style.background = `
                linear-gradient(135deg, #667eea 0%, #764ba2 100%)
            `;
            document.body.style.backgroundAttachment = 'fixed';
            updateTileTheme('waves');

            // Add animated wave overlay
            if (!document.getElementById('waves-overlay')) {
                const wavesOverlay = document.createElement('div');
                wavesOverlay.id = 'waves-overlay';
                wavesOverlay.style.cssText = `
                    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                    pointer-events: none; z-index: -1; opacity: 0.3;
                    background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.1'%3E%3Cpath d='M30 30c0-11.046-8.954-20-20-20s-20 8.954-20 20 8.954 20 20 20 20-8.954 20-20zm0 0c0 11.046 8.954 20 20 20s20-8.954 20-20-8.954-20-20-20-20 8.954-20 20z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
                    animation: wave-move 20s ease-in-out infinite;
                `;

                if (!document.getElementById('wave-animation')) {
                    const style = document.createElement('style');
                    style.id = 'wave-animation';
                    style.textContent = `
                        @keyframes wave-move {
                            0%, 100% { transform: translateX(0) translateY(0); }
                            25% { transform: translateX(-20px) translateY(-10px); }
                            50% { transform: translateX(20px) translateY(10px); }
                            75% { transform: translateX(-10px) translateY(20px); }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(wavesOverlay);
            }
        }

        function resetBackground() {
            // Remove all custom backgrounds and effects
            document.body.style.background = '';
            document.body.style.backgroundSize = '';
            document.body.style.backgroundAttachment = '';
            document.body.style.animation = '';

            // Remove special effect containers
            const starsContainer = document.getElementById('stars-container');
            if (starsContainer) starsContainer.remove();

            const wavesOverlay = document.getElementById('waves-overlay');
            if (wavesOverlay) wavesOverlay.remove();

            // Reset to original gradient
            document.body.className = 'flex items-center justify-center min-h-screen';
            document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            updateTileTheme('default');
        }

        // Function to update tile themes based on background
        function updateTileTheme(theme) {
            // Remove existing theme styles
            const existingStyle = document.getElementById('tile-theme-style');
            if (existingStyle) {
                existingStyle.remove();
            }

            // Create new theme style
            const style = document.createElement('style');
            style.id = 'tile-theme-style';

            let tileStyles = '';

            switch(theme) {
                case 'blue':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%) !important;
                            border-color: #2196f3 !important;
                            color: #1565c0 !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #2196f3 0%, #1976d2 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'purple':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%) !important;
                            border-color: #9c27b0 !important;
                            color: #6a1b9a !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'green':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #e8f5e8 0%, #c8e6c9 100%) !important;
                            border-color: #4caf50 !important;
                            color: #2e7d32 !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'sunset':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #fff3e0 0%, #ffcc80 100%) !important;
                            border-color: #ff9800 !important;
                            color: #e65100 !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'ocean':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #e0f2f1 0%, #80cbc4 100%) !important;
                            border-color: #00796b !important;
                            color: #004d40 !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #00796b 0%, #00695c 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'forest':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #e8f5e8 0%, #a5d6a7 100%) !important;
                            border-color: #388e3c !important;
                            color: #1b5e20 !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #388e3c 0%, #2e7d32 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                case 'space':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #263238 0%, #37474f 100%) !important;
                            border-color: #607d8b !important;
                            color: #eceff1 !important;
                            box-shadow: 0 0 10px rgba(96, 125, 139, 0.3) !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #607d8b 0%, #455a64 100%) !important;
                            color: white !important;
                            box-shadow: 0 0 15px rgba(96, 125, 139, 0.6) !important;
                        }
                    `;
                    break;
                case 'rainbow':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(45deg, #ff9a9e 0%, #fecfef 25%, #fecfef 50%, #ff9a9e 100%) !important;
                            border-color: #ff6b6b !important;
                            color: #d63031 !important;
                            animation: rainbow-tile 3s ease-in-out infinite !important;
                        }
                        .tile.selected {
                            background: linear-gradient(45deg, #ff6b6b 0%, #ee5a6f 100%) !important;
                            color: white !important;
                        }
                        @keyframes rainbow-tile {
                            0%, 100% { filter: hue-rotate(0deg); }
                            50% { filter: hue-rotate(180deg); }
                        }
                    `;
                    break;
                case 'dots':
                case 'stripes':
                case 'waves':
                    tileStyles = `
                        .tile {
                            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%) !important;
                            border-color: #6c757d !important;
                            color: #495057 !important;
                            backdrop-filter: blur(5px) !important;
                        }
                        .tile.selected {
                            background: linear-gradient(135deg, #6c757d 0%, #495057 100%) !important;
                            color: white !important;
                        }
                    `;
                    break;
                default:
                    tileStyles = `
                        .tile {
                            background-color: #f4e4bc !important;
                            border-color: #d4b896 !important;
                            color: #5d4037 !important;
                        }
                        .tile.selected {
                            background-color: #4ade80 !important;
                            color: white !important;
                            border-color: #22c55e !important;
                        }
                    `;
                    break;
            }

            style.textContent = tileStyles;
            document.head.appendChild(style);
        }

        // New secret command functions
        function infiniteTime() {
            if (currentGameMode === GAME_MODE.TIMED) {
                clearInterval(timerInterval);
                timer = 999999;
                updateTimerDisplay();
                console.log("Infinite time activated!");
            }
        }

        function vowelGrid() {
            const vowels = "AEIOUAEIOUAEIOU";
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    grid[i][j] = vowels[Math.floor(Math.random() * vowels.length)];
                }
            }
            renderGrid();
            console.log("Vowel grid activated!");
        }

        function megaPoints() {
            if (!window.originalCalculatePoints) {
                window.originalCalculatePoints = calculatePoints;
                calculatePoints = (length) => window.originalCalculatePoints(length) * 10;
                console.log("Mega points (10x) activated!");
                showCustomizeNotification("Mega Points ON - 10x scoring!");
            } else {
                calculatePoints = window.originalCalculatePoints;
                window.originalCalculatePoints = null;
                console.log("Mega points deactivated!");
                showCustomizeNotification("Mega Points OFF - Normal scoring restored");
            }
        }

        function ghostMode() {
            const tiles = document.querySelectorAll('.tile');
            const isGhost = tiles[0]?.style.opacity === '0.3';

            tiles.forEach(tile => {
                tile.style.opacity = isGhost ? '1' : '0.3';
                tile.style.transition = 'opacity 0.5s ease';
            });

            if (isGhost) {
                console.log("Ghost mode deactivated!");
                showCustomizeNotification("Ghost Mode OFF - Tiles visible");
            } else {
                console.log("Ghost mode activated!");
                showCustomizeNotification("Ghost Mode ON - Tiles transparent");
            }
        }

        function matrixRain() {
            if (document.getElementById('matrix-rain')) {
                document.getElementById('matrix-rain').remove();
                matrixModeActive = false;
                return;
            }

            matrixModeActive = true;

            const matrixContainer = document.createElement('div');
            matrixContainer.id = 'matrix-rain';
            matrixContainer.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                pointer-events: none; z-index: 1000; overflow: hidden;
            `;

            for (let i = 0; i < 20; i++) {
                const column = document.createElement('div');
                column.style.cssText = `
                    position: absolute; top: -100px; left: ${i * 5}%;
                    color: #00ff00; font-family: monospace; font-size: 14px;
                    animation: matrix-fall ${Math.random() * 3 + 2}s linear infinite;
                `;
                column.textContent = '01010101010101010101';
                matrixContainer.appendChild(column);
            }

            if (!document.getElementById('matrix-animation')) {
                const style = document.createElement('style');
                style.id = 'matrix-animation';
                style.textContent = `
                    @keyframes matrix-fall {
                        to { transform: translateY(100vh); }
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(matrixContainer);
            setTimeout(() => matrixContainer.remove(), 10000);
        }

        function teleportTiles() {
            const tiles = document.querySelectorAll('.tile');
            const positions = Array.from(tiles).map(tile => ({
                top: tile.style.top,
                left: tile.style.left,
                transform: tile.style.transform
            }));

            tiles.forEach((tile, i) => {
                const randomIndex = Math.floor(Math.random() * positions.length);
                tile.style.transition = 'all 0.5s ease';
                tile.style.transform = 'scale(0)';

                setTimeout(() => {
                    tile.style.transform = 'scale(1) rotate(360deg)';
                }, 250);
            });

            setTimeout(() => {
                tiles.forEach(tile => {
                    tile.style.transform = '';
                    tile.style.transition = '';
                });
            }, 1000);
        }

        function quantumGrid() {
            const tiles = document.querySelectorAll('.tile');

            // Check if quantum is already active
            if (window.quantumInterval) {
                clearInterval(window.quantumInterval);
                window.quantumInterval = null;
                tiles.forEach(tile => {
                    tile.style.opacity = '1';
                });
                console.log("Quantum grid deactivated!");
                showCustomizeNotification("Quantum Grid OFF - Stable tiles");
                return;
            }

            // Start quantum mode
            window.quantumInterval = setInterval(() => {
                tiles.forEach(tile => {
                    tile.style.opacity = Math.random() > 0.5 ? '1' : '0.3';
                });
            }, 500);

            console.log("Quantum grid activated!");
            showCustomizeNotification("Quantum Grid ON - Phasing tiles");
        }

        function laserMode() {
            const grid = document.getElementById('grid-container');
            grid.style.boxShadow = '0 0 50px #ff0000, inset 0 0 50px #ff0000';
            grid.style.border = '2px solid #ff0000';

            setTimeout(() => {
                grid.style.boxShadow = '';
                grid.style.border = '';
            }, 5000);
        }

        function portalEffect() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    tile.style.transform = 'rotateY(180deg) scale(0.8)';
                    tile.style.background = 'radial-gradient(circle, #8b5cf6, #3b82f6)';

                    setTimeout(() => {
                        tile.style.transform = '';
                        tile.style.background = '';
                    }, 1000);
                }, i * 100);
            });
        }

        function chaosMode() {
            const effects = [shuffleGrid, spinGrid, shakeGrid, flashMode, revealWord];
            const randomEffect = effects[Math.floor(Math.random() * effects.length)];
            randomEffect();

            setTimeout(() => {
                const anotherEffect = effects[Math.floor(Math.random() * effects.length)];
                anotherEffect();
            }, 1000);

            console.log("Chaos mode activated!");
        }

        // New customize effect functions
        function discoMode() {
            const tiles = document.querySelectorAll('.tile');
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];

            // Check if disco is already active
            if (window.discoInterval) {
                clearInterval(window.discoInterval);
                window.discoInterval = null;
                tiles.forEach(tile => {
                    tile.style.backgroundColor = '';
                    tile.style.color = '';
                });
                console.log("Disco mode deactivated!");
                return;
            }

            // Start disco mode
            window.discoInterval = setInterval(() => {
                tiles.forEach(tile => {
                    tile.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    tile.style.color = 'white';
                });
            }, 200);

            console.log("Disco mode activated! Click again to stop.");
        }

        function hologramEffect() {
            const grid = document.getElementById('grid-container');
            const isHologram = grid.classList.contains('hologram-mode');

            if (!isHologram) {
                grid.classList.add('hologram-mode');
                if (!document.getElementById('hologram-style')) {
                    const style = document.createElement('style');
                    style.id = 'hologram-style';
                    style.textContent = `
                        .hologram-mode {
                            background: linear-gradient(45deg, transparent 30%, rgba(0,255,255,0.3) 50%, transparent 70%) !important;
                            animation: hologram-scan 2s ease-in-out infinite !important;
                        }
                        .hologram-mode .tile {
                            background: rgba(0,255,255,0.1) !important;
                            border: 1px solid #00ffff !important;
                            color: #00ffff !important;
                            text-shadow: 0 0 10px #00ffff !important;
                        }
                        @keyframes hologram-scan {
                            0%, 100% { filter: hue-rotate(0deg) brightness(1); }
                            50% { filter: hue-rotate(180deg) brightness(1.2); }
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                grid.classList.remove('hologram-mode');
            }
        }

        function cyberpunkTheme() {
            const body = document.body;
            const isCyberpunk = body.classList.contains('cyberpunk-mode');

            if (!isCyberpunk) {
                body.classList.add('cyberpunk-mode');
                if (!document.getElementById('cyberpunk-style')) {
                    const style = document.createElement('style');
                    style.id = 'cyberpunk-style';
                    style.textContent = `
                        .cyberpunk-mode {
                            background: linear-gradient(135deg, #0a0a0a 0%, #1a0033 50%, #000000 100%) !important;
                        }
                        .cyberpunk-mode .tile {
                            background: linear-gradient(45deg, #ff00ff, #00ffff) !important;
                            border: 2px solid #ff00ff !important;
                            color: #000000 !important;
                            font-weight: bold !important;
                            text-shadow: 0 0 5px #ffffff !important;
                            box-shadow: 0 0 15px #ff00ff !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                body.classList.remove('cyberpunk-mode');
            }
        }

        function vintageFilter() {
            const body = document.body;
            const isVintage = body.classList.contains('vintage-mode');

            if (!isVintage) {
                body.classList.add('vintage-mode');
                if (!document.getElementById('vintage-style')) {
                    const style = document.createElement('style');
                    style.id = 'vintage-style';
                    style.textContent = `
                        .vintage-mode {
                            filter: sepia(0.8) contrast(1.2) brightness(0.9) !important;
                            background: linear-gradient(135deg, #8b7355 0%, #d2b48c 100%) !important;
                        }
                        .vintage-mode .tile {
                            background: #f5deb3 !important;
                            border: 2px solid #8b4513 !important;
                            color: #654321 !important;
                            font-family: 'Times New Roman', serif !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                body.classList.remove('vintage-mode');
            }
        }

        function glitchEffect() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    tile.style.animation = 'glitch 0.3s ease-in-out';
                    tile.style.filter = 'hue-rotate(180deg) contrast(2)';

                    setTimeout(() => {
                        tile.style.animation = '';
                        tile.style.filter = '';
                    }, 300);
                }, i * 50);
            });

            if (!document.getElementById('glitch-animation')) {
                const style = document.createElement('style');
                style.id = 'glitch-animation';
                style.textContent = `
                    @keyframes glitch {
                        0%, 100% { transform: translateX(0); }
                        20% { transform: translateX(-2px) skew(-5deg); }
                        40% { transform: translateX(2px) skew(5deg); }
                        60% { transform: translateX(-1px) skew(-2deg); }
                        80% { transform: translateX(1px) skew(2deg); }
                    }
                `;
                document.head.appendChild(style);
            }
        }

        function auroraEffect() {
            const body = document.body;
            const isAurora = body.classList.contains('aurora-mode');

            if (!isAurora) {
                body.classList.add('aurora-mode');
                if (!document.getElementById('aurora-style')) {
                    const style = document.createElement('style');
                    style.id = 'aurora-style';
                    style.textContent = `
                        .aurora-mode {
                            background: linear-gradient(45deg, #001122, #003366, #004488, #0066aa) !important;
                            background-size: 400% 400% !important;
                            animation: aurora-shift 8s ease infinite !important;
                        }
                        .aurora-mode .tile {
                            background: rgba(0,255,150,0.2) !important;
                            border: 1px solid #00ff96 !important;
                            color: #ffffff !important;
                            box-shadow: 0 0 20px rgba(0,255,150,0.3) !important;
                        }
                        @keyframes aurora-shift {
                            0%, 100% { background-position: 0% 50%; }
                            50% { background-position: 100% 50%; }
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                body.classList.remove('aurora-mode');
            }
        }

        function crystalTheme() {
            const tiles = document.querySelectorAll('.tile');
            const isCrystal = tiles[0]?.classList.contains('crystal-mode');

            if (!isCrystal) {
                tiles.forEach(tile => tile.classList.add('crystal-mode'));
                if (!document.getElementById('crystal-style')) {
                    const style = document.createElement('style');
                    style.id = 'crystal-style';
                    style.textContent = `
                        .crystal-mode {
                            background: linear-gradient(135deg, #e8f4fd 0%, #b3d9ff 50%, #e8f4fd 100%) !important;
                            border: 2px solid #4da6ff !important;
                            color: #0066cc !important;
                            box-shadow: 0 0 20px rgba(77,166,255,0.5), inset 0 0 20px rgba(255,255,255,0.3) !important;
                            transform: perspective(100px) rotateX(10deg) !important;
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                tiles.forEach(tile => tile.classList.remove('crystal-mode'));
            }
        }

        function lavaEffect() {
            const grid = document.getElementById('grid-container');
            const isLava = grid.classList.contains('lava-mode');

            if (!isLava) {
                grid.classList.add('lava-mode');
                if (!document.getElementById('lava-style')) {
                    const style = document.createElement('style');
                    style.id = 'lava-style';
                    style.textContent = `
                        .lava-mode {
                            background: radial-gradient(circle, #ff4500, #ff6347, #ff0000) !important;
                            animation: lava-bubble 3s ease-in-out infinite !important;
                        }
                        .lava-mode .tile {
                            background: linear-gradient(45deg, #ff4500, #ff6347) !important;
                            border: 2px solid #ff0000 !important;
                            color: #ffffff !important;
                            animation: lava-glow 2s ease-in-out infinite alternate !important;
                        }
                        @keyframes lava-bubble {
                            0%, 100% { transform: scale(1); }
                            50% { transform: scale(1.02); }
                        }
                        @keyframes lava-glow {
                            0% { box-shadow: 0 0 10px #ff4500; }
                            100% { box-shadow: 0 0 30px #ff0000; }
                        }
                    `;
                    document.head.appendChild(style);
                }
                console.log("Lava effect activated!");
            } else {
                grid.classList.remove('lava-mode');
                console.log("Lava effect deactivated!");
            }
        }

        function electricEffect() {
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach((tile, i) => {
                setTimeout(() => {
                    tile.style.boxShadow = '0 0 20px #ffff00, 0 0 40px #ffff00';
                    tile.style.backgroundColor = '#ffff00';
                    tile.style.color = '#000000';

                    setTimeout(() => {
                        tile.style.boxShadow = '';
                        tile.style.backgroundColor = '';
                        tile.style.color = '';
                    }, 200);
                }, Math.random() * 1000);
            });
        }

        function cosmicTheme() {
            const body = document.body;
            const isCosmic = body.classList.contains('cosmic-mode');

            if (!isCosmic) {
                body.classList.add('cosmic-mode');
                if (!document.getElementById('cosmic-style')) {
                    const style = document.createElement('style');
                    style.id = 'cosmic-style';
                    style.textContent = `
                        .cosmic-mode {
                            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%) !important;
                        }
                        .cosmic-mode .tile {
                            background: linear-gradient(45deg, #4a00e0, #8e2de2) !important;
                            border: 1px solid #a8edea !important;
                            color: #ffffff !important;
                            box-shadow: 0 0 15px rgba(168,237,234,0.5) !important;
                            animation: cosmic-float 4s ease-in-out infinite !important;
                        }
                        @keyframes cosmic-float {
                            0%, 100% { transform: translateY(0px); }
                            50% { transform: translateY(-5px); }
                        }
                    `;
                    document.head.appendChild(style);
                }
            } else {
                body.classList.remove('cosmic-mode');
            }
        }

        // Remove all effects functions
        function removeAllSecretEffects() {
            // Reset all secret command effects

            // Reset god mode
            if (window.originalCheckWord) {
                checkWord = window.originalCheckWord;
                window.originalCheckWord = null;
                godModeEnabled = false;
            }

            // Reset points multipliers
            if (window.originalCalculatePoints) {
                calculatePoints = window.originalCalculatePoints;
                window.originalCalculatePoints = null;
                bigPointsModeEnabled = false;
            }

            // Reset timer effects
            if (currentGameMode === GAME_MODE.TIMED && !slowTimeEnabled) {
                clearInterval(timerInterval);
                startTimer();
            }
            slowTimeEnabled = false;

            // Reset tile effects
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.style.opacity = '';
                tile.style.transition = '';
                tile.style.transform = '';
                tile.style.animation = '';
                tile.style.filter = '';
                tile.style.backgroundColor = '';
                tile.style.color = '';
                tile.style.boxShadow = '';
            });

            // Reset grid effects
            const grid = document.getElementById('grid-container');
            if (grid) {
                grid.style.boxShadow = '';
                grid.style.border = '';
                grid.style.animation = '';
                grid.style.transform = '';
            }

            // Remove special effect containers
            const matrixRain = document.getElementById('matrix-rain');
            if (matrixRain) matrixRain.remove();

            // Clear any intervals
            clearInterval(window.discoInterval);
            clearInterval(window.quantumInterval);

            console.log("All secret effects removed!");
        }

        function removeAllCustomizeEffects() {
            // Remove all customize effect classes and styles
            const body = document.body;
            const grid = document.getElementById('grid-container');
            const tiles = document.querySelectorAll('.tile');

            // Remove body classes
            body.classList.remove(
                'retro-mode', 'cyberpunk-mode', 'vintage-mode',
                'aurora-mode', 'cosmic-mode'
            );

            // Remove grid classes
            if (grid) {
                grid.classList.remove(
                    'neon-mode', 'hologram-mode', 'fire-mode',
                    'lava-mode', 'gradient-mode'
                );
                grid.style.boxShadow = '';
                grid.style.animation = '';
                grid.style.transform = '';
                grid.style.filter = '';
            }

            // Remove tile classes
            tiles.forEach(tile => {
                tile.classList.remove(
                    'pulse-mode', 'crystal-mode'
                );
                tile.style.animation = '';
                tile.style.transform = '';
                tile.style.filter = '';
                tile.style.backgroundColor = '';
                tile.style.color = '';
                tile.style.boxShadow = '';
                tile.style.border = '';
                tile.style.textShadow = '';
                tile.style.fontFamily = '';
                tile.style.transition = '';
            });

            // Remove special effect containers
            const effectContainers = [
                'snow-container', 'bubble-container', 'stars-container',
                'waves-overlay', 'matrix-rain'
            ];
            effectContainers.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.remove();
            });

            // Remove dynamic styles
            const dynamicStyles = [
                'neon-style', 'retro-style', 'snow-animation', 'bubble-animation',
                'fire-style', 'pulse-style', 'gradient-style', 'hologram-style',
                'cyberpunk-style', 'vintage-style', 'glitch-animation', 'aurora-style',
                'crystal-style', 'lava-style', 'cosmic-style', 'twinkle-animation',
                'rainbow-animation', 'wave-animation', 'matrix-animation'
            ];
            dynamicStyles.forEach(id => {
                const style = document.getElementById(id);
                if (style) style.remove();
            });

            // Clear intervals
            clearInterval(window.discoInterval);
            clearInterval(window.bubbleInterval);

            // Reset background to default
            resetBackground();

            console.log("All customize effects removed!");
        }

        // Achievement system functions
        function loadAchievements() {
            const saved = localStorage.getItem('wordHuntAchievements');
            if (saved) {
                const savedAchievements = JSON.parse(saved);
                Object.keys(savedAchievements).forEach(key => {
                    if (achievements[key]) {
                        achievements[key].unlocked = savedAchievements[key].unlocked;
                    }
                });
            }

            const savedStats = localStorage.getItem('wordHuntStats');
            if (savedStats) {
                const stats = JSON.parse(savedStats);
                gamesPlayed = stats.gamesPlayed || 0;
                totalScore = stats.totalScore || 0;
                bestScore = stats.bestScore || 0;
                totalWordsFound = stats.totalWordsFound || 0;
                customizeEffectsUsed = new Set(stats.customizeEffectsUsed || []);
            }
        }

        function saveAchievements() {
            // Debounce saving to prevent excessive localStorage writes
            if (window.saveTimeout) {
                clearTimeout(window.saveTimeout);
            }

            window.saveTimeout = setTimeout(() => {
                try {
                    localStorage.setItem('wordHuntAchievements', JSON.stringify(achievements));
                    localStorage.setItem('wordHuntStats', JSON.stringify({
                        gamesPlayed,
                        totalScore,
                        bestScore,
                        totalWordsFound,
                        customizeEffectsUsed: Array.from(customizeEffectsUsed)
                    }));
                } catch (error) {
                    console.warn('Failed to save achievements:', error);
                }
            }, 500);
        }

        // Analytics functions
        function loadAnalyticsData() {
            try {
                const saved = localStorage.getItem(ANALYTICS_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    analyticsData = {
                        ...analyticsData,
                        ...parsed,
                        wordPatterns: new Map(parsed.wordPatterns || []),
                        dailyStats: new Map(parsed.dailyStats || []),
                        weeklyStats: new Map(parsed.weeklyStats || []),
                        monthlyStats: new Map(parsed.monthlyStats || [])
                    };
                }
            } catch (error) {
                console.error('Error loading analytics data:', error);
            }
        }

        function saveAnalyticsData() {
            try {
                const dataToSave = {
                    ...analyticsData,
                    wordPatterns: Array.from(analyticsData.wordPatterns.entries()),
                    dailyStats: Array.from(analyticsData.dailyStats.entries()),
                    weeklyStats: Array.from(analyticsData.weeklyStats.entries()),
                    monthlyStats: Array.from(analyticsData.monthlyStats.entries()),
                    lastUpdated: new Date().toISOString()
                };
                localStorage.setItem(ANALYTICS_KEY, JSON.stringify(dataToSave));
            } catch (error) {
                console.error('Error saving analytics data:', error);
            }
        }

        function trackGameSession(sessionData) {
            const session = {
                id: Date.now() + Math.random(),
                timestamp: new Date().toISOString(),
                date: new Date().toDateString(),
                timeOfDay: new Date().getHours(),
                gameMode: currentGameMode,
                boardSize: currentBoardSize,
                score: sessionData.score,
                wordsFound: sessionData.wordsFound,
                gameTime: sessionData.gameTime,
                averageWordLength: sessionData.averageWordLength,
                longestWord: sessionData.longestWord,
                shortestWord: sessionData.shortestWord,
                wordsPerMinute: sessionData.wordsPerMinute,
                scorePerWord: sessionData.scorePerWord,
                uniqueLettersUsed: sessionData.uniqueLettersUsed,
                gridCoverage: sessionData.gridCoverage,
                secretCommandsUsed: secretCommandsUsed,
                powerupsUsed: sessionData.powerupsUsed || 0,
                achievements: sessionData.achievementsUnlocked || 0
            };

            // Add to sessions array (keep last 100 sessions)
            analyticsData.sessions.push(session);
            if (analyticsData.sessions.length > 100) {
                analyticsData.sessions.shift();
            }

            // Update word patterns
            sessionData.words.forEach(word => {
                const current = analyticsData.wordPatterns.get(word) || {
                    count: 0,
                    totalScore: 0,
                    averageScore: 0,
                    firstFound: session.timestamp,
                    lastFound: session.timestamp
                };
                current.count++;
                current.totalScore += getWordScore(word);
                current.averageScore = current.totalScore / current.count;
                current.lastFound = session.timestamp;
                analyticsData.wordPatterns.set(word, current);
            });

            // Update daily stats
            updateDailyStats(session);

            // Update performance metrics
            updatePerformanceMetrics();

            // Generate insights
            generateInsights();

            // Save data
            saveAnalyticsData();
        }

        function updateDailyStats(session) {
            const dateKey = session.date;
            const current = analyticsData.dailyStats.get(dateKey) || {
                date: dateKey,
                gamesPlayed: 0,
                totalScore: 0,
                totalWords: 0,
                totalTime: 0,
                bestScore: 0,
                averageScore: 0,
                averageWords: 0,
                averageTime: 0
            };

            current.gamesPlayed++;
            current.totalScore += session.score;
            current.totalWords += session.wordsFound;
            current.totalTime += session.gameTime;
            current.bestScore = Math.max(current.bestScore, session.score);
            current.averageScore = current.totalScore / current.gamesPlayed;
            current.averageWords = current.totalWords / current.gamesPlayed;
            current.averageTime = current.totalTime / current.gamesPlayed;

            analyticsData.dailyStats.set(dateKey, current);
        }

        function updatePerformanceMetrics() {
            const sessions = analyticsData.sessions;
            if (sessions.length === 0) return;

            const metrics = analyticsData.performanceMetrics;

            // Calculate averages
            metrics.averageScore = sessions.reduce((sum, s) => sum + s.score, 0) / sessions.length;
            metrics.averageWordsPerGame = sessions.reduce((sum, s) => sum + s.wordsFound, 0) / sessions.length;
            metrics.averageGameDuration = sessions.reduce((sum, s) => sum + s.gameTime, 0) / sessions.length;
            metrics.totalPlayTime = sessions.reduce((sum, s) => sum + s.gameTime, 0);

            // Find most productive time of day
            const timeOfDayStats = {};
            sessions.forEach(s => {
                const hour = s.timeOfDay;
                if (!timeOfDayStats[hour]) {
                    timeOfDayStats[hour] = { totalScore: 0, count: 0 };
                }
                timeOfDayStats[hour].totalScore += s.score;
                timeOfDayStats[hour].count++;
            });

            let bestHour = 0;
            let bestAverage = 0;
            Object.entries(timeOfDayStats).forEach(([hour, stats]) => {
                const average = stats.totalScore / stats.count;
                if (average > bestAverage) {
                    bestAverage = average;
                    bestHour = parseInt(hour);
                }
            });
            metrics.mostProductiveTimeOfDay = bestHour;

            // Calculate improvement trend (last 10 games vs previous 10)
            if (sessions.length >= 20) {
                const recent = sessions.slice(-10);
                const previous = sessions.slice(-20, -10);
                const recentAvg = recent.reduce((sum, s) => sum + s.score, 0) / recent.length;
                const previousAvg = previous.reduce((sum, s) => sum + s.score, 0) / previous.length;
                metrics.improvementTrend = ((recentAvg - previousAvg) / previousAvg) * 100;
            }

            // Find favorite word length
            const wordLengthStats = {};
            Array.from(analyticsData.wordPatterns.entries()).forEach(([word, stats]) => {
                const length = word.length;
                if (!wordLengthStats[length]) {
                    wordLengthStats[length] = 0;
                }
                wordLengthStats[length] += stats.count;
            });

            let favoriteLength = 0;
            let maxCount = 0;
            Object.entries(wordLengthStats).forEach(([length, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    favoriteLength = parseInt(length);
                }
            });
            metrics.favoriteWordLength = favoriteLength;
        }

        function generateInsights() {
            const insights = [];
            const sessions = analyticsData.sessions;
            const metrics = analyticsData.performanceMetrics;

            if (sessions.length < 5) return; // Need enough data for insights

            // Performance trend insight
            if (metrics.improvementTrend > 10) {
                insights.push({
                    type: 'positive',
                    title: 'Great Progress!',
                    message: `Your scores have improved by ${metrics.improvementTrend.toFixed(1)}% in recent games!`,
                    icon: '📈'
                });
            } else if (metrics.improvementTrend < -10) {
                insights.push({
                    type: 'suggestion',
                    title: 'Room for Improvement',
                    message: 'Try taking breaks between games or practicing with different board sizes.',
                    icon: '💡'
                });
            }

            // Time of day insight
            if (metrics.mostProductiveTimeOfDay !== null) {
                const timeStr = metrics.mostProductiveTimeOfDay === 0 ? '12 AM' :
                              metrics.mostProductiveTimeOfDay < 12 ? `${metrics.mostProductiveTimeOfDay} AM` :
                              metrics.mostProductiveTimeOfDay === 12 ? '12 PM' :
                              `${metrics.mostProductiveTimeOfDay - 12} PM`;
                insights.push({
                    type: 'info',
                    title: 'Peak Performance Time',
                    message: `You score best around ${timeStr}. Try playing during this time for better results!`,
                    icon: '⏰'
                });
            }

            // Word length insight
            if (metrics.favoriteWordLength > 0) {
                insights.push({
                    type: 'info',
                    title: 'Word Length Preference',
                    message: `You excel at finding ${metrics.favoriteWordLength}-letter words. Try focusing on longer words for bonus points!`,
                    icon: '📝'
                });
            }

            // Recent performance insight
            const recentSessions = sessions.slice(-5);
            const recentAvg = recentSessions.reduce((sum, s) => sum + s.score, 0) / recentSessions.length;
            if (recentAvg > metrics.averageScore * 1.2) {
                insights.push({
                    type: 'positive',
                    title: 'Hot Streak!',
                    message: 'Your recent games are well above your average. Keep it up!',
                    icon: '🔥'
                });
            }

            analyticsData.insights = insights.slice(0, 5); // Keep top 5 insights
        }

        // Analytics Dashboard UI
        function openAnalyticsMenu() {
            console.log("Analytics menu opened");

            // Create the mobile-responsive analytics menu
            const { menuPanel, menuContent } = createMobileMenu('analytics-menu-panel', '📊 Analytics Dashboard', 'right');

            // Get the menu body to add content
            const menuBody = menuContent.querySelector('.mobile-menu-body');
            const menuFooter = menuContent.querySelector('.mobile-menu-footer div');

            // Calculate current statistics
            const sessions = analyticsData.sessions;
            const metrics = analyticsData.performanceMetrics;
            const totalGames = sessions.length;
            const totalPlayTimeHours = Math.round(metrics.totalPlayTime / 3600);
            const totalPlayTimeMinutes = Math.round((metrics.totalPlayTime % 3600) / 60);

            // Create the analytics dashboard content
            menuBody.innerHTML = `
                <div class="space-y-4">
                    <!-- Overview Stats -->
                    <div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                            <span class="mr-2">📈</span> Performance Overview
                        </h4>
                        <div class="grid grid-cols-2 gap-3">
                            <div class="text-center">
                                <div class="text-lg font-bold text-blue-600">${totalGames}</div>
                                <div class="text-xs text-gray-600">Games Played</div>
                            </div>
                            <div class="text-center">
                                <div class="text-lg font-bold text-green-600">${Math.round(metrics.averageScore)}</div>
                                <div class="text-xs text-gray-600">Avg Score</div>
                            </div>
                            <div class="text-center">
                                <div class="text-lg font-bold text-purple-600">${Math.round(metrics.averageWordsPerGame)}</div>
                                <div class="text-xs text-gray-600">Avg Words</div>
                            </div>
                            <div class="text-center">
                                <div class="text-lg font-bold text-orange-600">${totalPlayTimeHours}h ${totalPlayTimeMinutes}m</div>
                                <div class="text-xs text-gray-600">Play Time</div>
                            </div>
                        </div>
                    </div>

                    <!-- Performance Trend -->
                    <div class="bg-white rounded-lg border border-gray-200 p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                            <span class="mr-2">📊</span> Score Trend (Last 10 Games)
                        </h4>
                        <div id="score-trend-chart" class="h-24 bg-gray-50 rounded flex items-end justify-between px-2 py-2">
                            ${generateScoreTrendChart()}
                        </div>
                        ${metrics.improvementTrend !== 0 ? `
                            <div class="mt-2 text-xs text-center ${metrics.improvementTrend > 0 ? 'text-green-600' : 'text-red-600'}">
                                ${metrics.improvementTrend > 0 ? '↗️' : '↘️'} ${Math.abs(metrics.improvementTrend).toFixed(1)}% vs previous 10 games
                            </div>
                        ` : ''}
                    </div>

                    <!-- Word Patterns -->
                    <div class="bg-white rounded-lg border border-gray-200 p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                            <span class="mr-2">📝</span> Word Patterns
                        </h4>
                        ${generateWordPatternsSection()}
                    </div>

                    <!-- Time Analysis -->
                    <div class="bg-white rounded-lg border border-gray-200 p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                            <span class="mr-2">⏰</span> Time Analysis
                        </h4>
                        ${generateTimeAnalysisSection()}
                    </div>

                    <!-- Insights & Recommendations -->
                    <div class="bg-gradient-to-r from-yellow-50 to-orange-50 rounded-lg p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                            <span class="mr-2">💡</span> Insights & Tips
                        </h4>
                        ${generateInsightsSection()}
                    </div>

                    <!-- Recent Performance -->
                    <div class="bg-white rounded-lg border border-gray-200 p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                            <span class="mr-2">🎯</span> Recent Games
                        </h4>
                        ${generateRecentGamesSection()}
                    </div>
                </div>
            `;

            // Set footer content
            menuFooter.textContent = `Last updated: ${new Date().toLocaleDateString()}`;

            // Show the menu using the mobile-responsive system
            showMobileMenu(menuPanel);
        }

        function generateScoreTrendChart() {
            const sessions = analyticsData.sessions.slice(-10); // Last 10 games
            if (sessions.length === 0) {
                return '<div class="text-center text-gray-500 text-xs">No games played yet</div>';
            }

            const maxScore = Math.max(...sessions.map(s => s.score));
            const minScore = Math.min(...sessions.map(s => s.score));
            const range = maxScore - minScore || 1;

            return sessions.map((session, index) => {
                const height = Math.max(10, ((session.score - minScore) / range) * 60 + 10);
                const color = index === sessions.length - 1 ? 'bg-blue-500' : 'bg-gray-400';
                return `
                    <div class="flex flex-col items-center">
                        <div class="${color} rounded-t" style="width: 12px; height: ${height}px;" title="Game ${index + 1}: ${session.score} points"></div>
                        <div class="text-xs text-gray-500 mt-1">${index + 1}</div>
                    </div>
                `;
            }).join('');
        }

        function generateWordPatternsSection() {
            const wordPatterns = Array.from(analyticsData.wordPatterns.entries())
                .sort((a, b) => b[1].count - a[1].count)
                .slice(0, 5);

            if (wordPatterns.length === 0) {
                return '<div class="text-center text-gray-500 text-sm">No word data available yet</div>';
            }

            const metrics = analyticsData.performanceMetrics;

            return `
                <div class="space-y-3">
                    <div class="grid grid-cols-2 gap-3 text-center">
                        <div>
                            <div class="text-lg font-bold text-indigo-600">${metrics.favoriteWordLength || 'N/A'}</div>
                            <div class="text-xs text-gray-600">Favorite Length</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-green-600">${wordPatterns.length > 0 ? wordPatterns[0][0] : 'N/A'}</div>
                            <div class="text-xs text-gray-600">Most Found</div>
                        </div>
                    </div>

                    <div class="space-y-2">
                        <div class="text-xs font-medium text-gray-700">Top Words:</div>
                        ${wordPatterns.map(([word, stats]) => `
                            <div class="flex justify-between items-center bg-gray-50 rounded px-2 py-1">
                                <span class="font-mono text-sm">${word.toUpperCase()}</span>
                                <span class="text-xs text-gray-600">${stats.count}x</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function generateTimeAnalysisSection() {
            const metrics = analyticsData.performanceMetrics;
            const sessions = analyticsData.sessions;

            if (sessions.length === 0) {
                return '<div class="text-center text-gray-500 text-sm">No time data available yet</div>';
            }

            // Calculate time of day distribution
            const timeDistribution = {};
            sessions.forEach(s => {
                const hour = s.timeOfDay;
                if (!timeDistribution[hour]) {
                    timeDistribution[hour] = { count: 0, totalScore: 0 };
                }
                timeDistribution[hour].count++;
                timeDistribution[hour].totalScore += s.score;
            });

            const bestTimeData = Object.entries(timeDistribution)
                .map(([hour, data]) => ({
                    hour: parseInt(hour),
                    avgScore: data.totalScore / data.count,
                    count: data.count
                }))
                .sort((a, b) => b.avgScore - a.avgScore)[0];

            const formatTime = (hour) => {
                if (hour === 0) return '12 AM';
                if (hour < 12) return `${hour} AM`;
                if (hour === 12) return '12 PM';
                return `${hour - 12} PM`;
            };

            return `
                <div class="space-y-3">
                    <div class="grid grid-cols-2 gap-3 text-center">
                        <div>
                            <div class="text-lg font-bold text-blue-600">${formatTime(metrics.mostProductiveTimeOfDay || 0)}</div>
                            <div class="text-xs text-gray-600">Best Time</div>
                        </div>
                        <div>
                            <div class="text-lg font-bold text-purple-600">${Math.round(metrics.averageGameDuration / 60)}m</div>
                            <div class="text-xs text-gray-600">Avg Duration</div>
                        </div>
                    </div>

                    <div class="bg-gray-50 rounded p-2">
                        <div class="text-xs font-medium text-gray-700 mb-2">Performance by Time:</div>
                        <div class="flex justify-between items-end h-12">
                            ${Object.entries(timeDistribution).slice(0, 6).map(([hour, data]) => {
                                const avgScore = data.totalScore / data.count;
                                const maxAvg = Math.max(...Object.values(timeDistribution).map(d => d.totalScore / d.count));
                                const height = (avgScore / maxAvg) * 40;
                                return `
                                    <div class="flex flex-col items-center">
                                        <div class="bg-blue-400 rounded-t" style="width: 8px; height: ${height}px;" title="${formatTime(parseInt(hour))}: ${Math.round(avgScore)} avg"></div>
                                        <div class="text-xs text-gray-500 mt-1">${hour}h</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                </div>
            `;
        }

        function generateInsightsSection() {
            const insights = analyticsData.insights;

            if (insights.length === 0) {
                return `
                    <div class="text-center text-gray-500 text-sm">
                        <div class="mb-2">🎯</div>
                        <div>Play more games to unlock personalized insights!</div>
                    </div>
                `;
            }

            return `
                <div class="space-y-2">
                    ${insights.map(insight => `
                        <div class="flex items-start space-x-3 p-3 bg-white rounded-lg border border-gray-200">
                            <div class="text-lg">${insight.icon}</div>
                            <div class="flex-1">
                                <div class="font-medium text-sm text-gray-800">${insight.title}</div>
                                <div class="text-xs text-gray-600 mt-1">${insight.message}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function generateRecentGamesSection() {
            const recentSessions = analyticsData.sessions.slice(-5).reverse(); // Last 5 games, newest first

            if (recentSessions.length === 0) {
                return '<div class="text-center text-gray-500 text-sm">No recent games to display</div>';
            }

            return `
                <div class="space-y-2">
                    ${recentSessions.map((session, index) => {
                        const date = new Date(session.timestamp);
                        const timeAgo = getTimeAgo(date);
                        const gameMode = session.gameMode === 'timed' ? '⏱️' : '♾️';
                        const boardSize = `${session.boardSize}×${session.boardSize}`;

                        return `
                            <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                                <div class="flex items-center space-x-3">
                                    <div class="text-lg">${gameMode}</div>
                                    <div>
                                        <div class="font-medium text-sm">${session.score} points</div>
                                        <div class="text-xs text-gray-600">${session.wordsFound} words • ${boardSize} • ${timeAgo}</div>
                                    </div>
                                </div>
                                <div class="text-right">
                                    <div class="text-sm font-medium ${session.score > analyticsData.performanceMetrics.averageScore ? 'text-green-600' : 'text-gray-600'}">
                                        ${session.score > analyticsData.performanceMetrics.averageScore ? '↗️' : '→'}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }

        function getTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }

        // Tutorial System Functions
        function loadTutorialData() {
            try {
                const saved = localStorage.getItem(TUTORIAL_KEY);
                if (saved) {
                    tutorialData = { ...tutorialData, ...JSON.parse(saved) };
                }
            } catch (error) {
                console.error('Error loading tutorial data:', error);
            }
        }

        function saveTutorialData() {
            try {
                localStorage.setItem(TUTORIAL_KEY, JSON.stringify(tutorialData));
            } catch (error) {
                console.error('Error saving tutorial data:', error);
            }
        }

        function isFirstTimeUser() {
            return tutorialData.firstTimeUser && !tutorialData.completed;
        }

        function startTutorial() {
            console.log("Starting tutorial");
            tutorialData.currentStep = 0;
            tutorialData.firstTimeUser = false;
            saveTutorialData();

            // Switch to practice mode and start tutorial
            startTutorialPracticeMode();
        }

        function startTutorialPracticeMode() {
            // Hide opening UI and show game container
            hideOpeningUI();

            // Set up practice mode
            currentGameMode = GAME_MODE.UNLIMITED; // Use unlimited mode for practice
            GRID_SIZE = BOARD_SIZE.SMALL; // Use 4x4 for tutorial

            // Create a predefined practice grid with good word opportunities
            createTutorialGrid();

            // Initialize practice game state
            initializeTutorialGame();

            // Start the tutorial steps
            showTutorialStep(0);
        }

        function createTutorialGrid() {
            // Create a carefully designed grid with obvious words for tutorial
            grid = [
                ['C', 'A', 'T', 'S'],
                ['O', 'R', 'E', 'H'],
                ['D', 'O', 'G', 'E'],
                ['M', 'A', 'N', 'Y']
            ];

            // This grid contains words like: CAT, CATS, DOG, MAN, MANY, ORE, CODE, etc.
            console.log("Tutorial practice grid created:", grid);
        }

        function initializeTutorialGame() {
            // Reset game state for tutorial
            score = 0;
            timer = 999; // Unlimited time for tutorial
            foundWords = new Set();
            currentPath = [];

            // Reset achievement tracking variables
            gameStartTime = Date.now();
            wordsFoundInTime = 0;
            currentStreak = 0;
            invalidWordCount = 0;
            firstWordTime = 0;
            tilesUsed.clear();
            sessionBackgrounds.clear();
            activeEffectsCount = 0;

            // Reset power-up state
            powerupSpawns.clear();
            activePowerups.clear();
            powerupEffects = {
                timeFreeze: false,
                pointMultiplier: 1,
                wordMagnet: false
            };

            // Update UI elements
            const scoreEl = document.getElementById('score');
            if (scoreEl) scoreEl.textContent = '0';

            const timerDisplayEl = document.getElementById('timer-display');
            if (timerDisplayEl) {
                timerDisplayEl.textContent = "TUTORIAL";
                timerDisplayEl.classList.add('bg-green-500', 'hover:bg-green-600');
                timerDisplayEl.classList.remove('bg-red-500', 'hover:bg-red-600', 'cursor-pointer');
                timerDisplayEl.title = "Tutorial Mode - No Time Limit";
            }

            const wordCountEl = document.getElementById('word-count');
            if (wordCountEl) wordCountEl.textContent = '0';

            const currentWordDisplayEl = document.getElementById('current-word-display');
            if (currentWordDisplayEl) {
                currentWordDisplayEl.classList.add('opacity-0', 'transform', '-translate-y-2');
            }

            // Update grid layout for tutorial
            updateGridLayout();

            // Render the tutorial grid
            renderGrid();

            // Add event listeners
            addEventListeners();

            console.log("Tutorial game initialized");
        }

        function showTutorialStep(stepIndex) {
            if (stepIndex >= TUTORIAL_STEPS.length) {
                completeTutorial();
                return;
            }

            const step = TUTORIAL_STEPS[stepIndex];
            tutorialData.currentStep = stepIndex;

            // Remove any existing tutorial elements
            removeTutorialElements();

            // Create tutorial overlay
            const overlay = document.createElement('div');
            overlay.id = 'tutorial-overlay';
            overlay.className = 'tutorial-overlay';

            // Create tutorial popup
            const popup = document.createElement('div');
            popup.className = 'tutorial-popup';
            popup.style.position = 'fixed';
            popup.style.zIndex = '1001';

            // Add content based on step type
            if (step.action === 'highlight') {
                createHighlightTutorial(step, popup, overlay);
            } else if (step.action === 'demo') {
                createDemoTutorial(step, popup, overlay);
            } else if (step.action === 'guided_practice') {
                createGuidedPracticeTutorial(step, popup, overlay);
            } else if (step.action === 'free_practice') {
                createFreePracticeTutorial(step, popup, overlay);
            } else if (step.action === 'completion') {
                createCompletionTutorial(step, popup, overlay);
            } else {
                createCenterTutorial(step, popup, overlay);
            }

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Show with animation
            setTimeout(() => {
                overlay.classList.add('show');
            }, 50);

            saveTutorialData();
        }

        function createCenterTutorial(step, popup, overlay) {
            // Center tutorials should block interaction
            overlay.classList.add('interactive');

            popup.innerHTML = `
                <div class="tutorial-header">
                    <h3 class="text-xl font-bold text-gray-800">${step.title}</h3>
                    <p class="text-sm text-gray-600 mt-1">${step.description}</p>
                </div>
                <div class="tutorial-content">
                    <p class="text-gray-700">${step.content}</p>
                    <div class="tutorial-progress">
                        <div class="tutorial-progress-bar" style="width: ${((tutorialData.currentStep + 1) / TUTORIAL_STEPS.length) * 100}%"></div>
                    </div>
                    <div class="text-xs text-gray-500 text-center">
                        Step ${tutorialData.currentStep + 1} of ${TUTORIAL_STEPS.length}
                    </div>
                </div>
                <div class="tutorial-footer">
                    ${tutorialData.currentStep > 0 ? '<button class="tutorial-btn secondary" onclick="previousTutorialStep()">← Previous</button>' : '<div></div>'}
                    <button class="tutorial-btn" onclick="nextTutorialStep()">
                        ${tutorialData.currentStep === TUTORIAL_STEPS.length - 1 ? 'Finish' : 'Next →'}
                    </button>
                </div>
            `;
        }

        function createHighlightTutorial(step, popup, overlay) {
            // Highlight tutorials should allow board interaction
            // Don't add 'interactive' class to overlay

            // Position popup relative to target
            const target = step.target ? document.querySelector(step.target) : null;

            if (target) {
                // Create highlight element
                const highlight = document.createElement('div');
                highlight.className = 'tutorial-highlight';
                highlight.id = 'tutorial-highlight';

                // Position highlight over target
                const rect = target.getBoundingClientRect();
                highlight.style.left = (rect.left - 5) + 'px';
                highlight.style.top = (rect.top - 5) + 'px';
                highlight.style.width = (rect.width + 10) + 'px';
                highlight.style.height = (rect.height + 10) + 'px';

                document.body.appendChild(highlight);

                // Position popup
                positionTutorialPopup(popup, target, step.position);
            }

            popup.innerHTML = `
                <div class="tutorial-header">
                    <button class="tutorial-close" onclick="closeTutorialModal()" title="Close tutorial">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                    <h3 class="text-base font-bold text-gray-800">${step.title}</h3>
                    <p class="text-xs text-gray-600 mt-1">${step.description}</p>
                </div>
                <div class="tutorial-content">
                    <p class="text-gray-700 text-sm">${step.content}</p>
                </div>
                <div class="tutorial-footer">
                    ${tutorialData.currentStep > 0 ? '<button class="tutorial-btn secondary text-xs py-1 px-2" onclick="previousTutorialStep()">← Back</button>' : '<div></div>'}
                    <button class="tutorial-btn text-xs py-1 px-3" onclick="nextTutorialStep()">
                        Got it!
                    </button>
                </div>
            `;
        }

        function createInteractiveTutorial(step, popup, overlay) {
            // For interactive steps, we wait for user action
            const target = step.target ? document.querySelector(step.target) : null;

            if (target) {
                const highlight = document.createElement('div');
                highlight.className = 'tutorial-highlight';
                highlight.id = 'tutorial-highlight';

                const rect = target.getBoundingClientRect();
                highlight.style.left = (rect.left - 5) + 'px';
                highlight.style.top = (rect.top - 5) + 'px';
                highlight.style.width = (rect.width + 10) + 'px';
                highlight.style.height = (rect.height + 10) + 'px';

                document.body.appendChild(highlight);
                positionTutorialPopup(popup, target, step.position);
            }

            popup.innerHTML = `
                <div class="tutorial-header">
                    <h3 class="text-lg font-bold text-gray-800">${step.title}</h3>
                    <p class="text-sm text-gray-600 mt-1">${step.description}</p>
                </div>
                <div class="tutorial-content">
                    <p class="text-gray-700 text-sm">${step.content}</p>
                    <div class="mt-3 p-3 bg-blue-50 rounded-lg">
                        <p class="text-xs text-blue-700">💡 <strong>Tip:</strong> We'll automatically continue when you find your first word!</p>
                    </div>
                </div>
                <div class="tutorial-footer">
                    <button class="tutorial-btn secondary" onclick="skipTutorialStep()">Skip this step</button>
                    <div class="text-xs text-gray-500">Waiting for action...</div>
                </div>
            `;

            // Set up listener for word found
            if (step.id === 'first_word') {
                window.tutorialWordListener = function() {
                    setTimeout(() => {
                        nextTutorialStep();
                    }, 1000); // Small delay to let user see the word was found
                };
            }
        }

        function positionTutorialPopup(popup, target, position) {
            const rect = target.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const popupWidth = Math.min(350, viewportWidth - 40); // Responsive width

            popup.style.position = 'fixed';
            popup.style.maxWidth = popupWidth + 'px';
            popup.style.width = popupWidth + 'px';
            popup.style.zIndex = '1001';

            // Calculate best position based on available space
            let left, top;

            switch (position) {
                case 'top':
                    left = Math.max(20, Math.min(rect.left + rect.width/2 - popupWidth/2, viewportWidth - popupWidth - 20));
                    top = Math.max(20, rect.top - 200);
                    break;
                case 'bottom':
                    left = Math.max(20, Math.min(rect.left + rect.width/2 - popupWidth/2, viewportWidth - popupWidth - 20));
                    top = Math.min(rect.bottom + 20, viewportHeight - 250);
                    break;
                case 'left':
                    left = Math.max(20, rect.left - popupWidth - 20);
                    top = Math.max(20, Math.min(rect.top + rect.height/2 - 100, viewportHeight - 200));
                    break;
                case 'right':
                    left = Math.min(rect.right + 20, viewportWidth - popupWidth - 20);
                    top = Math.max(20, Math.min(rect.top + rect.height/2 - 100, viewportHeight - 200));
                    break;
                default:
                    // Smart positioning - find the best spot
                    if (rect.bottom + 220 < viewportHeight) {
                        // Bottom has space
                        position = 'bottom';
                        left = Math.max(20, Math.min(rect.left + rect.width/2 - popupWidth/2, viewportWidth - popupWidth - 20));
                        top = rect.bottom + 20;
                    } else if (rect.top > 220) {
                        // Top has space
                        position = 'top';
                        left = Math.max(20, Math.min(rect.left + rect.width/2 - popupWidth/2, viewportWidth - popupWidth - 20));
                        top = rect.top - 200;
                    } else if (rect.right + popupWidth + 40 < viewportWidth) {
                        // Right has space
                        position = 'right';
                        left = rect.right + 20;
                        top = Math.max(20, Math.min(rect.top + rect.height/2 - 100, viewportHeight - 200));
                    } else {
                        // Left has space or fallback
                        position = 'left';
                        left = Math.max(20, rect.left - popupWidth - 20);
                        top = Math.max(20, Math.min(rect.top + rect.height/2 - 100, viewportHeight - 200));
                    }
                    break;
            }

            popup.style.left = left + 'px';
            popup.style.top = top + 'px';

            // Add arrow pointing to target
            addTutorialArrow(popup, target, position, left, top);
        }

        function addTutorialArrow(popup, target, position, popupLeft, popupTop) {
            // Remove any existing arrow
            const existingArrow = popup.querySelector('.tutorial-arrow');
            if (existingArrow) existingArrow.remove();

            const arrow = document.createElement('div');
            arrow.className = `tutorial-arrow ${position}`;

            const targetRect = target.getBoundingClientRect();
            const popupRect = popup.getBoundingClientRect();

            switch (position) {
                case 'top':
                    arrow.style.left = Math.max(10, Math.min(targetRect.left + targetRect.width/2 - popupLeft - 10, popup.offsetWidth - 20)) + 'px';
                    arrow.style.bottom = '-10px';
                    break;
                case 'bottom':
                    arrow.style.left = Math.max(10, Math.min(targetRect.left + targetRect.width/2 - popupLeft - 10, popup.offsetWidth - 20)) + 'px';
                    arrow.style.top = '-10px';
                    break;
                case 'left':
                    arrow.style.right = '-10px';
                    arrow.style.top = Math.max(10, Math.min(targetRect.top + targetRect.height/2 - popupTop - 10, 180)) + 'px';
                    break;
                case 'right':
                    arrow.style.left = '-10px';
                    arrow.style.top = Math.max(10, Math.min(targetRect.top + targetRect.height/2 - popupTop - 10, 180)) + 'px';
                    break;
            }

            popup.appendChild(arrow);
        }

        function nextTutorialStep() {
            const nextStep = tutorialData.currentStep + 1;
            tutorialData.stepsCompleted.push(tutorialData.currentStep);

            if (nextStep >= TUTORIAL_STEPS.length) {
                completeTutorial();
            } else {
                showTutorialStep(nextStep);
            }
        }

        function previousTutorialStep() {
            if (tutorialData.currentStep > 0) {
                showTutorialStep(tutorialData.currentStep - 1);
            }
        }

        function skipTutorialStep() {
            nextTutorialStep();
        }

        function completeTutorial() {
            tutorialData.completed = true;
            tutorialData.lastTutorialDate = new Date().toISOString();
            saveTutorialData();

            removeTutorialElements();

            // Show completion message
            showTutorialCompletionModal();
        }

        function showTutorialCompletionModal() {
            const overlay = document.createElement('div');
            overlay.className = 'tutorial-overlay show';

            const popup = document.createElement('div');
            popup.className = 'tutorial-popup';
            popup.innerHTML = `
                <div class="tutorial-header">
                    <h3 class="text-xl font-bold text-green-600">🎉 Tutorial Complete!</h3>
                    <p class="text-sm text-gray-600 mt-1">You're ready to start playing Word Hunt!</p>
                </div>
                <div class="tutorial-content">
                    <p class="text-gray-700 mb-4">Great job! You've learned the basics of Word Hunt. Here's what you can do next:</p>
                    <ul class="text-sm text-gray-600 space-y-2">
                        <li>• Start with a 4×4 board to practice</li>
                        <li>• Try both timed and unlimited modes</li>
                        <li>• Check out the strategy guides for advanced tips</li>
                        <li>• Unlock achievements as you play</li>
                    </ul>
                </div>
                <div class="tutorial-footer">
                    <button class="tutorial-btn secondary" onclick="openTutorialMenu()">View Guides</button>
                    <button class="tutorial-btn" onclick="closeTutorialModal()">Start Playing!</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);
        }

        function removeTutorialElements() {
            const overlay = document.getElementById('tutorial-overlay');
            const highlight = document.getElementById('tutorial-highlight');

            if (overlay) overlay.remove();
            if (highlight) highlight.remove();

            // Remove tutorial path highlights
            document.querySelectorAll('.tutorial-path-highlight').forEach(el => el.remove());

            // Remove any tutorial listeners
            if (window.tutorialWordListener) {
                window.tutorialWordListener = null;
            }
            if (window.tutorialGuidedPractice) {
                window.tutorialGuidedPractice = null;
            }
            if (window.tutorialFreePractice) {
                window.tutorialFreePractice = null;
            }
        }

        function closeTutorialModal() {
            removeTutorialElements();
            // Return to opening UI after tutorial
            showOpeningUI();
        }

        // New tutorial step functions for practice board
        function createDemoTutorial(step, popup, overlay) {
            // Demo tutorials allow board interaction

            const target = step.target ? document.querySelector(step.target) : null;

            if (target) {
                const highlight = document.createElement('div');
                highlight.className = 'tutorial-highlight';
                highlight.id = 'tutorial-highlight';

                const rect = target.getBoundingClientRect();
                highlight.style.left = (rect.left - 5) + 'px';
                highlight.style.top = (rect.top - 5) + 'px';
                highlight.style.width = (rect.width + 10) + 'px';
                highlight.style.height = (rect.height + 10) + 'px';

                document.body.appendChild(highlight);
                positionTutorialPopup(popup, target, step.position);
            }

            popup.innerHTML = `
                <div class="tutorial-header">
                    <h3 class="text-base font-bold text-gray-800">${step.title}</h3>
                    <p class="text-xs text-gray-600 mt-1">${step.description}</p>
                </div>
                <div class="tutorial-content">
                    <p class="text-gray-700 text-sm mb-2">${step.content}</p>
                    <div class="bg-blue-50 rounded p-2">
                        <p class="text-xs text-blue-700">👀 I'll highlight "${step.demoWord}" for you!</p>
                    </div>
                </div>
                <div class="tutorial-footer">
                    <button class="tutorial-btn secondary text-xs py-1 px-2" onclick="skipTutorialStep()">Skip</button>
                    <button class="tutorial-btn text-xs py-1 px-3" onclick="startTutorialDemo('${step.id}')">Show Me!</button>
                </div>
            `;
        }

        function createGuidedPracticeTutorial(step, popup, overlay) {
            // Guided practice allows board interaction

            const target = step.target ? document.querySelector(step.target) : null;

            if (target) {
                const highlight = document.createElement('div');
                highlight.className = 'tutorial-highlight';
                highlight.id = 'tutorial-highlight';

                const rect = target.getBoundingClientRect();
                highlight.style.left = (rect.left - 5) + 'px';
                highlight.style.top = (rect.top - 5) + 'px';
                highlight.style.width = (rect.width + 10) + 'px';
                highlight.style.height = (rect.height + 10) + 'px';

                document.body.appendChild(highlight);
                positionTutorialPopup(popup, target, step.position);
            }

            popup.innerHTML = `
                <div class="tutorial-header">
                    <h3 class="text-base font-bold text-gray-800">${step.title}</h3>
                    <p class="text-xs text-gray-600 mt-1">${step.description}</p>
                </div>
                <div class="tutorial-content">
                    <p class="text-gray-700 text-sm mb-2">${step.content}</p>
                    <div class="bg-green-50 rounded p-2">
                        <p class="text-xs text-green-700">🎯 Find "${step.targetWord}" by connecting letters!</p>
                    </div>
                </div>
                <div class="tutorial-footer">
                    <button class="tutorial-btn secondary text-xs py-1 px-2" onclick="showTutorialHint('${step.id}')">Hint?</button>
                    <div class="text-xs text-gray-500">Try it!</div>
                </div>
            `;

            // Set up guided practice listener
            window.tutorialGuidedPractice = {
                targetWord: step.targetWord,
                targetPath: step.targetPath,
                stepId: step.id
            };
        }

        function createFreePracticeTutorial(step, popup, overlay) {
            // Free practice allows board interaction

            const target = step.target ? document.querySelector(step.target) : null;

            if (target) {
                const highlight = document.createElement('div');
                highlight.className = 'tutorial-highlight';
                highlight.id = 'tutorial-highlight';

                const rect = target.getBoundingClientRect();
                highlight.style.left = (rect.left - 5) + 'px';
                highlight.style.top = (rect.top - 5) + 'px';
                highlight.style.width = (rect.width + 10) + 'px';
                highlight.style.height = (rect.height + 10) + 'px';

                document.body.appendChild(highlight);
                positionTutorialPopup(popup, target, step.position);
            }

            popup.innerHTML = `
                <div class="tutorial-header">
                    <h3 class="text-base font-bold text-gray-800">${step.title}</h3>
                    <p class="text-xs text-gray-600 mt-1">${step.description}</p>
                </div>
                <div class="tutorial-content">
                    <p class="text-gray-700 text-sm mb-2">${step.content}</p>
                    <div class="bg-yellow-50 rounded p-2 mb-2">
                        <p class="text-xs text-yellow-700">📝 Progress: <span id="tutorial-words-found">0</span> / ${step.wordsNeeded} words</p>
                    </div>
                    <div class="text-xs text-gray-500">
                        💡 Try: DOG, MAN, ORE, CODE, MANY
                    </div>
                </div>
                <div class="tutorial-footer">
                    <button class="tutorial-btn secondary text-xs py-1 px-2" onclick="skipTutorialStep()">Skip</button>
                    <div class="text-xs text-gray-500">Keep going!</div>
                </div>
            `;

            // Set up free practice tracking
            window.tutorialFreePractice = {
                wordsNeeded: step.wordsNeeded,
                wordsFound: 0,
                startingWords: foundWords.size
            };
        }

        function createCompletionTutorial(step, popup, overlay) {
            // Completion tutorial should block interaction
            overlay.classList.add('interactive');

            popup.innerHTML = `
                <div class="tutorial-header">
                    <h3 class="text-xl font-bold text-green-600">🎉 ${step.title}</h3>
                    <p class="text-sm text-gray-600 mt-1">${step.description}</p>
                </div>
                <div class="tutorial-content">
                    <p class="text-gray-700 mb-4">${step.content}</p>
                    <div class="bg-gradient-to-r from-green-50 to-blue-50 rounded-lg p-4 mb-4">
                        <h4 class="font-medium text-gray-800 mb-2">🎯 What's Next?</h4>
                        <ul class="text-sm text-gray-600 space-y-1">
                            <li>• Choose your preferred game mode</li>
                            <li>• Try both 4×4 and 5×5 board sizes</li>
                            <li>• Unlock achievements as you play</li>
                            <li>• Check out strategy guides for advanced tips</li>
                        </ul>
                    </div>
                </div>
                <div class="tutorial-footer">
                    <button class="tutorial-btn secondary" onclick="openTutorialMenu(); completeTutorial();">View Guides</button>
                    <button class="tutorial-btn" onclick="completeTutorialAndStartGame()">Start Playing!</button>
                </div>
            `;
        }

        // Tutorial interaction functions
        function startTutorialDemo(stepId) {
            const step = TUTORIAL_STEPS.find(s => s.id === stepId);
            if (!step || !step.demoPath) return;

            // Highlight the demo word path
            highlightTutorialPath(step.demoPath, 'demo');

            // Auto-advance after demo
            setTimeout(() => {
                nextTutorialStep();
            }, 3000);
        }

        function highlightTutorialPath(path, type = 'demo') {
            // Remove any existing path highlights
            document.querySelectorAll('.tutorial-path-highlight').forEach(el => el.remove());

            path.forEach((pos, index) => {
                const tile = document.querySelector(`[data-row='${pos.row}'][data-col='${pos.col}']`);
                if (tile) {
                    const highlight = document.createElement('div');
                    highlight.className = 'tutorial-path-highlight';
                    highlight.style.position = 'absolute';
                    highlight.style.background = type === 'demo' ? 'rgba(59, 130, 246, 0.3)' : 'rgba(34, 197, 94, 0.3)';
                    highlight.style.border = type === 'demo' ? '2px solid #3b82f6' : '2px solid #22c55e';
                    highlight.style.borderRadius = '0.375rem';
                    highlight.style.pointerEvents = 'none';
                    highlight.style.zIndex = '998';

                    const rect = tile.getBoundingClientRect();
                    highlight.style.left = rect.left + 'px';
                    highlight.style.top = rect.top + 'px';
                    highlight.style.width = rect.width + 'px';
                    highlight.style.height = rect.height + 'px';

                    // Add number indicator
                    const number = document.createElement('div');
                    number.textContent = index + 1;
                    number.style.position = 'absolute';
                    number.style.top = '-8px';
                    number.style.right = '-8px';
                    number.style.background = type === 'demo' ? '#3b82f6' : '#22c55e';
                    number.style.color = 'white';
                    number.style.borderRadius = '50%';
                    number.style.width = '20px';
                    number.style.height = '20px';
                    number.style.display = 'flex';
                    number.style.alignItems = 'center';
                    number.style.justifyContent = 'center';
                    number.style.fontSize = '12px';
                    number.style.fontWeight = 'bold';

                    highlight.appendChild(number);
                    document.body.appendChild(highlight);

                    // Animate in sequence
                    setTimeout(() => {
                        highlight.style.opacity = '1';
                        highlight.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            highlight.style.transform = 'scale(1)';
                        }, 200);
                    }, index * 500);
                }
            });
        }

        function showTutorialHint(stepId) {
            const step = TUTORIAL_STEPS.find(s => s.id === stepId);
            if (!step || !step.targetPath) return;

            // Show hint by briefly highlighting the target path
            highlightTutorialPath(step.targetPath, 'hint');

            // Remove hint after 2 seconds
            setTimeout(() => {
                document.querySelectorAll('.tutorial-path-highlight').forEach(el => el.remove());
            }, 2000);
        }

        function completeTutorialAndStartGame() {
            completeTutorial();
            // Return to opening UI so user can choose game mode
            showOpeningUI();
        }

        // Update word checking to handle tutorial progression
        function checkTutorialProgress(word) {
            // Handle guided practice
            if (window.tutorialGuidedPractice) {
                const practice = window.tutorialGuidedPractice;
                if (word.toUpperCase() === practice.targetWord.toUpperCase()) {
                    // Success! Clean up and advance
                    document.querySelectorAll('.tutorial-path-highlight').forEach(el => el.remove());
                    window.tutorialGuidedPractice = null;

                    setTimeout(() => {
                        nextTutorialStep();
                    }, 1500); // Give time to see the word was found
                    return true;
                }
            }

            // Handle free practice
            if (window.tutorialFreePractice) {
                const practice = window.tutorialFreePractice;
                const newWordsFound = foundWords.size - practice.startingWords;
                practice.wordsFound = newWordsFound;

                // Update progress display
                const progressEl = document.getElementById('tutorial-words-found');
                if (progressEl) {
                    progressEl.textContent = newWordsFound;
                }

                // Check if enough words found
                if (newWordsFound >= practice.wordsNeeded) {
                    window.tutorialFreePractice = null;
                    setTimeout(() => {
                        nextTutorialStep();
                    }, 1500);
                    return true;
                }
            }

            return false;
        }

        // Tutorial Menu and Strategy Guides
        function openTutorialMenu() {
            console.log("Tutorial menu opened");

            // Create the mobile-responsive tutorial menu
            const { menuPanel, menuContent } = createMobileMenu('tutorial-menu-panel', '🎓 Tutorial & Guides', 'right');

            // Get the menu body to add content
            const menuBody = menuContent.querySelector('.mobile-menu-body');
            const menuFooter = menuContent.querySelector('.mobile-menu-footer div');

            // Create the tutorial menu content
            menuBody.innerHTML = `
                <div class="space-y-4">
                    <!-- Tutorial Status -->
                    <div class="bg-gradient-to-r from-blue-50 to-indigo-50 rounded-lg p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-2 flex items-center">
                            <span class="mr-2">🎯</span> Tutorial Status
                        </h4>
                        <div class="flex items-center justify-between">
                            <span class="text-sm text-gray-600">
                                ${tutorialData.completed ? '✅ Completed' : '📚 Available'}
                            </span>
                            <button class="tutorial-btn text-sm py-1 px-3" onclick="startTutorial(); closeMobileMenu(document.getElementById('tutorial-menu-panel'));">
                                ${tutorialData.completed ? 'Replay Tutorial' : 'Start Tutorial'}
                            </button>
                        </div>
                    </div>

                    <!-- Quick Tips -->
                    <div class="bg-white rounded-lg border border-gray-200 p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                            <span class="mr-2">💡</span> Quick Tips
                        </h4>
                        <div class="space-y-2 text-sm text-gray-600">
                            <div class="flex items-start space-x-2">
                                <span class="text-blue-500">•</span>
                                <span>Words must be at least 3 letters long</span>
                            </div>
                            <div class="flex items-start space-x-2">
                                <span class="text-blue-500">•</span>
                                <span>Connect adjacent letters (including diagonally)</span>
                            </div>
                            <div class="flex items-start space-x-2">
                                <span class="text-blue-500">•</span>
                                <span>Longer words give exponentially more points</span>
                            </div>
                            <div class="flex items-start space-x-2">
                                <span class="text-blue-500">•</span>
                                <span>Each letter can only be used once per word</span>
                            </div>
                        </div>
                    </div>

                    <!-- Strategy Guides -->
                    <div class="bg-white rounded-lg border border-gray-200 p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                            <span class="mr-2">📚</span> Strategy Guides
                        </h4>
                        <div class="space-y-2">
                            ${STRATEGY_GUIDES.map(guide => `
                                <button class="mobile-touch-btn w-full text-left bg-gray-50 hover:bg-gray-100 border border-gray-200" onclick="openStrategyGuide('${guide.id}')">
                                    <div class="flex items-center justify-between">
                                        <div class="flex items-center space-x-3">
                                            <span class="text-lg">${guide.icon}</span>
                                            <div>
                                                <div class="font-medium text-sm">${guide.title}</div>
                                                <div class="text-xs text-gray-500">${guide.description}</div>
                                            </div>
                                        </div>
                                        <span class="strategy-category ${guide.category.toLowerCase()}">${guide.category}</span>
                                    </div>
                                </button>
                            `).join('')}
                        </div>
                    </div>

                    <!-- Tooltips Info -->
                    <div class="bg-white rounded-lg border border-gray-200 p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                            <span class="mr-2">ℹ️</span> Interactive Help
                        </h4>
                        <p class="text-sm text-gray-600 mb-3">
                            Hover over buttons and features throughout the game to see helpful tooltips and explanations.
                        </p>
                        <div class="text-xs text-gray-500">
                            💡 Tooltips are automatically enabled and will appear when you hover over interactive elements.
                        </div>
                    </div>

                    <!-- Scoring Reference -->
                    <div class="bg-white rounded-lg border border-gray-200 p-4">
                        <h4 class="text-sm font-bold text-gray-700 mb-3 flex items-center">
                            <span class="mr-2">🎯</span> Scoring Reference
                        </h4>
                        <div class="grid grid-cols-2 gap-3 text-sm">
                            <div class="text-center p-2 bg-gray-50 rounded">
                                <div class="font-bold text-blue-600">100</div>
                                <div class="text-xs text-gray-600">3 letters</div>
                            </div>
                            <div class="text-center p-2 bg-gray-50 rounded">
                                <div class="font-bold text-green-600">400</div>
                                <div class="text-xs text-gray-600">4 letters</div>
                            </div>
                            <div class="text-center p-2 bg-gray-50 rounded">
                                <div class="font-bold text-orange-600">800</div>
                                <div class="text-xs text-gray-600">5 letters</div>
                            </div>
                            <div class="text-center p-2 bg-gray-50 rounded">
                                <div class="font-bold text-purple-600">1400+</div>
                                <div class="text-xs text-gray-600">6+ letters</div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Set footer content
            menuFooter.textContent = 'Learn, practice, and improve your Word Hunt skills!';

            // Show the menu using the mobile-responsive system
            showMobileMenu(menuPanel);
        }

        function openStrategyGuide(guideId) {
            const guide = STRATEGY_GUIDES.find(g => g.id === guideId);
            if (!guide) return;

            // Track that this strategy was viewed
            if (!tutorialData.strategiesViewed.includes(guideId)) {
                tutorialData.strategiesViewed.push(guideId);
                saveTutorialData();
            }

            // Create strategy guide modal
            const overlay = document.createElement('div');
            overlay.className = 'tutorial-overlay show';
            overlay.id = 'strategy-guide-overlay';

            const popup = document.createElement('div');
            popup.className = 'tutorial-popup';
            popup.style.maxWidth = '500px';
            popup.style.maxHeight = '80vh';

            popup.innerHTML = `
                <div class="tutorial-header">
                    <div class="flex items-center justify-between">
                        <div>
                            <h3 class="text-xl font-bold text-gray-800 flex items-center">
                                <span class="mr-2">${guide.icon}</span> ${guide.title}
                            </h3>
                            <span class="strategy-category ${guide.category.toLowerCase()}">${guide.category}</span>
                        </div>
                        <button onclick="closeStrategyGuide()" class="text-gray-500 hover:text-gray-700 p-1">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                <line x1="6" y1="6" x2="18" y2="18"></line>
                            </svg>
                        </button>
                    </div>
                    <p class="text-sm text-gray-600 mt-2">${guide.description}</p>
                </div>
                <div class="tutorial-content" style="max-height: 400px; overflow-y: auto;">
                    ${guide.content.map(section => `
                        <div class="mb-6">
                            <h4 class="font-bold text-gray-800 mb-3 flex items-center">
                                <span class="w-2 h-2 bg-blue-500 rounded-full mr-2"></span>
                                ${section.section}
                            </h4>
                            <ul class="space-y-2">
                                ${section.tips.map(tip => `
                                    <li class="flex items-start space-x-2 text-sm text-gray-700">
                                        <span class="text-blue-500 mt-1">•</span>
                                        <span>${tip}</span>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    `).join('')}
                </div>
                <div class="tutorial-footer">
                    <button class="tutorial-btn secondary" onclick="openTutorialMenu(); closeStrategyGuide();">← Back to Guides</button>
                    <button class="tutorial-btn" onclick="closeStrategyGuide()">Got it!</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);
        }

        function closeStrategyGuide() {
            const overlay = document.getElementById('strategy-guide-overlay');
            if (overlay) {
                overlay.remove();
            }
        }

        // Tooltip System
        function initializeTooltips() {
            // Add tooltips to various elements
            addTooltip('#opening-achievements-btn', TOOLTIPS.achievements);
            addTooltip('#opening-analytics-btn', TOOLTIPS.analytics);
            addTooltip('#opening-tutorial-btn', {
                title: 'Tutorial & Guides',
                content: 'Learn how to play, view strategy guides, and get tips to improve your gameplay.',
                trigger: 'hover',
                position: 'top'
            });
            addTooltip('#daily-challenge-btn', TOOLTIPS.daily_challenge);
            addTooltip('.board-size-btn', TOOLTIPS.board_size);
        }

        function addTooltip(selector, tooltipConfig) {
            const elements = document.querySelectorAll(selector);

            elements.forEach(element => {
                let tooltip = null;
                let showTimeout = null;
                let hideTimeout = null;

                function showTooltip(e) {
                    clearTimeout(hideTimeout);

                    showTimeout = setTimeout(() => {
                        // Remove any existing tooltip
                        if (tooltip) {
                            tooltip.remove();
                        }

                        // Create new tooltip
                        tooltip = document.createElement('div');
                        tooltip.className = `tooltip ${tooltipConfig.position}`;
                        tooltip.innerHTML = `
                            <div class="font-medium text-xs">${tooltipConfig.title}</div>
                            <div class="text-xs mt-1 opacity-90">${tooltipConfig.content}</div>
                        `;

                        document.body.appendChild(tooltip);

                        // Position tooltip
                        positionTooltip(tooltip, element, tooltipConfig.position);

                        // Show tooltip
                        setTimeout(() => {
                            tooltip.classList.add('show');
                        }, 10);

                        // Track tooltip shown
                        if (!tutorialData.tooltipsShown.includes(selector)) {
                            tutorialData.tooltipsShown.push(selector);
                            saveTutorialData();
                        }
                    }, 500); // Delay before showing
                }

                function hideTooltip() {
                    clearTimeout(showTimeout);

                    hideTimeout = setTimeout(() => {
                        if (tooltip) {
                            tooltip.classList.remove('show');
                            setTimeout(() => {
                                if (tooltip) {
                                    tooltip.remove();
                                    tooltip = null;
                                }
                            }, 200);
                        }
                    }, 100); // Small delay before hiding
                }

                if (tooltipConfig.trigger === 'hover') {
                    element.addEventListener('mouseenter', showTooltip);
                    element.addEventListener('mouseleave', hideTooltip);

                    // Touch support for mobile
                    element.addEventListener('touchstart', showTooltip);
                    element.addEventListener('touchend', hideTooltip);
                }
            });
        }

        function positionTooltip(tooltip, target, position) {
            const rect = target.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();

            switch (position) {
                case 'top':
                    tooltip.style.left = (rect.left + rect.width/2 - tooltipRect.width/2) + 'px';
                    tooltip.style.top = (rect.top - tooltipRect.height - 10) + 'px';
                    break;
                case 'bottom':
                    tooltip.style.left = (rect.left + rect.width/2 - tooltipRect.width/2) + 'px';
                    tooltip.style.top = (rect.bottom + 10) + 'px';
                    break;
                case 'left':
                    tooltip.style.left = (rect.left - tooltipRect.width - 10) + 'px';
                    tooltip.style.top = (rect.top + rect.height/2 - tooltipRect.height/2) + 'px';
                    break;
                case 'right':
                    tooltip.style.left = (rect.right + 10) + 'px';
                    tooltip.style.top = (rect.top + rect.height/2 - tooltipRect.height/2) + 'px';
                    break;
            }

            // Ensure tooltip stays within viewport
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            if (tooltip.offsetLeft < 10) {
                tooltip.style.left = '10px';
            }
            if (tooltip.offsetLeft + tooltip.offsetWidth > viewportWidth - 10) {
                tooltip.style.left = (viewportWidth - tooltip.offsetWidth - 10) + 'px';
            }
            if (tooltip.offsetTop < 10) {
                tooltip.style.top = '10px';
            }
            if (tooltip.offsetTop + tooltip.offsetHeight > viewportHeight - 10) {
                tooltip.style.top = (viewportHeight - tooltip.offsetHeight - 10) + 'px';
            }
        }

        // First-time user experience
        function showFirstTimeUserPrompt() {
            const overlay = document.createElement('div');
            overlay.className = 'tutorial-overlay show';
            overlay.id = 'first-time-prompt';

            const popup = document.createElement('div');
            popup.className = 'tutorial-popup';
            popup.innerHTML = `
                <div class="tutorial-header">
                    <h3 class="text-xl font-bold text-blue-600">👋 Welcome to Word Hunt!</h3>
                    <p class="text-sm text-gray-600 mt-1">It looks like this is your first time playing.</p>
                </div>
                <div class="tutorial-content">
                    <p class="text-gray-700 mb-4">Would you like to take a quick tutorial to learn how to play? It only takes a few minutes and will help you get started.</p>

                    <div class="bg-blue-50 rounded-lg p-3 mb-4">
                        <h4 class="font-medium text-blue-800 mb-2">What you'll learn:</h4>
                        <ul class="text-sm text-blue-700 space-y-1">
                            <li>• How to form words by connecting letters</li>
                            <li>• Understanding the scoring system</li>
                            <li>• Game modes and features</li>
                            <li>• Tips for finding more words</li>
                        </ul>
                    </div>

                    <p class="text-xs text-gray-500">You can always access the tutorial and strategy guides later from the main menu.</p>
                </div>
                <div class="tutorial-footer">
                    <button class="tutorial-btn secondary" onclick="skipFirstTimeTutorial()">Skip for now</button>
                    <button class="tutorial-btn" onclick="startFirstTimeTutorial()">Start Tutorial</button>
                </div>
            `;

            overlay.appendChild(popup);
            document.body.appendChild(overlay);
        }

        function startFirstTimeTutorial() {
            const prompt = document.getElementById('first-time-prompt');
            if (prompt) prompt.remove();

            startTutorial();
        }

        function skipFirstTimeTutorial() {
            const prompt = document.getElementById('first-time-prompt');
            if (prompt) prompt.remove();

            tutorialData.firstTimeUser = false;
            saveTutorialData();
        }

        // Enhanced strategy guides with more content
        function addAdvancedStrategyGuides() {
            STRATEGY_GUIDES.push(
                {
                    id: 'pattern_recognition',
                    title: 'Pattern Recognition',
                    category: 'Advanced',
                    icon: '🧠',
                    description: 'Develop your ability to quickly spot word patterns.',
                    content: [
                        {
                            section: 'Common Letter Combinations',
                            tips: [
                                'Look for "ING" endings - very common in English',
                                'Search for "TH" combinations - often start words',
                                'Find "ER" patterns - common word endings',
                                'Spot "ST" combinations - frequent in many words'
                            ]
                        },
                        {
                            section: 'Visual Scanning Techniques',
                            tips: [
                                'Use peripheral vision to scan multiple areas',
                                'Start from corners - they have fewer connection options',
                                'Look for isolated letters that might anchor longer words',
                                'Practice the "spiral scan" - work from outside to center'
                            ]
                        }
                    ]
                },
                {
                    id: 'competitive_play',
                    title: 'Competitive Strategies',
                    category: 'Expert',
                    icon: '🏆',
                    description: 'Advanced techniques for high-level play.',
                    content: [
                        {
                            section: 'Speed Optimization',
                            tips: [
                                'Memorize common 3-letter words for quick points',
                                'Practice smooth mouse/finger movements',
                                'Learn to abandon difficult words quickly',
                                'Develop muscle memory for frequent patterns'
                            ]
                        },
                        {
                            section: 'Score Maximization',
                            tips: [
                                'Always prioritize 4+ letter words when possible',
                                'Look for word extensions (CAT → CATS → CATCH)',
                                'Use rare letters (Q, X, Z) strategically',
                                'Save easy words for time pressure situations'
                            ]
                        }
                    ]
                }
            );
        }

        // Call this to add the advanced guides
        addAdvancedStrategyGuides();

        // Tutorial Progress Tracking and Contextual Hints
        function showContextualHint(context) {
            // Only show hints if tutorial is completed or user has played a few games
            if (!tutorialData.completed && gamesPlayed < 3) return;

            const hints = {
                'low_score': {
                    title: '💡 Scoring Tip',
                    message: 'Try focusing on 4-letter words - they give 4x more points than 3-letter words!',
                    action: 'View Strategy Guide',
                    actionCallback: () => openStrategyGuide('scoring_optimization')
                },
                'time_pressure': {
                    title: '⏰ Time Management',
                    message: 'Running out of time? Focus on quick 3-letter words in the final seconds.',
                    action: 'Learn More',
                    actionCallback: () => openStrategyGuide('time_management')
                },
                'few_words': {
                    title: '🔍 Word Finding',
                    message: 'Having trouble finding words? Try starting from vowels and common letter combinations.',
                    action: 'See Patterns',
                    actionCallback: () => openStrategyGuide('pattern_recognition')
                },
                'first_achievement': {
                    title: '🏆 Great Job!',
                    message: 'You unlocked your first achievement! Check out the achievements menu to see what else you can unlock.',
                    action: 'View Achievements',
                    actionCallback: () => openAchievementsMenu()
                }
            };

            const hint = hints[context];
            if (!hint) return;

            // Don't show the same hint too frequently
            const lastHintKey = `lastHint_${context}`;
            const lastShown = localStorage.getItem(lastHintKey);
            if (lastShown && Date.now() - parseInt(lastShown) < 300000) return; // 5 minutes

            showHintNotification(hint);
            localStorage.setItem(lastHintKey, Date.now().toString());
        }

        function showHintNotification(hint) {
            // Remove any existing hint notification
            const existing = document.getElementById('hint-notification');
            if (existing) existing.remove();

            const notification = document.createElement('div');
            notification.id = 'hint-notification';
            notification.className = 'fixed top-4 right-4 bg-white border border-blue-200 rounded-lg shadow-lg p-4 z-50 max-w-sm transform translate-x-full transition-transform duration-300';

            notification.innerHTML = `
                <div class="flex items-start space-x-3">
                    <div class="flex-1">
                        <h4 class="font-medium text-gray-800 text-sm">${hint.title}</h4>
                        <p class="text-xs text-gray-600 mt-1">${hint.message}</p>
                        <div class="flex items-center space-x-2 mt-3">
                            <button onclick="hint.actionCallback(); closeHintNotification();" class="text-xs bg-blue-500 text-white px-3 py-1 rounded hover:bg-blue-600 transition-colors">
                                ${hint.action}
                            </button>
                            <button onclick="closeHintNotification()" class="text-xs text-gray-500 hover:text-gray-700">
                                Dismiss
                            </button>
                        </div>
                    </div>
                    <button onclick="closeHintNotification()" class="text-gray-400 hover:text-gray-600">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
            `;

            document.body.appendChild(notification);

            // Store the callback for the action button
            notification.querySelector('button').onclick = () => {
                hint.actionCallback();
                closeHintNotification();
            };

            // Animate in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 100);

            // Auto-hide after 10 seconds
            setTimeout(() => {
                closeHintNotification();
            }, 10000);
        }

        function closeHintNotification() {
            const notification = document.getElementById('hint-notification');
            if (notification) {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.remove();
                    }
                }, 300);
            }
        }

        // Tutorial completion tracking
        function trackTutorialProgress() {
            const progress = {
                tutorialCompleted: tutorialData.completed,
                stepsCompleted: tutorialData.stepsCompleted.length,
                totalSteps: TUTORIAL_STEPS.length,
                strategiesViewed: tutorialData.strategiesViewed.length,
                tooltipsShown: tutorialData.tooltipsShown.length
            };

            return progress;
        }

        // Add tutorial progress to analytics
        function getTutorialAnalytics() {
            const progress = trackTutorialProgress();

            return {
                tutorialEngagement: {
                    completed: progress.tutorialCompleted,
                    completionRate: (progress.stepsCompleted / progress.totalSteps) * 100,
                    strategiesViewed: progress.strategiesViewed,
                    tooltipsInteracted: progress.tooltipsShown,
                    helpSeeking: progress.strategiesViewed > 0 || progress.tooltipsShown > 3
                }
            };
        }

        function checkAchievements(specificTypes = null) {
            // Debounce achievement checking to prevent excessive calls
            if (window.achievementCheckTimeout) {
                clearTimeout(window.achievementCheckTimeout);
            }

            window.achievementCheckTimeout = setTimeout(() => {
                const newUnlocks = [];

                Object.keys(achievements).forEach(key => {
                    const achievement = achievements[key];
                    if (!achievement.unlocked) {
                        // Skip checking if specific types are provided and this isn't one of them
                        if (specificTypes && !specificTypes.includes(achievement.type)) {
                            return;
                        }

                        let shouldUnlock = false;

                        switch (achievement.type) {
                            case 'games':
                                shouldUnlock = gamesPlayed >= achievement.requirement;
                                break;
                            case 'score':
                                shouldUnlock = score >= achievement.requirement;
                                break;
                            case 'words_single':
                                shouldUnlock = foundWords.size >= achievement.requirement;
                                break;
                            case 'words_total':
                                shouldUnlock = totalWordsFound >= achievement.requirement;
                                break;
                            case 'perfect':
                                // Only check perfect game at game end to avoid performance issues
                                if (specificTypes && specificTypes.includes('perfect')) {
                                    const allWords = findAllPossibleWords();
                                    shouldUnlock = foundWords.size === allWords.length && allWords.length > 0;
                                }
                                break;
                            case 'speed':
                                shouldUnlock = wordsFoundInTime >= achievement.requirement;
                                break;
                            case 'word_length':
                                shouldUnlock = Array.from(foundWords).some(word => word.length >= achievement.requirement);
                                break;
                            case 'customize':
                                shouldUnlock = customizeEffectsUsed.size >= achievement.requirement;
                                break;
                            case 'backgrounds':
                                shouldUnlock = backgroundsUsed.size >= achievement.requirement;
                                break;
                            case 'total_score':
                                shouldUnlock = totalScore >= achievement.requirement;
                                break;
                            case 'daily_streak':
                                shouldUnlock = consecutiveDays >= achievement.requirement;
                                break;
                            case 'combo':
                                shouldUnlock = currentStreak >= achievement.requirement;
                                break;
                            case 'exact_score':
                                shouldUnlock = score === achievement.requirement;
                                break;
                            case 'speed_burst':
                                // Check if 3 words found in under 10 seconds
                                shouldUnlock = wordsFoundInTime >= achievement.requirement && (Date.now() - gameStartTime) < 10000;
                                break;
                            case 'efficiency':
                                // Score 2000+ with under 15 words
                                shouldUnlock = score >= 2000 && foundWords.size < 15;
                                break;
                            case 'word_variety':
                                // Find words of every length 3-10+
                                const lengths = Array.from(foundWords).map(w => w.length);
                                const uniqueLengths = new Set(lengths);
                                shouldUnlock = uniqueLengths.size >= achievement.requirement;
                                break;
                            case 'perfect_accuracy':
                                shouldUnlock = invalidWordCount === 0 && foundWords.size > 0;
                                break;
                            case 'quick_start':
                                shouldUnlock = firstWordTime > 0 && firstWordTime < 5000;
                                break;
                            case 'endurance':
                                shouldUnlock = currentGameMode === GAME_MODE.TIMED && timer <= 0;
                                break;
                            case 'time':
                                const currentHour = new Date().getHours();
                                if (key === 'night_owl') {
                                    shouldUnlock = currentHour >= 0 && currentHour < 6;
                                } else if (key === 'early_bird') {
                                    shouldUnlock = currentHour >= 0 && currentHour < 6;
                                }
                                break;
                            case 'palindrome':
                                shouldUnlock = Array.from(foundWords).some(word =>
                                    word.toLowerCase() === word.toLowerCase().split('').reverse().join('')
                                );
                                break;
                            case 'vowel_word':
                                shouldUnlock = Array.from(foundWords).some(word => {
                                    const vowels = ['a', 'e', 'i', 'o', 'u'];
                                    return vowels.every(vowel => word.toLowerCase().includes(vowel));
                                });
                                break;
                            case 'no_vowel_word':
                                shouldUnlock = Array.from(foundWords).some(word => {
                                    const vowels = ['a', 'e', 'i', 'o', 'u'];
                                    return !vowels.some(vowel => word.toLowerCase().includes(vowel)) && word.length >= 3;
                                });
                                break;
                            case 'matrix_play':
                                shouldUnlock = matrixModeActive && foundWords.size > 0;
                                break;
                        }

                        if (shouldUnlock) {
                            achievement.unlocked = true;
                            newUnlocks.push(achievement);
                        }
                    }
                });

                if (newUnlocks.length > 0) {
                    showAchievementNotification(newUnlocks);
                    saveAchievements();

                    // Show contextual hint for first achievement
                    const unlockedCount = Object.values(achievements).filter(a => a.unlocked).length;
                    if (unlockedCount === 1) {
                        setTimeout(() => showContextualHint('first_achievement'), 3000);
                    }
                }
            }, 100); // Small delay to batch multiple checks
        }

        function showAchievementNotification(achievements) {
            // Use requestAnimationFrame for better performance
            achievements.forEach((achievement, index) => {
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        const notification = document.createElement('div');
                        notification.className = 'fixed top-4 left-1/2 bg-gradient-to-r from-yellow-400 to-orange-500 text-white px-4 py-3 rounded-lg shadow-lg z-50';
                        notification.style.transform = 'translate(-50%, -20px)';
                        notification.style.opacity = '0';
                        notification.style.transition = 'all 0.3s ease-out';

                        notification.innerHTML = `
                            <div class="flex items-center space-x-2">
                                <div class="text-xl">${achievement.icon}</div>
                                <div>
                                    <div class="font-bold text-sm">Achievement Unlocked!</div>
                                    <div class="text-xs">${achievement.name}</div>
                                </div>
                            </div>
                        `;

                        document.body.appendChild(notification);

                        // Animate in
                        requestAnimationFrame(() => {
                            notification.style.transform = 'translate(-50%, 0)';
                            notification.style.opacity = '1';
                        });

                        // Remove after 3 seconds
                        setTimeout(() => {
                            notification.style.transform = 'translate(-50%, -20px)';
                            notification.style.opacity = '0';
                            setTimeout(() => {
                                if (notification.parentNode) {
                                    notification.remove();
                                }
                            }, 300);
                        }, 3000);
                    });
                }, index * 500); // Reduced stagger time
            });
        }

        function getAchievementProgress(achievement) {
            let current = 0;
            let required = achievement.requirement;

            switch (achievement.type) {
                case 'games':
                    current = gamesPlayed;
                    break;
                case 'score':
                    current = bestScore;
                    break;
                case 'words_single':
                    current = foundWords ? foundWords.size : 0;
                    break;
                case 'words_total':
                    current = totalWordsFound;
                    break;
                case 'customize':
                    current = customizeEffectsUsed.size;
                    break;
                case 'backgrounds':
                    current = backgroundsUsed.size;
                    break;
                case 'total_score':
                    current = totalScore;
                    break;
                case 'daily_streak':
                    current = consecutiveDays;
                    break;
                case 'speed':
                    current = wordsFoundInTime;
                    break;
                case 'word_length':
                    current = foundWords ? Math.max(...Array.from(foundWords).map(w => w.length), 0) : 0;
                    break;
                case 'combo':
                    current = currentStreak;
                    break;
                case 'exact_score':
                    current = score === achievement.requirement ? 1 : 0;
                    required = 1;
                    break;
                case 'perfect':
                case 'secret':
                case 'time':
                case 'palindrome':
                case 'vowel_word':
                case 'no_vowel_word':
                case 'matrix_play':
                case 'weekend':
                case 'holiday':
                case 'exact_time':
                case 'duplicate_words':
                case 'alphabet_variety':
                case 'reverse_word':
                case 'theme_session':
                case 'alphabetical':
                case 'multi_effects':
                case 'minimalist':
                case 'maximalist':
                case 'full_grid':
                case 'corners':
                case 'center_tile':
                case 'edge_only':
                case 'zigzag':
                case 'mode_variety':
                case 'grid_variety':
                case 'easter_word':
                case 'speed_burst':
                case 'efficiency':
                case 'word_variety':
                case 'perfect_accuracy':
                case 'quick_start':
                case 'endurance':
                    current = achievement.unlocked ? 1 : 0;
                    required = 1;
                    break;
                default:
                    current = 0;
            }

            // Cap current at required to avoid >100%
            current = Math.min(current, required);
            const percent = Math.round((current / required) * 100);

            return { current, required, percent };
        }

        function openAchievementsMenu() {
            const unlockedCount = Object.values(achievements).filter(a => a.unlocked).length;
            const totalCount = Object.keys(achievements).length;
            const completionPercent = Math.round((unlockedCount / totalCount) * 100);

            // Create the mobile-responsive achievements menu
            const { menuPanel, menuContent } = createMobileMenu('achievements-menu-panel', '🏆 Achievements', 'right');

            // Get the menu body to add content
            const menuBody = menuContent.querySelector('.mobile-menu-body');
            const menuFooter = menuContent.querySelector('.mobile-menu-footer div');

            // Simple category grouping
            const categories = {
                'long-term': { name: 'Long-term', icon: '📈', achievements: [] },
                'skill': { name: 'Skill', icon: '🎯', achievements: [] },
                'hidden': { name: 'Hidden', icon: '🔍', achievements: [] }
            };

            Object.entries(achievements).forEach(([key, achievement]) => {
                const category = achievement.category || 'skill';
                if (categories[category]) {
                    categories[category].achievements.push({ key, ...achievement });
                }
            });

            let currentCategory = 'long-term';

            // Create mobile-friendly achievements content
            menuBody.innerHTML = `
                <div class="mb-4">
                    <div class="flex justify-between items-center mb-2">
                        <h4 class="text-sm font-bold text-gray-700">Progress Overview</h4>
                        <span class="text-xs text-gray-500">${unlockedCount}/${totalCount} (${completionPercent}%)</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded h-2">
                        <div class="bg-yellow-500 h-2 rounded transition-all duration-300" style="width: ${completionPercent}%"></div>
                    </div>
                </div>

                <div class="mb-4">
                    <h4 class="text-sm font-bold text-gray-700 mb-2">Categories</h4>
                    <div class="flex border border-gray-200 rounded-lg overflow-hidden">
                        ${Object.keys(categories).map(key => `
                            <button class="flex-1 py-2 px-2 text-xs font-medium category-tab ${key === currentCategory ? 'bg-blue-100 text-blue-700' : 'text-gray-500 hover:text-gray-700 hover:bg-gray-50'}" data-category="${key}">
                                <div class="text-center">
                                    <div>${categories[key].icon}</div>
                                    <div class="text-xs">${categories[key].name}</div>
                                </div>
                            </button>
                        `).join('')}
                    </div>
                </div>

                <div id="category-content">
                    <!-- Content will be populated by renderCategory -->
                </div>
            `;

            function renderCategory(categoryKey) {
                const category = categories[categoryKey];
                const categoryUnlocked = category.achievements.filter(a => a.unlocked).length;
                const categoryPercent = category.achievements.length > 0 ? Math.round((categoryUnlocked / category.achievements.length) * 100) : 0;

                return `
                    <div>
                        <div class="flex justify-between items-center mb-3">
                            <h4 class="font-bold text-sm">${category.icon} ${category.name}</h4>
                            <span class="text-xs text-gray-500">${categoryUnlocked}/${category.achievements.length}</span>
                        </div>
                        <div class="w-full bg-gray-200 rounded h-1 mb-3">
                            <div class="bg-blue-500 h-1 rounded transition-all duration-300" style="width: ${categoryPercent}%"></div>
                        </div>
                        <div class="space-y-2">
                            ${category.achievements.map(achievement => {
                                const progress = getAchievementProgress(achievement);
                                return `
                                    <div class="flex items-center space-x-3 p-3 rounded-lg border ${achievement.unlocked ? 'bg-green-50 border-green-200' : 'bg-gray-50 border-gray-200'}">
                                        <div class="text-lg ${achievement.unlocked ? '' : 'grayscale opacity-50'}">${achievement.icon}</div>
                                        <div class="flex-1 min-w-0">
                                            <div class="font-medium text-sm ${achievement.unlocked ? 'text-green-700' : 'text-gray-700'}">${achievement.name}</div>
                                            <div class="text-xs text-gray-500 mt-1">${achievement.description}</div>
                                            ${achievement.unlocked ?
                                                '<div class="text-xs text-green-600 font-medium mt-1">✓ Unlocked</div>' :
                                                `<div class="text-xs text-gray-400 mt-1">${progress.current}/${progress.required} (${progress.percent}%)</div>`
                                            }
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Set initial content
            menuContent.querySelector('#category-content').innerHTML = renderCategory(currentCategory);

            // Set footer content
            menuFooter.innerHTML = `Games: ${gamesPlayed} | Best: ${bestScore} | Words: ${totalWordsFound}`;

            // Show the menu using the mobile-responsive system
            showMobileMenu(menuPanel);

            // Add event listeners for category tabs
            menuPanel.querySelectorAll('.category-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const category = tab.dataset.category;
                    currentCategory = category;

                    // Update active tab
                    menuPanel.querySelectorAll('.category-tab').forEach(t => {
                        t.className = 'flex-1 py-2 px-2 text-xs font-medium category-tab text-gray-500 hover:text-gray-700 hover:bg-gray-50';
                    });
                    tab.className = 'flex-1 py-2 px-2 text-xs font-medium category-tab bg-blue-100 text-blue-700';

                    // Update content
                    menuPanel.querySelector('#category-content').innerHTML = renderCategory(category);
                });
            });
        }









        // Power-ups Functions
        function loadPowerupInventory() {
            try {
                const saved = localStorage.getItem(POWERUPS_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    powerupInventory = new Map(parsed);
                }
            } catch (error) {
                console.error('Error loading power-up inventory:', error);
            }
        }

        function savePowerupInventory() {
            try {
                localStorage.setItem(POWERUPS_KEY, JSON.stringify(Array.from(powerupInventory.entries())));
            } catch (error) {
                console.error('Error saving power-up inventory:', error);
            }
        }

        function spawnPowerup() {
            // Disable power-ups for Daily Challenge mode
            if (isDailyChallenge) {
                return; // No power-ups in competitive modes
            }

            // Check if we should spawn a power-up
            const totalChance = Object.values(POWERUP_SPAWN_RATES).reduce((sum, rate) => sum + rate, 0);
            const roll = Math.random() * 100;

            if (roll > totalChance) return; // No power-up spawned

            // Determine rarity
            let rarity = 'common';
            let cumulativeChance = 0;

            for (const [rarityLevel, chance] of Object.entries(POWERUP_SPAWN_RATES)) {
                cumulativeChance += chance;
                if (roll <= cumulativeChance) {
                    rarity = rarityLevel;
                    break;
                }
            }

            // Get power-ups of this rarity
            const powerupsOfRarity = Object.values(POWERUP_TYPES).filter(p => p.rarity === rarity);
            if (powerupsOfRarity.length === 0) return;

            // Select random power-up
            const selectedPowerup = powerupsOfRarity[Math.floor(Math.random() * powerupsOfRarity.length)];

            // Find empty position on grid
            const emptyPositions = [];
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const posKey = `${row}-${col}`;
                    if (!powerupSpawns.has(posKey)) {
                        emptyPositions.push({row, col, key: posKey});
                    }
                }
            }

            if (emptyPositions.length === 0) return; // No empty positions

            // Place power-up
            const position = emptyPositions[Math.floor(Math.random() * emptyPositions.length)];
            powerupSpawns.set(position.key, selectedPowerup);

            // Add visual indicator to grid tile
            addPowerupToGrid(position.row, position.col, selectedPowerup);

            console.log(`Spawned ${selectedPowerup.name} at ${position.row},${position.col}`);
        }

        function addPowerupToGrid(row, col, powerup) {
            const tile = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (!tile) return;

            // Create power-up indicator
            const powerupIndicator = document.createElement('div');
            powerupIndicator.className = 'absolute top-0 right-0 w-4 h-4 rounded-full flex items-center justify-center text-xs transform translate-x-1 -translate-y-1 animate-pulse';
            powerupIndicator.classList.add(powerup.color);
            powerupIndicator.textContent = powerup.icon;
            powerupIndicator.style.fontSize = '10px';
            powerupIndicator.setAttribute('data-powerup', powerup.id);

            // Make tile position relative if not already
            tile.style.position = 'relative';
            tile.appendChild(powerupIndicator);
        }

        function collectPowerup(row, col) {
            const posKey = `${row}-${col}`;
            const powerup = powerupSpawns.get(posKey);

            if (!powerup) return false;

            // Add to inventory
            const currentCount = powerupInventory.get(powerup.id) || 0;
            powerupInventory.set(powerup.id, currentCount + 1);
            savePowerupInventory();

            // Track power-up collection achievements
            const totalCollected = Array.from(powerupInventory.values()).reduce((sum, count) => sum + count, 0);

            // Check collection achievements
            if (!achievements.power_collector.unlocked && totalCollected >= 1) {
                achievements.power_collector.unlocked = true;
                showAchievementNotification([achievements.power_collector]);
            }

            if (!achievements.power_hoarder.unlocked && totalCollected >= 10) {
                achievements.power_hoarder.unlocked = true;
                showAchievementNotification([achievements.power_hoarder]);
            }

            // Check rarity achievements
            if (!achievements.lucky_finder.unlocked && powerup.rarity === 'epic') {
                achievements.lucky_finder.unlocked = true;
                showAchievementNotification([achievements.lucky_finder]);
            }

            saveAchievements();

            // Remove from spawns
            powerupSpawns.delete(posKey);

            // Remove visual indicator
            const tile = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            if (tile) {
                const indicator = tile.querySelector('[data-powerup]');
                if (indicator) {
                    indicator.remove();
                }
            }

            // Show collection modal
            showPowerupCollectionModal(powerup);

            // Update inventory display
            updatePowerupInventoryDisplay();

            return true;
        }

        function showPowerupCollectionModal(powerup) {
            const modal = document.getElementById('powerup-collection-modal');

            document.getElementById('collected-powerup-icon').textContent = powerup.icon;
            document.getElementById('collected-powerup-name').textContent = powerup.name;
            document.getElementById('collected-powerup-description').textContent = powerup.description;

            const totalCount = Array.from(powerupInventory.values()).reduce((sum, count) => sum + count, 0);
            document.getElementById('powerup-inventory-count').textContent = totalCount;

            modal.classList.remove('hidden');
            setTimeout(() => {
                const content = modal.querySelector('div');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);

            // Auto-close after 3 seconds
            setTimeout(() => {
                closePowerupCollectionModal();
            }, 3000);
        }

        function closePowerupCollectionModal() {
            const modal = document.getElementById('powerup-collection-modal');
            const content = modal.querySelector('div');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        function updatePowerupInventoryDisplay() {
            const container = document.getElementById('powerups-inventory');
            const panel = document.getElementById('powerups-panel');
            const competitiveIndicator = document.getElementById('competitive-mode-indicator');
            const secretIndicator = document.getElementById('secret-commands-indicator');

            // Hide power-ups panel and show competitive indicator for Daily Challenge mode
            if (isDailyChallenge) {
                if (panel) {
                    panel.style.display = 'none';
                }
                if (competitiveIndicator) {
                    competitiveIndicator.classList.remove('hidden');
                    competitiveIndicator.querySelector('.font-mono').textContent = '🏆 Daily Challenge';
                }
                if (secretIndicator) {
                    secretIndicator.classList.add('hidden');
                }
                return;
            } else {
                if (panel) {
                    panel.style.display = 'block';
                }
                if (competitiveIndicator) {
                    competitiveIndicator.classList.add('hidden');
                }
            }

            // Show secret commands indicator if secret commands were used
            if (secretIndicator) {
                if (secretCommandsUsed) {
                    secretIndicator.classList.remove('hidden');
                } else {
                    secretIndicator.classList.add('hidden');
                }
            }

            container.innerHTML = '';

            // Show only power-ups that the player has
            const availablePowerups = Object.values(POWERUP_TYPES).filter(powerup => {
                const count = powerupInventory.get(powerup.id) || 0;
                return count > 0;
            });

            if (availablePowerups.length === 0) {
                // Show a compact message when no power-ups available
                const emptyEl = document.createElement('div');
                emptyEl.className = 'text-xs text-white/60 font-mono';
                emptyEl.textContent = 'none';
                container.appendChild(emptyEl);
                return;
            }

            // Show available power-ups in compact format matching timer style
            availablePowerups.forEach(powerup => {
                const count = powerupInventory.get(powerup.id) || 0;

                const powerupEl = document.createElement('div');
                powerupEl.className = 'relative bg-white/20 hover:bg-white/30 rounded-full w-6 h-6 cursor-pointer transition-all flex items-center justify-center text-xs';
                powerupEl.innerHTML = `
                    ${powerup.icon}
                    ${count > 1 ? `<div class="absolute -top-1 -right-1 w-3 h-3 bg-yellow-400 text-black text-xs rounded-full flex items-center justify-center font-bold" style="font-size: 8px;">${count}</div>` : ''}
                `;

                powerupEl.addEventListener('click', () => usePowerup(powerup.id));
                powerupEl.title = `${powerup.name}: ${powerup.description} (${count} available)`;

                container.appendChild(powerupEl);
            });
        }

        function usePowerup(powerupId) {
            // Disable power-up usage for Daily Challenge mode
            if (isDailyChallenge) {
                return; // No power-up usage in competitive modes
            }

            const count = powerupInventory.get(powerupId) || 0;
            if (count <= 0) return;

            const powerup = POWERUP_TYPES[powerupId.toUpperCase()];
            if (!powerup) return;

            // Consume power-up
            powerupInventory.set(powerup.id, count - 1);
            savePowerupInventory();

            // Apply effect
            applyPowerupEffect(powerup);

            // Track power-up usage achievements
            if (!achievements.time_master.unlocked && powerup.id === 'time_freeze') {
                achievements.time_master.unlocked = true;
                showAchievementNotification([achievements.time_master]);
                saveAchievements();
            }

            if (!achievements.multiplier_madness.unlocked && (powerup.id === 'point_multiplier' || powerup.id === 'mega_multiplier')) {
                achievements.multiplier_madness.unlocked = true;
                showAchievementNotification([achievements.multiplier_madness]);
                saveAchievements();
            }

            // Check for power combo achievement
            if (!achievements.power_combo.unlocked && activePowerups.size >= 3) {
                achievements.power_combo.unlocked = true;
                showAchievementNotification([achievements.power_combo]);
                saveAchievements();
            }

            // Update display
            updatePowerupInventoryDisplay();

            // Show usage feedback
            showPowerupUsageEffect(powerup);
        }

        function applyPowerupEffect(powerup) {
            switch (powerup.id) {
                case 'time_freeze':
                    activatePowerup('timeFreeze', powerup.duration);
                    powerupEffects.timeFreeze = true;
                    break;

                case 'word_hint':
                    showWordHint();
                    break;

                case 'letter_shuffle':
                    shuffleGridLetters();
                    break;

                case 'point_multiplier':
                    activatePowerup('pointMultiplier', powerup.duration, powerup.multiplier);
                    powerupEffects.pointMultiplier = powerup.multiplier;
                    break;

                case 'mega_multiplier':
                    activatePowerup('pointMultiplier', powerup.duration, powerup.multiplier);
                    powerupEffects.pointMultiplier = powerup.multiplier;
                    break;

                case 'extra_time':
                    if (currentGameMode === GAME_MODE.TIMED || isDailyChallenge) {
                        timer += powerup.timeBonus;
                        updateTimerDisplay();
                    }
                    break;

                case 'word_magnet':
                    activatePowerup('wordMagnet', powerup.duration);
                    powerupEffects.wordMagnet = true;
                    highlightLongWords();
                    break;

                case 'lucky_grid':
                    generateLuckyGrid();
                    break;
            }
        }

        function activatePowerup(effectName, duration, value = true) {
            const endTime = Date.now() + duration;
            activePowerups.set(effectName, {endTime, value});

            // Set up automatic deactivation
            setTimeout(() => {
                deactivatePowerup(effectName);
            }, duration);
        }

        function deactivatePowerup(effectName) {
            activePowerups.delete(effectName);

            switch (effectName) {
                case 'timeFreeze':
                    powerupEffects.timeFreeze = false;
                    break;
                case 'pointMultiplier':
                    powerupEffects.pointMultiplier = 1;
                    break;
                case 'wordMagnet':
                    powerupEffects.wordMagnet = false;
                    removeWordHighlights();
                    break;
            }
        }

        function showWordHint() {
            const possibleWords = findAllPossibleWords();
            if (possibleWords.length === 0) return;

            // Filter out already found words
            const unfoundWords = possibleWords.filter(word => !foundWords.has(word));
            if (unfoundWords.length === 0) return;

            // Select a random unfound word
            const hintWord = unfoundWords[Math.floor(Math.random() * unfoundWords.length)];

            // Show hint
            const hintEl = document.createElement('div');
            hintEl.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-yellow-500 text-white px-6 py-3 rounded-lg shadow-lg z-50 animate-pulse';
            hintEl.innerHTML = `
                <div class="text-center">
                    <div class="text-lg font-bold">💡 Word Hint</div>
                    <div class="text-xl font-mono">${hintWord}</div>
                </div>
            `;

            document.body.appendChild(hintEl);

            setTimeout(() => {
                document.body.removeChild(hintEl);
            }, 3000);
        }

        function shuffleGridLetters() {
            // Preserve found words by not shuffling their paths
            const newGrid = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                newGrid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    const randomIndex = Math.floor(Math.random() * LETTER_DISTRIBUTION.length);
                    newGrid[i][j] = LETTER_DISTRIBUTION[randomIndex];
                }
            }

            grid = newGrid;
            renderGrid();

            // Show shuffle effect
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.classList.add('animate-spin');
                setTimeout(() => {
                    tile.classList.remove('animate-spin');
                }, 500);
            });
        }

        function highlightLongWords() {
            const possibleWords = findAllPossibleWords();
            const longWords = possibleWords.filter(word => word.length >= 6);

            // This would highlight tiles that form long words
            // Implementation would depend on word path finding
            console.log('Highlighting long words:', longWords);
        }

        function removeWordHighlights() {
            // Remove any word highlighting effects
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.classList.remove('ring-2', 'ring-pink-400');
            });
        }

        function generateLuckyGrid() {
            // Generate a grid with high-value letters
            const highValueLetters = "QXZJKWVYFHPBCGMDULNTSRAOEI";
            const newGrid = [];

            for (let i = 0; i < GRID_SIZE; i++) {
                newGrid[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    const randomIndex = Math.floor(Math.random() * highValueLetters.length);
                    newGrid[i][j] = highValueLetters[randomIndex];
                }
            }

            grid = newGrid;
            renderGrid();

            // Show lucky effect
            const tiles = document.querySelectorAll('.tile');
            tiles.forEach(tile => {
                tile.classList.add('animate-bounce');
                setTimeout(() => {
                    tile.classList.remove('animate-bounce');
                }, 1000);
            });
        }

        function showPowerupUsageEffect(powerup) {
            const effectEl = document.createElement('div');
            effectEl.className = 'fixed top-16 left-1/2 transform -translate-x-1/2 bg-white border border-blue-300 px-3 py-1 rounded-full shadow-md z-50 animate-pulse';
            effectEl.innerHTML = `
                <div class="flex items-center space-x-1">
                    <div class="text-lg">${powerup.icon}</div>
                    <div class="text-xs font-bold text-blue-600">${powerup.name}</div>
                </div>
            `;

            document.body.appendChild(effectEl);

            setTimeout(() => {
                document.body.removeChild(effectEl);
            }, 1500);
        }

        // Daily Challenge Functions
        function getDailyChallengeId() {
            const today = new Date();
            return today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
        }

        function getDailyChallengeDate() {
            const today = new Date();
            return today.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
        }

        function getDailyChallengeInfo() {
            const today = new Date();
            const startDate = DAILY_CHALLENGE_CONFIG.startDate;

            // Calculate days since start
            const timeDiff = today.getTime() - startDate.getTime();
            const daysSinceStart = Math.floor(timeDiff / (1000 * 3600 * 24));

            // Handle dates before start date
            if (daysSinceStart < 0) {
                return {
                    challengeNumber: 1,
                    seed: DAILY_CHALLENGE_CONFIG.seeds[0],
                    theme: DAILY_CHALLENGE_CONFIG.themes[0],
                    isActive: false,
                    daysUntilStart: Math.abs(daysSinceStart)
                };
            }

            // Handle dates beyond our 100-day range
            if (daysSinceStart >= 100) {
                // Cycle through the challenges again
                const cycleDay = daysSinceStart % 100;
                const cycleNumber = Math.floor(daysSinceStart / 100) + 1;

                return {
                    challengeNumber: daysSinceStart + 1,
                    seed: DAILY_CHALLENGE_CONFIG.seeds[cycleDay],
                    theme: DAILY_CHALLENGE_CONFIG.themes[cycleDay % DAILY_CHALLENGE_CONFIG.themes.length],
                    isActive: true,
                    cycle: cycleNumber
                };
            }

            // Normal case: within first 100 days
            return {
                challengeNumber: daysSinceStart + 1,
                seed: DAILY_CHALLENGE_CONFIG.seeds[daysSinceStart],
                theme: DAILY_CHALLENGE_CONFIG.themes[daysSinceStart % DAILY_CHALLENGE_CONFIG.themes.length],
                isActive: true
            };
        }

        function generateDailyGrid(challengeInfo) {
            // Use the pre-generated seed for deterministic grid generation
            const seed = challengeInfo.seed;
            const random = seedRandom(seed);

            // Use theme-specific grid size
            const gridSize = challengeInfo.theme.gridSize;

            const dailyGrid = [];
            for (let i = 0; i < gridSize; i++) {
                dailyGrid[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    const randomIndex = Math.floor(random() * LETTER_DISTRIBUTION.length);
                    dailyGrid[i][j] = LETTER_DISTRIBUTION[randomIndex];
                }
            }
            return dailyGrid;
        }

        function seedRandom(seed) {
            // Simple seeded random number generator
            let m = 0x80000000; // 2**31
            let a = 1103515245;
            let c = 12345;
            let state = seed ? seed : Math.floor(Math.random() * (m - 1));

            return function() {
                state = (a * state + c) % m;
                return state / (m - 1);
            };
        }

        function loadDailyChallengeData() {
            try {
                const saved = localStorage.getItem(DAILY_CHALLENGE_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    dailyChallengeData.currentStreak = parsed.currentStreak || 0;
                    dailyChallengeData.lastPlayedDate = parsed.lastPlayedDate;
                    dailyChallengeData.completedChallenges = new Map(parsed.completedChallenges || []);
                    dailyChallengeData.streakBadges = new Set(parsed.streakBadges || []);
                }
            } catch (error) {
                console.error('Error loading daily challenge data:', error);
            }
        }

        function saveDailyChallengeData() {
            try {
                const toSave = {
                    currentStreak: dailyChallengeData.currentStreak,
                    lastPlayedDate: dailyChallengeData.lastPlayedDate,
                    completedChallenges: Array.from(dailyChallengeData.completedChallenges.entries()),
                    streakBadges: Array.from(dailyChallengeData.streakBadges)
                };
                localStorage.setItem(DAILY_CHALLENGE_KEY, JSON.stringify(toSave));
            } catch (error) {
                console.error('Error saving daily challenge data:', error);
            }
        }

        function openDailyChallengeModal() {
            const modal = document.getElementById('daily-challenge-modal');
            const challengeId = getDailyChallengeId();
            const challengeInfo = getDailyChallengeInfo();
            currentChallengeId = challengeId;

            // Update modal content
            document.getElementById('daily-challenge-date').textContent = getDailyChallengeDate();
            document.getElementById('challenge-number').textContent = challengeInfo.challengeNumber;
            document.getElementById('current-streak').textContent = `${dailyChallengeData.currentStreak} days`;

            // Update challenge info based on theme
            const gridSizeEl = document.getElementById('challenge-grid-size');
            const timeLimitText = document.querySelector('#daily-challenge-info .text-sm .font-medium:nth-child(2)');

            if (gridSizeEl) {
                gridSizeEl.textContent = `${challengeInfo.theme.gridSize}x${challengeInfo.theme.gridSize}`;
            }

            // Update time limit display
            const timeLimitEl = gridSizeEl.parentElement.children[1];
            if (timeLimitEl) {
                timeLimitEl.innerHTML = `Time Limit: <span class="font-medium">${challengeInfo.theme.timeLimit} seconds</span>`;
            }

            // Show theme name
            const themeEl = document.createElement('div');
            themeEl.className = 'text-sm text-emerald-600 font-medium';
            themeEl.textContent = `Theme: ${challengeInfo.theme.name}`;

            // Check if challenge is active
            if (!challengeInfo.isActive) {
                document.getElementById('challenge-status').textContent = `Starts in ${challengeInfo.daysUntilStart} days`;
                document.getElementById('start-daily-challenge').textContent = '⏳ Coming Soon';
                document.getElementById('start-daily-challenge').disabled = true;
            } else {
                // Check if already completed today
                const todayData = dailyChallengeData.completedChallenges.get(challengeId);
                if (todayData && todayData.completed) {
                    document.getElementById('challenge-status').textContent = 'Completed';
                    document.getElementById('today-score').textContent = todayData.score;
                    document.getElementById('today-rank').textContent = `#${todayData.rank || '--'}`;
                    document.getElementById('start-daily-challenge').textContent = '✅ Already Completed';
                    document.getElementById('start-daily-challenge').disabled = true;
                } else {
                    document.getElementById('challenge-status').textContent = 'Not Started';
                    document.getElementById('today-score').textContent = '--';
                    document.getElementById('today-rank').textContent = '--';
                    document.getElementById('start-daily-challenge').textContent = '🚀 Start Today\'s Challenge';
                    document.getElementById('start-daily-challenge').disabled = false;
                }
            }

            // Show cycle information if applicable
            if (challengeInfo.cycle) {
                const cycleInfo = document.createElement('div');
                cycleInfo.className = 'text-xs text-gray-500 mt-1';
                cycleInfo.textContent = `Cycle ${challengeInfo.cycle} • Challenge ${challengeInfo.challengeNumber}`;
                document.getElementById('daily-challenge-info').appendChild(cycleInfo);
            }

            // Update streak badges
            updateStreakBadges();

            // Show upcoming challenges
            updateUpcomingChallenges();

            // Show modal
            modal.classList.remove('hidden');
            setTimeout(() => {
                const content = modal.querySelector('div');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function updateUpcomingChallenges() {
            const container = document.getElementById('upcoming-challenges-list');
            if (!container) return;

            container.innerHTML = '';

            // Show next 3 days
            for (let i = 1; i <= 3; i++) {
                const preview = getDailyChallengePreview(i);
                if (!preview) continue;

                const challengeEl = document.createElement('div');
                challengeEl.className = 'flex justify-between items-center text-xs bg-gray-50 rounded p-2';
                challengeEl.innerHTML = `
                    <div>
                        <span class="font-medium">Day ${i}: Challenge #${preview.challengeNumber}</span>
                        <span class="text-gray-500 ml-2">${preview.theme.name}</span>
                    </div>
                    <div class="text-gray-400">
                        ${preview.theme.gridSize}x${preview.theme.gridSize} • ${preview.theme.timeLimit}s
                    </div>
                `;

                container.appendChild(challengeEl);
            }
        }

        function updateStreakBadges() {
            const badges = document.querySelectorAll('.badge-item');
            badges.forEach(badge => {
                const requiredStreak = parseInt(badge.dataset.streak);
                if (dailyChallengeData.currentStreak >= requiredStreak || dailyChallengeData.streakBadges.has(requiredStreak)) {
                    badge.classList.add('bg-yellow-100', 'text-yellow-800');
                    badge.classList.remove('bg-gray-100', 'text-gray-500');
                } else {
                    badge.classList.add('bg-gray-100', 'text-gray-500');
                    badge.classList.remove('bg-yellow-100', 'text-yellow-800');
                }
            });
        }

        function closeDailyChallengeModal() {
            const modal = document.getElementById('daily-challenge-modal');
            const content = modal.querySelector('div');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        function startDailyChallenge() {
            const challengeInfo = getDailyChallengeInfo();

            // Check if challenge is active
            if (!challengeInfo.isActive) {
                alert(`Daily challenge starts in ${challengeInfo.daysUntilStart} days!`);
                return;
            }

            isDailyChallenge = true;
            currentGameMode = GAME_MODE.DAILY_CHALLENGE;

            // Use theme-specific settings
            GRID_SIZE = challengeInfo.theme.gridSize;
            currentBoardSize = challengeInfo.theme.gridSize === 4 ? BOARD_SIZE.SMALL : BOARD_SIZE.LARGE;

            // Generate today's grid using challenge info
            grid = generateDailyGrid(challengeInfo);

            closeDailyChallengeModal();
            hideOpeningUI();
            updateGridLayout();

            // Reset game state with theme-specific timer
            score = 0;
            foundWords = new Set();
            timer = challengeInfo.theme.timeLimit;

            // Start the game
            renderGrid();
            startTimer();

            console.log(`Daily challenge started: ${challengeInfo.theme.name} (${challengeInfo.theme.gridSize}x${challengeInfo.theme.gridSize}, ${challengeInfo.theme.timeLimit}s)`);
        }

        function completeDailyChallenge() {
            if (!isDailyChallenge) return;

            // Don't save to leaderboard if secret commands were used
            if (secretCommandsUsed) {
                console.log("Daily challenge score not saved to leaderboard: secret commands were used");

                // Show notification
                const notification = document.createElement('div');
                notification.className = 'fixed top-4 right-4 bg-red-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-500';
                notification.innerHTML = `
                    <div class="flex items-center space-x-2">
                        <span class="text-xl">🚫</span>
                        <div>
                            <div class="font-bold">Challenge Invalid</div>
                            <div class="text-sm opacity-90">Secret commands were used</div>
                        </div>
                    </div>
                `;

                document.body.appendChild(notification);

                // Animate in
                setTimeout(() => {
                    notification.classList.remove('translate-x-full');
                }, 100);

                // Auto-hide after 4 seconds
                setTimeout(() => {
                    notification.classList.add('translate-x-full');
                    setTimeout(() => {
                        if (document.body.contains(notification)) {
                            document.body.removeChild(notification);
                        }
                    }, 500);
                }, 4000);

                // Reset daily challenge state and return to menu
                isDailyChallenge = false;
                currentChallengeId = null;
                showOpeningUI();
                return;
            }

            // Calculate rank (simulated for now)
            const rank = calculateDailyRank(score);

            // Update challenge data
            dailyChallengeData.completedChallenges.set(currentChallengeId, {
                score: score,
                words: foundWords.size,
                completed: true,
                rank: rank,
                date: new Date().toISOString()
            });

            // Update streak
            updateDailyStreak();

            // Save data
            saveDailyChallengeData();

            // Add to leaderboard
            addToLeaderboard(score, foundWords.size);

            // Check daily challenge achievements
            checkDailyChallengeAchievements(rank);

            // Show results modal
            showDailyChallengeResults(rank);
        }

        function updateDailyStreak() {
            const today = new Date();
            const todayStr = today.toDateString();

            if (dailyChallengeData.lastPlayedDate) {
                const lastPlayed = new Date(dailyChallengeData.lastPlayedDate);
                const lastPlayedStr = lastPlayed.toDateString();

                if (lastPlayedStr === todayStr) {
                    // Already played today, don't update streak
                    return;
                }

                const daysDiff = Math.floor((today - lastPlayed) / (1000 * 60 * 60 * 24));

                if (daysDiff === 1) {
                    // Consecutive day
                    dailyChallengeData.currentStreak++;
                } else if (daysDiff > 1) {
                    // Streak broken
                    dailyChallengeData.currentStreak = 1;
                }
            } else {
                // First time playing
                dailyChallengeData.currentStreak = 1;
            }

            dailyChallengeData.lastPlayedDate = todayStr;

            // Check for new streak badges
            checkStreakBadges();
        }

        function checkStreakBadges() {
            const streakMilestones = [3, 7, 30, 100];
            let newBadge = null;

            streakMilestones.forEach(milestone => {
                if (dailyChallengeData.currentStreak >= milestone && !dailyChallengeData.streakBadges.has(milestone)) {
                    dailyChallengeData.streakBadges.add(milestone);
                    newBadge = milestone;
                }
            });

            return newBadge;
        }

        function checkDailyChallengeAchievements(rank) {
            const achievementsToCheck = [];

            // Daily debut
            if (!achievements.daily_debut.unlocked) {
                achievements.daily_debut.unlocked = true;
                achievementsToCheck.push(achievements.daily_debut);
            }

            // Streak achievements
            if (dailyChallengeData.currentStreak >= 3 && !achievements.streak_starter.unlocked) {
                achievements.streak_starter.unlocked = true;
                achievementsToCheck.push(achievements.streak_starter);
            }

            if (dailyChallengeData.currentStreak >= 7 && !achievements.weekly_champion.unlocked) {
                achievements.weekly_champion.unlocked = true;
                achievementsToCheck.push(achievements.weekly_champion);
            }

            if (dailyChallengeData.currentStreak >= 30 && !achievements.monthly_legend.unlocked) {
                achievements.monthly_legend.unlocked = true;
                achievementsToCheck.push(achievements.monthly_legend);
            }

            if (dailyChallengeData.currentStreak >= 100 && !achievements.century_streak.unlocked) {
                achievements.century_streak.unlocked = true;
                achievementsToCheck.push(achievements.century_streak);
            }

            // Score achievements
            if (score >= 2000 && !achievements.daily_perfectionist.unlocked) {
                achievements.daily_perfectionist.unlocked = true;
                achievementsToCheck.push(achievements.daily_perfectionist);
            }

            // Rank achievements
            if (rank === 1 && !achievements.daily_champion.unlocked) {
                achievements.daily_champion.unlocked = true;
                achievementsToCheck.push(achievements.daily_champion);
            }

            if (rank <= 3 && !achievements.daily_podium.unlocked) {
                achievements.daily_podium.unlocked = true;
                achievementsToCheck.push(achievements.daily_podium);
            }

            // Show achievement notifications
            if (achievementsToCheck.length > 0) {
                showAchievementNotification(achievementsToCheck);
                saveAchievements();
            }
        }

        function calculateDailyRank(playerScore) {
            // Simulate ranking based on score
            // In a real implementation, this would query a server
            const leaderboard = getDailyLeaderboard();
            let rank = 1;

            leaderboard.forEach(entry => {
                if (entry.score > playerScore) {
                    rank++;
                }
            });

            return rank;
        }

        function addToLeaderboard(playerScore, wordsFound) {
            let leaderboard = getDailyLeaderboard();

            // Add current player's score
            leaderboard.push({
                score: playerScore,
                words: wordsFound,
                date: new Date().toISOString(),
                challengeId: currentChallengeId,
                name: 'You' // In real implementation, would use player name
            });

            // Sort by score descending
            leaderboard.sort((a, b) => b.score - a.score);

            // Keep top 100
            leaderboard = leaderboard.slice(0, 100);

            // Save leaderboard
            saveDailyLeaderboard(leaderboard);
        }

        function getDailyLeaderboard() {
            try {
                const saved = localStorage.getItem(DAILY_LEADERBOARD_KEY + '_' + currentChallengeId);
                return saved ? JSON.parse(saved) : [];
            } catch (error) {
                console.error('Error loading daily leaderboard:', error);
                return [];
            }
        }

        function saveDailyLeaderboard(leaderboard) {
            try {
                localStorage.setItem(DAILY_LEADERBOARD_KEY + '_' + currentChallengeId, JSON.stringify(leaderboard));
            } catch (error) {
                console.error('Error saving daily leaderboard:', error);
            }
        }

        function showDailyChallengeResults(rank) {
            const modal = document.getElementById('daily-results-modal');

            // Update results
            document.getElementById('final-challenge-score').textContent = score;
            document.getElementById('final-rank').textContent = `#${rank}`;
            document.getElementById('final-words').textContent = foundWords.size;
            document.getElementById('new-streak').textContent = dailyChallengeData.currentStreak;

            // Check for new badge
            const newBadge = checkStreakBadges();
            const badgeEarned = document.getElementById('badge-earned');

            if (newBadge) {
                const badgeIcon = document.getElementById('earned-badge-icon');
                const badgeText = document.getElementById('earned-badge-text');

                let icon = '🔥';
                let text = `${newBadge}-Day Streak!`;

                if (newBadge === 7) { icon = '⭐'; text = 'Week Streak!'; }
                else if (newBadge === 30) { icon = '💎'; text = 'Month Streak!'; }
                else if (newBadge === 100) { icon = '👑'; text = 'Legend Streak!'; }

                badgeIcon.textContent = icon;
                badgeText.textContent = text;
                badgeEarned.classList.remove('hidden');
            } else {
                badgeEarned.classList.add('hidden');
            }

            // Show modal
            modal.classList.remove('hidden');
            setTimeout(() => {
                const content = modal.querySelector('div');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function showDailyLeaderboard() {
            const modal = document.getElementById('daily-leaderboard-modal');
            const leaderboard = getDailyLeaderboard();
            const leaderboardList = document.getElementById('leaderboard-list');

            // Update date
            document.getElementById('leaderboard-date').textContent = getDailyChallengeDate();

            // Clear and populate leaderboard
            leaderboardList.innerHTML = '';

            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<div class="text-center py-4 text-gray-500">No scores yet today</div>';
            } else {
                leaderboard.slice(0, 20).forEach((entry, index) => {
                    const row = document.createElement('div');
                    row.className = `flex justify-between items-center py-2 px-3 rounded-lg ${entry.name === 'You' ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'}`;

                    let rankDisplay = `${index + 1}.`;
                    if (index === 0) rankDisplay = '🥇';
                    else if (index === 1) rankDisplay = '🥈';
                    else if (index === 2) rankDisplay = '🥉';

                    row.innerHTML = `
                        <div class="flex items-center space-x-2">
                            <span class="font-medium">${rankDisplay}</span>
                            <span class="${entry.name === 'You' ? 'font-bold text-blue-600' : ''}">${entry.name}</span>
                        </div>
                        <div class="text-right">
                            <div class="font-bold">${entry.score}</div>
                            <div class="text-xs text-gray-500">${entry.words} words</div>
                        </div>
                    `;

                    leaderboardList.appendChild(row);
                });
            }

            // Show modal
            modal.classList.remove('hidden');
            setTimeout(() => {
                const content = modal.querySelector('div');
                content.classList.remove('scale-95', 'opacity-0');
            }, 10);
        }

        function closeDailyLeaderboard() {
            const modal = document.getElementById('daily-leaderboard-modal');
            const content = modal.querySelector('div');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
            }, 300);
        }

        function closeDailyResults() {
            const modal = document.getElementById('daily-results-modal');
            const content = modal.querySelector('div');
            content.classList.add('scale-95', 'opacity-0');
            setTimeout(() => {
                modal.classList.add('hidden');
                // Reset daily challenge state
                isDailyChallenge = false;
                currentChallengeId = null;
                // Return to opening UI
                showOpeningUI();
            }, 300);
        }

        function shareScore() {
            const challengeData = dailyChallengeData.completedChallenges.get(currentChallengeId);
            if (!challengeData) return;

            const shareText = `🎯 Word Hunt Daily Challenge #${currentChallengeId}\n` +
                             `📊 Score: ${challengeData.score} points\n` +
                             `📝 Words: ${challengeData.words}\n` +
                             `🏆 Rank: #${challengeData.rank}\n` +
                             `🔥 Streak: ${dailyChallengeData.currentStreak} days\n\n` +
                             `Play today's challenge!`;

            if (navigator.share) {
                navigator.share({
                    title: 'Word Hunt Daily Challenge',
                    text: shareText
                });
            } else {
                // Fallback: copy to clipboard
                navigator.clipboard.writeText(shareText).then(() => {
                    alert('Score copied to clipboard!');
                }).catch(() => {
                    // Final fallback: show in alert
                    alert(shareText);
                });
            }
        }

        function setupDailyChallengeListeners() {
            // Daily challenge modal buttons
            document.getElementById('start-daily-challenge').addEventListener('click', startDailyChallenge);
            document.getElementById('view-daily-leaderboard').addEventListener('click', showDailyLeaderboard);
            document.getElementById('close-daily-challenge').addEventListener('click', closeDailyChallengeModal);

            // Leaderboard modal buttons
            document.getElementById('close-leaderboard').addEventListener('click', closeDailyLeaderboard);
            document.getElementById('share-score').addEventListener('click', shareScore);

            // Results modal buttons
            document.getElementById('view-leaderboard-from-results').addEventListener('click', () => {
                closeDailyResults();
                setTimeout(showDailyLeaderboard, 100);
            });
            document.getElementById('share-daily-result').addEventListener('click', shareScore);
            document.getElementById('close-daily-results').addEventListener('click', closeDailyResults);
        }

        // Automatic daily challenge management
        function initializeDailyChallengeSystem() {
            console.log('Initializing daily challenge system...');

            // Check for new daily challenge
            checkForNewDailyChallenge();

            // Set up automatic checking every hour
            setInterval(checkForNewDailyChallenge, 60 * 60 * 1000); // Check every hour

            // Set up midnight checker for immediate updates
            scheduleNextMidnightCheck();
        }

        function checkForNewDailyChallenge() {
            const challengeInfo = getDailyChallengeInfo();
            const today = getDailyChallengeId();

            console.log(`Daily Challenge #${challengeInfo.challengeNumber}: ${challengeInfo.theme.name}`);

            // Update daily challenge button with current info
            updateDailyChallengeButton(challengeInfo);

            // Check if player has missed days (for streak tracking)
            checkMissedDays();
        }

        function updateDailyChallengeButton(challengeInfo) {
            const button = document.getElementById('opening-daily-challenge-btn');
            if (!button) return;

            const today = getDailyChallengeId();
            const todayData = dailyChallengeData.completedChallenges.get(today);
            const isCompleted = todayData && todayData.completed;

            // Update button text based on status
            if (!challengeInfo.isActive) {
                button.innerHTML = `📅 Daily Challenge<br><span class="text-xs opacity-75">Starts in ${challengeInfo.daysUntilStart} days</span>`;
                button.disabled = true;
                button.classList.add('opacity-50');
            } else if (isCompleted) {
                button.innerHTML = `📅 Daily Challenge<br><span class="text-xs opacity-75">✅ Completed (#${challengeInfo.challengeNumber})</span>`;
                button.disabled = false;
                button.classList.remove('opacity-50');
            } else {
                button.innerHTML = `📅 Daily Challenge<br><span class="text-xs opacity-75">#${challengeInfo.challengeNumber} • ${challengeInfo.theme.name}</span>`;
                button.disabled = false;
                button.classList.remove('opacity-50');

                // Add subtle animation for new challenges
                button.classList.add('animate-pulse');
                setTimeout(() => {
                    button.classList.remove('animate-pulse');
                }, 3000);
            }
        }

        function scheduleNextMidnightCheck() {
            const now = new Date();
            const tomorrow = new Date(now);
            tomorrow.setDate(tomorrow.getDate() + 1);
            tomorrow.setHours(0, 0, 1, 0); // 1 second after midnight

            const msUntilMidnight = tomorrow.getTime() - now.getTime();

            setTimeout(() => {
                console.log('🌅 New day detected! Checking for new daily challenge...');
                checkForNewDailyChallenge();

                // Schedule the next check
                scheduleNextMidnightCheck();

                // Show notification for new challenge
                showNewDayChallengeNotification();
            }, msUntilMidnight);

            console.log(`Next daily challenge check scheduled in ${Math.round(msUntilMidnight / 1000 / 60)} minutes`);
        }

        function showNewDayChallengeNotification() {
            const challengeInfo = getDailyChallengeInfo();

            if (!challengeInfo.isActive) return;

            const notification = document.createElement('div');
            notification.className = 'fixed top-4 right-4 bg-emerald-500 text-white px-4 py-3 rounded-lg shadow-lg z-50 transform translate-x-full transition-transform duration-500';
            notification.innerHTML = `
                <div class="flex items-center space-x-2">
                    <span class="text-xl">📅</span>
                    <div>
                        <div class="font-bold">New Daily Challenge!</div>
                        <div class="text-sm opacity-90">#${challengeInfo.challengeNumber} • ${challengeInfo.theme.name}</div>
                    </div>
                </div>
            `;

            document.body.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 100);

            // Auto-hide after 5 seconds
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 500);
            }, 5000);
        }

        function checkMissedDays() {
            if (!dailyChallengeData.lastPlayedDate) return;

            const lastPlayed = new Date(dailyChallengeData.lastPlayedDate);
            const today = new Date();
            const daysDiff = Math.floor((today - lastPlayed) / (1000 * 60 * 60 * 24));

            // If more than 1 day has passed, streak is broken
            if (daysDiff > 1) {
                if (dailyChallengeData.currentStreak > 0) {
                    console.log(`Streak broken: ${daysDiff} days missed`);
                    dailyChallengeData.currentStreak = 0;
                    saveDailyChallengeData();
                }
            }
        }

        function getDailyChallengePreview(daysAhead = 0) {
            const targetDate = new Date();
            targetDate.setDate(targetDate.getDate() + daysAhead);

            const startDate = DAILY_CHALLENGE_CONFIG.startDate;
            const timeDiff = targetDate.getTime() - startDate.getTime();
            const daysSinceStart = Math.floor(timeDiff / (1000 * 3600 * 24));

            if (daysSinceStart < 0 || daysSinceStart >= 100) {
                return null;
            }

            return {
                date: targetDate.toLocaleDateString(),
                challengeNumber: daysSinceStart + 1,
                theme: DAILY_CHALLENGE_CONFIG.themes[daysSinceStart % DAILY_CHALLENGE_CONFIG.themes.length],
                seed: DAILY_CHALLENGE_CONFIG.seeds[daysSinceStart]
            };
        }

        function setupPowerupListeners() {
            // Power-up collection modal
            document.getElementById('close-powerup-modal').addEventListener('click', closePowerupCollectionModal);

            // Power-up shop modal
            document.getElementById('close-powerup-shop').addEventListener('click', () => {
                const modal = document.getElementById('powerup-shop-modal');
                const content = modal.querySelector('div');
                content.classList.add('scale-95', 'opacity-0');
                setTimeout(() => {
                    modal.classList.add('hidden');
                }, 300);
            });
        }

        // Initialize the game when the page loads
        window.onload = async function() {
            console.log("Window loaded");

            // Load the dictionary first
            await loadDictionary();

            // Load achievements and statistics
            loadAchievements();

            // Load high scores
            loadHighScores();

            // Load daily challenge data
            loadDailyChallengeData();

            // Initialize daily challenge system
            initializeDailyChallengeSystem();

            // Load power-up inventory
            loadPowerupInventory();

            // Load analytics data
            loadAnalyticsData();

            // Load tutorial data
            loadTutorialData();

            // Set up event listeners
            setupEventListeners();
            setupOpeningUI();
            setupDailyChallengeListeners();
            setupPowerupListeners();

            // Set up secret menu
            setupSecretMenu();

            // Add the secret dot
            addSecretDot();

            // Setup mobile touch pattern detection
            setupMobileTouchPattern();

            // Refresh secret dots periodically to ensure they appear in all modes
            setInterval(() => {
                addSecretDot();
            }, 2000);

            // Initialize board size selection
            updateBoardSizeSelection();

            // Initialize tooltips
            initializeTooltips();

            // Show opening UI instead of starting game
            showOpeningUI();

            // Check if this is a first-time user and offer tutorial
            if (isFirstTimeUser()) {
                setTimeout(() => {
                    showFirstTimeUserPrompt();
                }, 1000);
            }

            // Make key functions available globally for debugging
            window.endGame = endGame;
            window.startNewGame = init;
            window.showAllWords = showAllPossibleWords;
            window.showMenu = showOpeningUI;
            window.debugStorage = debugLocalStorage;
            window.resetData = resetAllData;

            // Make tutorial functions globally accessible
            window.nextTutorialStep = nextTutorialStep;
            window.previousTutorialStep = previousTutorialStep;
            window.skipTutorialStep = skipTutorialStep;
            window.startTutorialDemo = startTutorialDemo;
            window.showTutorialHint = showTutorialHint;
            window.completeTutorialAndStartGame = completeTutorialAndStartGame;
            window.startFirstTimeTutorial = startFirstTimeTutorial;
            window.skipFirstTimeTutorial = skipFirstTimeTutorial;

            console.log("Game ready! You can use these console commands:");
            console.log("- endGame() - End the current game");
            console.log("- startNewGame() - Start a new game");
            console.log("- showMenu() - Show the opening menu");
            console.log("- debugStorage() - Check localStorage contents");
            console.log("- resetData() - Reset all game data (use with caution)");
        }
    </script>
</body>
</html>
